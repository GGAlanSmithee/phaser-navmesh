<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">library/nav-poly.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
<link data-ice="userStyle" rel="stylesheet" href="user/css/0-injected-style.css">
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/mikewesthad/phaser-navmesh-plugin" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/library/nav-mesh-plugin.js~NavMeshPlugin.html">NavMeshPlugin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/library/nav-mesh.js~NavMesh.html">NavMesh</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">library/nav-poly.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// Debug color palette
const palette = [0x00A0B0, 0x6A4A3C, 0xCC333F, 0xEB6841, 0xEDC951];

/**
 * A class that represents a navigable polygon in a navmesh. It is build from a Phaser.Polygon. It
 * has a drawing function to help visualize it&apos;s features:
 *  - polygon
 *  - neighbors - any navpolys that can be reached from this navpoly
 *  - portals - overlapping edges between neighbors
 *  - centroid - not a true centroid, just an approximation.
 *  - boundingRadius - the radius of a circle at the centroid that fits all the points of the poly 
 * 
 * It implements the properties and fields that javascript-astar needs - weight, toString, isWall
 * and getCost. See GPS test from astar repo for structure: 
 * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js
 *
 * @class NavPoly
 * @private
 */
class NavPoly {
    /**
     * Creates an instance of NavPoly.
     * @param {Phaser.Game} game 
     * @param {number} id 
     * @param {Phaser.Polygon} polygon 
     * 
     * @memberof NavPoly
     */
    constructor(game, id, polygon) {
        this.game = game;
        this.id = id;
        this.polygon = polygon;
        this.edges = this._calculateEdges();
        this.neighbors = [];
        this.portals = [];
        this.centroid = this._calculateCentroid();
        this.boundingRadius = this._calculateRadius();

        this.weight = 1; // jsastar property
        
        const i = this.id % palette.length;
        this._color = palette[i];
    }

    constains(point) {
        return this.polygon.contains(point.x, point.y);
    }

    destroy() {
        this.game = null;
        this.neighbors = [];
        this.portals = [];
    }

    // jsastar methods
    toString() {
        return `NavPoly(id: ${this.id} at: ${this.centroid})`;
    }
    isWall() {
        return this.weight === 0;
    }
    centroidDistance(navPolygon) {
        return this.centroid.distance(navPolygon.centroid);
    }
    getCost(navPolygon) {
        return this.centroidDistance(navPolygon);
    }

    _calculateEdges() {
        const points = this.polygon.points;
        const edges = [];
        for (let i = 1; i &lt; points.length; i++) {
            const p1 = points[i - 1];
            const p2 = points[i];
            edges.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));
        }
        const first = points[0];
        const last = points[points.length - 1]
        edges.push(new Phaser.Line(first.x, first.y, last.x, last.y));
        return edges;
    }
    
    _calculateCentroid() {
        // NOTE: this is not actually the centroid, it&apos;s the average of the vertices - not the same
        // thing!
        const centroid = new Phaser.Point(0, 0);
        const length = this.polygon.points.length;
        for (const point of this.polygon.points) {
            centroid.add(point.x, point.y);
        }
        centroid.divide(length, length);
        return centroid;
    }

    _calculateRadius() {
        let boundingRadius = 0;
        for (const point of this.polygon.points) {
            const d = this.centroid.distance(point);
            if (d &gt; boundingRadius) boundingRadius = d;
        }
        return boundingRadius;
    }

    /**
     * Draw the polygon to given graphics object
     * 
     * @param {Phaser.Graphics} graphics 
     * @param {boolean} [drawCentroid=true] Show the approx centroid
     * @param {boolean} [drawBounds=false] Show the bounding radius
     * @param {boolean} [drawNeighbors=true] Show the connections to neighbors
     * @param {boolean} [drawPortals=true] Show the portal edges
     * 
     * @memberof NavPoly
     */
    draw(graphics, drawCentroid = true, drawBounds = false, drawNeighbors = true, 
            drawPortals = true) {
        graphics.lineWidth = 0;
        graphics.beginFill(this._color);
        graphics.drawPolygon(this.polygon);
        graphics.endFill();

        if (drawCentroid) {
            graphics.beginFill(0x000000);
            graphics.drawEllipse(this.centroid.x, this.centroid.y, 4, 4);
            graphics.endFill();
        }

        if (drawBounds) {
            graphics.lineStyle(1, 0xFFFFFF);
            const r = this.boundingRadius;
            graphics.drawEllipse(this.centroid.x, this.centroid.y, r, r);
        }

        if (drawNeighbors) {
            graphics.lineStyle(2, 0x000000);
            for (const n of this.neighbors) {
                graphics.moveTo(this.centroid.x, this.centroid.y);
                graphics.lineTo(n.centroid.x, n.centroid.y);
            }
        }

        if (drawPortals) {
            graphics.lineStyle(10, 0x000000);
            for (const p of this.portals) {
                graphics.moveTo(p.start.x, p.start.y);
                graphics.lineTo(p.end.x, p.end.y);
            }
        }
    }
}

export default NavPoly;</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
