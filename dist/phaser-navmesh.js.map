{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 7c2d548790e295d9b34b","webpack:///./utils.js","webpack:///E:/Github/navmesh-phaser-plugin/~/javascript-astar/astar.js","webpack:///./nav-mesh-plugin.js","webpack:///./channel.js","webpack:///./index.js","webpack:///./nav-graph.js","webpack:///./nav-mesh.js","webpack:///./nav-poly.js"],"names":["triarea2","a","b","c","ax","x","ay","y","bx","by","almostEqual","value1","value2","errorMargin","Math","abs","angleDifference","i","PI","j","floor","areCollinear","line1","line2","area1","start","end","area2","NavMeshPlugin","game","manager","_navMeshes","tilemap","objectKey","meshShrinkAmount","rects","objects","polygons","r","top","bottom","height","left","right","width","poly","Phaser","Polygon","push","mesh","destroy","Plugin","Channel","portals","p1","p2","pts","portalApex","portalLeft","portalRight","apexIndex","leftIndex","rightIndex","length","equals","path","module","exports","require","default","NavGraph","navPolygons","nodes","init","navPolygon","neighbors","navPolygon1","navPolygon2","centroidDistance","cleanDirty","prototype","jsastar","Graph","markDirty","NavMesh","_debugGraphics","_meshShrinkAmount","_navPolygons","entries","polygon","_calculateNeighbors","_graph","disableDebug","startPoint","endPoint","drawPolyPath","drawFinalPath","startPoly","endPoly","startDistance","Number","MAX_VALUE","endDistance","d","navPoly","boundingRadius","centroid","distance","constains","_projectPointToPolygon","astarPath","astar","search","heuristic","navHeuristic","unshift","channel","nextNavPolygon","portal","id","stringPull","lastPoint","phaserPath","p","newPoint","clone","polyPath","map","elem","debugDrawPath","otherNavPoly","edges","edge","otherEdge","overlap","_getSegmentOverlap","edgeStartAngle","angle","a1","a2","d1","d2","Line","points","line","point","sort","noOverlap","singlePointOverlap","closestProjection","closestDistance","projectedPoint","_projectPointToEdge","dx","dy","l2","_distanceSquared","t","clamp","Point","add","graphics","alpha","clear","drawCentroid","drawBounds","drawNeighbors","drawPortals","enableDebug","draw","color","thickness","lineStyle","drawShape","beginFill","drawEllipse","endFill","palette","NavPoly","_calculateEdges","_calculateCentroid","_calculateRadius","weight","_color","contains","first","last","divide","lineWidth","drawPolygon","n","moveTo","lineTo"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;AChEA;AAAA;;;;AAIO,SAASA,QAAT,CAAkBC,CAAlB,EAAqBC,CAArB,EAAwBC,CAAxB,EAA2B;AAC9B,QAAMC,KAAKF,EAAEG,CAAF,GAAMJ,EAAEI,CAAnB;AACA,QAAMC,KAAKJ,EAAEK,CAAF,GAAMN,EAAEM,CAAnB;AACA,QAAMC,KAAKL,EAAEE,CAAF,GAAMJ,EAAEI,CAAnB;AACA,QAAMI,KAAKN,EAAEI,CAAF,GAAMN,EAAEM,CAAnB;AACA,WAAOC,KAAKF,EAAL,GAAUF,KAAKK,EAAtB;AACH;;AAED;;;AAGO,SAASC,WAAT,CAAqBC,MAArB,EAA6BC,MAA7B,EAA2D;AAAA,QAAtBC,WAAsB,uEAAR,MAAQ;;AAC9D,QAAIC,KAAKC,GAAL,CAASJ,SAASC,MAAlB,KAA6BC,WAAjC,EAA8C,OAAO,IAAP,CAA9C,KACK,OAAO,KAAP;AACR;;AAED;;;;AAIO,SAASG,eAAT,CAAyBX,CAAzB,EAA4BE,CAA5B,EAA+B;AAClC,QAAIN,IAAII,IAAIE,CAAZ;AACA,QAAMU,IAAIhB,IAAIa,KAAKI,EAAnB;AACA,QAAMC,IAAIL,KAAKI,EAAL,GAAU,CAApB;AACAjB,QAAIgB,IAAIH,KAAKM,KAAL,CAAWH,IAAIE,CAAf,IAAoBA,CAA5B,CAJkC,CAIH;AAC/BlB,SAAKa,KAAKI,EAAV;AACA,WAAOjB,CAAP;AACH;;AAED;;;AAGO,SAASoB,YAAT,CAAsBC,KAAtB,EAA6BC,KAA7B,EAAwD;AAAA,QAApBV,WAAoB,uEAAR,MAAQ;;AAC3D;AACA;AACA,QAAMW,QAAQxB,SAASsB,MAAMG,KAAf,EAAsBH,MAAMI,GAA5B,EAAiCH,MAAME,KAAvC,CAAd;AACA,QAAME,QAAQ3B,SAASsB,MAAMG,KAAf,EAAsBH,MAAMI,GAA5B,EAAiCH,MAAMG,GAAvC,CAAd;AACA,QAAIhB,YAAYc,KAAZ,EAAmB,CAAnB,EAAsBX,WAAtB,KAAsCH,YAAYiB,KAAZ,EAAmB,CAAnB,EAAsBd,WAAtB,CAA1C,EAA8E;AAC1E,eAAO,IAAP;AACH,KAFD,MAEO,OAAO,KAAP;AACV,C;;;;;;AC5CD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AAAA;AAAA;AAAA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4CAA4C,QAAQ;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;;AAEA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;;AAEA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","file":"phaser-navmesh.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserNavmesh\"] = factory();\n\telse\n\t\troot[\"PhaserNavmesh\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7c2d548790e295d9b34b","/**\r\n * Twice the area of the triangle formed by a, b and c\r\n * @private\r\n */\r\nexport function triarea2(a, b, c) {\r\n    const ax = b.x - a.x;\r\n    const ay = b.y - a.y;\r\n    const bx = c.x - a.x;\r\n    const by = c.y - a.y;\r\n    return bx * ay - ax * by;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function almostEqual(value1, value2, errorMargin = 0.0001) {\r\n    if (Math.abs(value1 - value2) <= errorMargin) return true;\r\n    else return false;\r\n}\r\n\r\n/**\r\n * https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0\r\n * @private\r\n */\r\nexport function angleDifference(x, y) {\r\n    let a = x - y;\r\n    const i = a + Math.PI;\r\n    const j = Math.PI * 2;\r\n    a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign\r\n    a -= Math.PI;\r\n    return a;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function areCollinear(line1, line2, errorMargin=0.0001) {\r\n    // Figure out if the two lines are equal by looking at the area of the triangle formed\r\n    // by their points\r\n    const area1 = triarea2(line1.start, line1.end, line2.start);\r\n    const area2 = triarea2(line1.start, line1.end, line2.end);\r\n    if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {\r\n        return true;\r\n    } else return false;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./utils.js","// javascript-astar 0.4.2\r\n// http://github.com/bgrins/javascript-astar\r\n// Freely distributable under the MIT License.\r\n// Implements the astar search algorithm in javascript using a Binary Heap.\r\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\r\n// http://eloquentjavascript.net/appendix2.html\r\n(function(definition) {\r\n  /* global module, define */\r\n  if (typeof module === 'object' && typeof module.exports === 'object') {\r\n    module.exports = definition();\r\n  } else if (typeof define === 'function' && define.amd) {\r\n    define([], definition);\r\n  } else {\r\n    var exports = definition();\r\n    window.astar = exports.astar;\r\n    window.Graph = exports.Graph;\r\n  }\r\n})(function() {\r\n\r\nfunction pathTo(node) {\r\n  var curr = node;\r\n  var path = [];\r\n  while (curr.parent) {\r\n    path.unshift(curr);\r\n    curr = curr.parent;\r\n  }\r\n  return path;\r\n}\r\n\r\nfunction getHeap() {\r\n  return new BinaryHeap(function(node) {\r\n    return node.f;\r\n  });\r\n}\r\n\r\nvar astar = {\r\n  /**\r\n  * Perform an A* Search on a graph given a start and end node.\r\n  * @param {Graph} graph\r\n  * @param {GridNode} start\r\n  * @param {GridNode} end\r\n  * @param {Object} [options]\r\n  * @param {bool} [options.closest] Specifies whether to return the\r\n             path to the closest node if the target is unreachable.\r\n  * @param {Function} [options.heuristic] Heuristic function (see\r\n  *          astar.heuristics).\r\n  */\r\n  search: function(graph, start, end, options) {\r\n    graph.cleanDirty();\r\n    options = options || {};\r\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\r\n    var closest = options.closest || false;\r\n\r\n    var openHeap = getHeap();\r\n    var closestNode = start; // set the start node to be the closest if required\r\n\r\n    start.h = heuristic(start, end);\r\n    graph.markDirty(start);\r\n\r\n    openHeap.push(start);\r\n\r\n    while (openHeap.size() > 0) {\r\n\r\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\r\n      var currentNode = openHeap.pop();\r\n\r\n      // End case -- result has been found, return the traced path.\r\n      if (currentNode === end) {\r\n        return pathTo(currentNode);\r\n      }\r\n\r\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\r\n      currentNode.closed = true;\r\n\r\n      // Find all neighbors for the current node.\r\n      var neighbors = graph.neighbors(currentNode);\r\n\r\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\r\n        var neighbor = neighbors[i];\r\n\r\n        if (neighbor.closed || neighbor.isWall()) {\r\n          // Not a valid node to process, skip to next neighbor.\r\n          continue;\r\n        }\r\n\r\n        // The g score is the shortest distance from start to current node.\r\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\r\n        var gScore = currentNode.g + neighbor.getCost(currentNode);\r\n        var beenVisited = neighbor.visited;\r\n\r\n        if (!beenVisited || gScore < neighbor.g) {\r\n\r\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\r\n          neighbor.visited = true;\r\n          neighbor.parent = currentNode;\r\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\r\n          neighbor.g = gScore;\r\n          neighbor.f = neighbor.g + neighbor.h;\r\n          graph.markDirty(neighbor);\r\n          if (closest) {\r\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\r\n            // a cheaper path than the current closest node then it becomes the closest node\r\n            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\r\n              closestNode = neighbor;\r\n            }\r\n          }\r\n\r\n          if (!beenVisited) {\r\n            // Pushing to heap will put it in proper place based on the 'f' value.\r\n            openHeap.push(neighbor);\r\n          } else {\r\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\r\n            openHeap.rescoreElement(neighbor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (closest) {\r\n      return pathTo(closestNode);\r\n    }\r\n\r\n    // No result was found - empty array signifies failure to find path.\r\n    return [];\r\n  },\r\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\r\n  heuristics: {\r\n    manhattan: function(pos0, pos1) {\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return d1 + d2;\r\n    },\r\n    diagonal: function(pos0, pos1) {\r\n      var D = 1;\r\n      var D2 = Math.sqrt(2);\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\r\n    }\r\n  },\r\n  cleanNode: function(node) {\r\n    node.f = 0;\r\n    node.g = 0;\r\n    node.h = 0;\r\n    node.visited = false;\r\n    node.closed = false;\r\n    node.parent = null;\r\n  }\r\n};\r\n\r\n/**\r\n * A graph memory structure\r\n * @param {Array} gridIn 2D array of input weights\r\n * @param {Object} [options]\r\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\r\n */\r\nfunction Graph(gridIn, options) {\r\n  options = options || {};\r\n  this.nodes = [];\r\n  this.diagonal = !!options.diagonal;\r\n  this.grid = [];\r\n  for (var x = 0; x < gridIn.length; x++) {\r\n    this.grid[x] = [];\r\n\r\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\r\n      var node = new GridNode(x, y, row[y]);\r\n      this.grid[x][y] = node;\r\n      this.nodes.push(node);\r\n    }\r\n  }\r\n  this.init();\r\n}\r\n\r\nGraph.prototype.init = function() {\r\n  this.dirtyNodes = [];\r\n  for (var i = 0; i < this.nodes.length; i++) {\r\n    astar.cleanNode(this.nodes[i]);\r\n  }\r\n};\r\n\r\nGraph.prototype.cleanDirty = function() {\r\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\r\n    astar.cleanNode(this.dirtyNodes[i]);\r\n  }\r\n  this.dirtyNodes = [];\r\n};\r\n\r\nGraph.prototype.markDirty = function(node) {\r\n  this.dirtyNodes.push(node);\r\n};\r\n\r\nGraph.prototype.neighbors = function(node) {\r\n  var ret = [];\r\n  var x = node.x;\r\n  var y = node.y;\r\n  var grid = this.grid;\r\n\r\n  // West\r\n  if (grid[x - 1] && grid[x - 1][y]) {\r\n    ret.push(grid[x - 1][y]);\r\n  }\r\n\r\n  // East\r\n  if (grid[x + 1] && grid[x + 1][y]) {\r\n    ret.push(grid[x + 1][y]);\r\n  }\r\n\r\n  // South\r\n  if (grid[x] && grid[x][y - 1]) {\r\n    ret.push(grid[x][y - 1]);\r\n  }\r\n\r\n  // North\r\n  if (grid[x] && grid[x][y + 1]) {\r\n    ret.push(grid[x][y + 1]);\r\n  }\r\n\r\n  if (this.diagonal) {\r\n    // Southwest\r\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\r\n      ret.push(grid[x - 1][y - 1]);\r\n    }\r\n\r\n    // Southeast\r\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\r\n      ret.push(grid[x + 1][y - 1]);\r\n    }\r\n\r\n    // Northwest\r\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\r\n      ret.push(grid[x - 1][y + 1]);\r\n    }\r\n\r\n    // Northeast\r\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\r\n      ret.push(grid[x + 1][y + 1]);\r\n    }\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nGraph.prototype.toString = function() {\r\n  var graphString = [];\r\n  var nodes = this.grid;\r\n  for (var x = 0; x < nodes.length; x++) {\r\n    var rowDebug = [];\r\n    var row = nodes[x];\r\n    for (var y = 0; y < row.length; y++) {\r\n      rowDebug.push(row[y].weight);\r\n    }\r\n    graphString.push(rowDebug.join(\" \"));\r\n  }\r\n  return graphString.join(\"\\n\");\r\n};\r\n\r\nfunction GridNode(x, y, weight) {\r\n  this.x = x;\r\n  this.y = y;\r\n  this.weight = weight;\r\n}\r\n\r\nGridNode.prototype.toString = function() {\r\n  return \"[\" + this.x + \" \" + this.y + \"]\";\r\n};\r\n\r\nGridNode.prototype.getCost = function(fromNeighbor) {\r\n  // Take diagonal weight into consideration.\r\n  if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\r\n    return this.weight * 1.41421;\r\n  }\r\n  return this.weight;\r\n};\r\n\r\nGridNode.prototype.isWall = function() {\r\n  return this.weight === 0;\r\n};\r\n\r\nfunction BinaryHeap(scoreFunction) {\r\n  this.content = [];\r\n  this.scoreFunction = scoreFunction;\r\n}\r\n\r\nBinaryHeap.prototype = {\r\n  push: function(element) {\r\n    // Add the new element to the end of the array.\r\n    this.content.push(element);\r\n\r\n    // Allow it to sink down.\r\n    this.sinkDown(this.content.length - 1);\r\n  },\r\n  pop: function() {\r\n    // Store the first element so we can return it later.\r\n    var result = this.content[0];\r\n    // Get the element at the end of the array.\r\n    var end = this.content.pop();\r\n    // If there are any elements left, put the end element at the\r\n    // start, and let it bubble up.\r\n    if (this.content.length > 0) {\r\n      this.content[0] = end;\r\n      this.bubbleUp(0);\r\n    }\r\n    return result;\r\n  },\r\n  remove: function(node) {\r\n    var i = this.content.indexOf(node);\r\n\r\n    // When it is found, the process seen in 'pop' is repeated\r\n    // to fill up the hole.\r\n    var end = this.content.pop();\r\n\r\n    if (i !== this.content.length - 1) {\r\n      this.content[i] = end;\r\n\r\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n        this.sinkDown(i);\r\n      } else {\r\n        this.bubbleUp(i);\r\n      }\r\n    }\r\n  },\r\n  size: function() {\r\n    return this.content.length;\r\n  },\r\n  rescoreElement: function(node) {\r\n    this.sinkDown(this.content.indexOf(node));\r\n  },\r\n  sinkDown: function(n) {\r\n    // Fetch the element that has to be sunk.\r\n    var element = this.content[n];\r\n\r\n    // When at 0, an element can not sink any further.\r\n    while (n > 0) {\r\n\r\n      // Compute the parent element's index, and fetch it.\r\n      var parentN = ((n + 1) >> 1) - 1;\r\n      var parent = this.content[parentN];\r\n      // Swap the elements if the parent is greater.\r\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n        this.content[parentN] = element;\r\n        this.content[n] = parent;\r\n        // Update 'n' to continue at the new position.\r\n        n = parentN;\r\n      }\r\n      // Found a parent that is less, no need to sink any further.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  },\r\n  bubbleUp: function(n) {\r\n    // Look up the target element and its score.\r\n    var length = this.content.length;\r\n    var element = this.content[n];\r\n    var elemScore = this.scoreFunction(element);\r\n\r\n    while (true) {\r\n      // Compute the indices of the child elements.\r\n      var child2N = (n + 1) << 1;\r\n      var child1N = child2N - 1;\r\n      // This is used to store the new position of the element, if any.\r\n      var swap = null;\r\n      var child1Score;\r\n      // If the first child exists (is inside the array)...\r\n      if (child1N < length) {\r\n        // Look it up and compute its score.\r\n        var child1 = this.content[child1N];\r\n        child1Score = this.scoreFunction(child1);\r\n\r\n        // If the score is less than our element's, we need to swap.\r\n        if (child1Score < elemScore) {\r\n          swap = child1N;\r\n        }\r\n      }\r\n\r\n      // Do the same checks for the other child.\r\n      if (child2N < length) {\r\n        var child2 = this.content[child2N];\r\n        var child2Score = this.scoreFunction(child2);\r\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\r\n          swap = child2N;\r\n        }\r\n      }\r\n\r\n      // If the element needs to be moved, swap it, and continue.\r\n      if (swap !== null) {\r\n        this.content[n] = this.content[swap];\r\n        this.content[swap] = element;\r\n        n = swap;\r\n      }\r\n      // Otherwise, we are done.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nreturn {\r\n  astar: astar,\r\n  Graph: Graph\r\n};\r\n\r\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/navmesh-phaser-plugin/~/javascript-astar/astar.js\n// module id = 1\n// module chunks = 0 1","// const triangulate = require(\"./triangulate\");\r\nimport NavMesh from \"./nav-mesh\";\r\n\r\n/**\r\n * This plugin can create navigation meshes for use in Phaser. The navmeshes can be constructed from\r\n * convex polygons embedded in a Tiled map. Instantiate this using game.plugins.add(NavMeshPlugin).\r\n *\r\n * @param {Phaser.Game} game\r\n * @param {Phaser.PluginManager} manager\r\n */\r\nexport default class NavMeshPlugin extends Phaser.Plugin {\r\n    constructor(game, manager) {\r\n        super(game, manager);\r\n        this._navMeshes = [];\r\n    }\r\n\r\n    /**\r\n     * Load a navmesh from Tiled and switch it to be the current navmesh. Currently assumes that the\r\n     * polygons are squares!\r\n     * \r\n     * @param {Phaser.Tilemap} tilemap The tilemap that contains polygons under an object layer\r\n     * @param {string} objectKey The name of the object layer in the tilemap\r\n     * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n     * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n     * \r\n     * @memberof NavMeshPlugin\r\n     */\r\n    buildMeshFromTiled(tilemap, objectKey, meshShrinkAmount = 0) {\r\n        // Load up the object layer\r\n        const rects = tilemap.objects[objectKey] || [];\r\n        // Loop over the objects and construct a polygon\r\n        const polygons = [];\r\n        for (const r of rects) {\r\n            const top = r.y;\r\n            const bottom = r.y + r.height;\r\n            const left = r.x;\r\n            const right = r.x + r.width;\r\n            const poly = new Phaser.Polygon(left,top, left,bottom, right,bottom, right,top);\r\n            polygons.push(poly);\r\n        }\r\n        // Build the navmesh\r\n        const mesh = new NavMesh(this.game, polygons, meshShrinkAmount);\r\n        this._navMeshes.push(mesh);\r\n        return mesh;\r\n    }\r\n\r\n    destroy() {\r\n        for (const mesh of this._navMeshes) mesh.destroy();\r\n        this._navMeshes = [];\r\n        super.destroy();\r\n    }\r\n\r\n    // /**\r\n    //  * Build a navmesh from an array of convex polygons. This currently tesselates the polygons into\r\n    //  * triangles. They aren't as efficient or as well designed as ones made by hand in Tiled. \r\n    //  *\r\n    //  * @param {string} levelName The key to use to store the navmesh in the plugin  \r\n    //  * @param {[]} hulls An array of convex polygons describing the obstacles in the\r\n    //  * level. See lighting-plugin/hull-from-tiles.\r\n    //  *\r\n    //  * @memberof NavMeshPlugin\r\n    //  */\r\n    // buildMesh(levelName, hulls) {\r\n    //     const contours = this._buildContours(hulls);\r\n    //     // Get an array of triangulated vertices\r\n    //     const triangles = triangulate(contours, false); // Counter-clockwise ordering!\r\n    //     const polygons = [];\r\n    //     for (let i = 0; i < triangles.length; i += 6) {\r\n    //         const poly = new Phaser.Polygon(\r\n    //             // These should be in counter-clockwise order from triangulate\r\n    //             triangles[i + 0], triangles[i + 1], \r\n    //             triangles[i + 2], triangles[i + 3], \r\n    //             triangles[i + 4], triangles[i + 5]\r\n    //         );\r\n    //         polygons.push(poly);\r\n    //     }\r\n    //     const navMesh = new NavMesh(this.game, polygons);\r\n    //     this._navMeshes[levelName] = navMesh;\r\n    //     this._currentNavMesh = navMesh;\r\n    // }\r\n\r\n    // /**\r\n    //  * @param {[]} hulls \r\n    //  * @returns \r\n    //  * \r\n    //  * @memberof NavMeshPlugin\r\n    //  */\r\n    // _buildContours(hulls) {\r\n    //     const w = this.game.width;\r\n    //     const h = this.game.height;\r\n    //     // Start the contours\r\n    //     const contours = [\r\n    //         // Full screen - counter clockwise\r\n    //         Float32Array.of(0,0, 0,h, w,h, w,0)\r\n    //     ];\r\n    //     // For each convex hull add the contour\r\n    //     for (const hull of hulls) {\r\n    //         const contour = [];\r\n    //         for (const lineInfo of hull) {\r\n    //             contour.push(lineInfo.line.start.x, lineInfo.line.start.y);\r\n    //         }\r\n    //         contours.push(Float32Array.from(contour));\r\n    //     }\r\n    //     return contours;\r\n    // }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./nav-mesh-plugin.js","// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete\r\n// funnel algorithm so astar checks can be more accurate.\r\n\r\nimport {triarea2} from \"./utils\";\r\n\r\n/**\r\n * @private\r\n */\r\nclass Channel {\r\n    constructor() {\r\n        this.portals = [];\r\n    }\r\n\r\n    /**\r\n     * @param {Phaser.Point} p1 \r\n     * @param {Phaser.Point} p2 \r\n     * \r\n     * @memberof Channel\r\n     */\r\n    push(p1, p2 = null) {\r\n        if (p2 === null) p2 = p1;\r\n        this.portals.push({\r\n            left: p1, \r\n            right: p2\r\n        });\r\n    }\r\n\r\n    stringPull() {\r\n        var portals = this.portals;\r\n        var pts = [];\r\n        // Init scan state\r\n        var portalApex, portalLeft, portalRight;\r\n        var apexIndex = 0,\r\n            leftIndex = 0,\r\n            rightIndex = 0;\r\n\r\n        portalApex = portals[0].left;\r\n        portalLeft = portals[0].left;\r\n        portalRight = portals[0].right;\r\n\r\n        // Add start point.\r\n        pts.push(portalApex);\r\n\r\n        for (var i = 1; i < portals.length; i++) {\r\n            // Find the next portal vertices\r\n            var left = portals[i].left;\r\n            var right = portals[i].right;\r\n\r\n            // Update right vertex.\r\n            if (triarea2(portalApex, portalRight, right) <= 0.0) {\r\n                if (portalApex.equals(portalRight) || \r\n                        triarea2(portalApex, portalLeft, right) > 0.0) {\r\n                    // Tighten the funnel.\r\n                    portalRight = right;\r\n                    rightIndex = i;\r\n                } else {\r\n                    // Right vertex just crossed over the left vertex, so the left vertex should\r\n                    // now be part of the path.\r\n                    pts.push(portalLeft);\r\n                    \r\n                    // Restart scan from portal left point.\r\n\r\n                    // Make current left the new apex.\r\n                    portalApex = portalLeft;\r\n                    apexIndex = leftIndex;\r\n                    // Reset portal\r\n                    portalLeft = portalApex;\r\n                    portalRight = portalApex;\r\n                    leftIndex = apexIndex;\r\n                    rightIndex = apexIndex;\r\n                    // Restart scan\r\n                    i = apexIndex;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // Update left vertex.\r\n            if (triarea2(portalApex, portalLeft, left) >= 0.0) {\r\n                if (portalApex.equals(portalLeft) || \r\n                        triarea2(portalApex, portalRight, left) < 0.0) {\r\n                    // Tighten the funnel.\r\n                    portalLeft = left;\r\n                    leftIndex = i;\r\n                } else {\r\n                    // Left vertex just crossed over the right vertex, so the right vertex should\r\n                    // now be part of the path\r\n                    pts.push(portalRight);\r\n                    \r\n                    // Restart scan from portal right point.\r\n\r\n                    // Make current right the new apex.\r\n                    portalApex = portalRight;\r\n                    apexIndex = rightIndex;\r\n                    // Reset portal\r\n                    portalLeft = portalApex;\r\n                    portalRight = portalApex;\r\n                    leftIndex = apexIndex;\r\n                    rightIndex = apexIndex;\r\n                    // Restart scan\r\n                    i = apexIndex;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        if ((pts.length === 0) || (!pts[pts.length - 1].equals(portals[portals.length - 1].left))) {\r\n            // Append last point to path.\r\n            pts.push(portals[portals.length - 1].left);\r\n        }\r\n\r\n        this.path = pts;\r\n        return pts;\r\n    }\r\n}\r\n\r\nexport default Channel;\n\n\n// WEBPACK FOOTER //\n// ./channel.js","// Fix for webpack not exporting ES6 module default properly when using global mode of UMD. It ends\r\n// up with someone having to do \"PhaserNavmesh.default\" instead of \"PhaserNavmesh\"\r\nmodule.exports = require(\"./nav-mesh-plugin\").default;\n\n\n// WEBPACK FOOTER //\n// ./index.js","import jsastar from \"javascript-astar\";\r\n\r\n/**\r\n * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar\r\n * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavGraph \r\n * @private\r\n */\r\nclass NavGraph {\r\n    constructor(navPolygons) {\r\n        this.nodes = navPolygons;\r\n        this.init();\r\n    }\r\n\r\n    neighbors(navPolygon) {\r\n        return navPolygon.neighbors;\r\n    }\r\n\r\n    navHeuristic(navPolygon1, navPolygon2) {\r\n        return navPolygon1.centroidDistance(navPolygon2);\r\n    }\r\n\r\n    destroy() {\r\n        this.cleanDirty();\r\n        this.nodes = [];\r\n    }\r\n}\r\n\r\nNavGraph.prototype.init = jsastar.Graph.prototype.init;\r\nNavGraph.prototype.cleanDirty = jsastar.Graph.prototype.cleanDirty;\r\nNavGraph.prototype.markDirty = jsastar.Graph.prototype.markDirty;\r\n\r\nexport default NavGraph;\n\n\n// WEBPACK FOOTER //\n// ./nav-graph.js","import jsastar from \"javascript-astar\";\r\nimport NavPoly from \"./nav-poly\";\r\nimport NavGraph from \"./nav-graph\";\r\nimport Channel from \"./channel\";\r\nimport {angleDifference, areCollinear} from \"./utils\";\r\n\r\n/**\r\n * The workhorse that represents a navigation mesh built from a series of polygons. Once built, the\r\n * mesh can be asked for a path from one point to another point. It has debug methods for \r\n * visualizing paths and visualizing the individual polygons. Some internal terminology usage:\r\n * \r\n * - neighbor: a polygon that shares part of an edge with another polygon\r\n * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment\r\n * - channel: the path of polygons from starting point to end point\r\n * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the\r\n *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut.\r\n */\r\nclass NavMesh {\r\n    /**\r\n     * Creates an instance of NavMesh.\r\n     * \r\n     * @param {Phaser.Game} game\r\n     * @param {Phaser.Polygon[]} polygons\r\n     * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n     * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n     */\r\n    constructor(game, polygons, meshShrinkAmount = 0) {\r\n        this.game = game;\r\n        this._debugGraphics = null;\r\n        this._meshShrinkAmount = meshShrinkAmount;\r\n\r\n        // Construct NavPoly instances for each polygon\r\n        this._navPolygons = [];\r\n        for (const [i, polygon] of polygons.entries()) {\r\n            this._navPolygons.push(new NavPoly(game, i, polygon));\r\n        }\r\n\r\n        this._calculateNeighbors();\r\n\r\n        // Astar graph of connections between polygons\r\n        this._graph = new NavGraph(this._navPolygons);\r\n    }\r\n\r\n    /**\r\n     * Cleanup method to remove references so that navmeshes don't hang around from state to state.\r\n     * You don't have to invoke this directly. If you call destroy on the plugin, it will destroy\r\n     * all navmeshes that have been created. \r\n     * \r\n     * @memberof NavMesh\r\n     */\r\n    destroy() {\r\n        this._graph.destroy();\r\n        for (const poly of this._navPolygons) poly.destroy();\r\n        this._navPolygons = [];\r\n        this.game = null;\r\n        this.disableDebug();\r\n    }\r\n\r\n    /**\r\n     * Find a path from the start point to the end point using this nav mesh.\r\n     *\r\n     * @param {Phaser.Point} startPoint\r\n     * @param {Phaser.Point} endPoint\r\n     * @param {object} [drawOptions={}] Options for controlling debug drawing\r\n     * @param {boolean} [drawOptions.drawPolyPath=false] Whether or not to visualize the path\r\n     * through the polygons - e.g. the path that astar found.\r\n     * @param {boolean} [drawOptions.drawFinalPath=false] Whether or not to visualize the path\r\n     * through the path that was returned.\r\n     * @returns {Phaser.Point[]|null} An array of points if a path is found, or null if no path\r\n     *\r\n     * @memberof NavMesh\r\n     */\r\n    findPath(startPoint, endPoint, {drawPolyPath = false, drawFinalPath = false} = {}) {\r\n        let startPoly = null;\r\n        let endPoly = null;\r\n        let startDistance = Number.MAX_VALUE;\r\n        let endDistance = Number.MAX_VALUE;\r\n        let d, r;\r\n\r\n        // Find the closest poly for the starting and ending point\r\n        for (const navPoly of this._navPolygons) {\r\n            r = navPoly.boundingRadius;\r\n            // Start\r\n            d = navPoly.centroid.distance(startPoint);\r\n            if (d <= startDistance && d <= r && navPoly.constains(startPoint)) {\r\n                startPoly = navPoly;\r\n                startDistance = d;\r\n            }\r\n            // End\r\n            d = navPoly.centroid.distance(endPoint);\r\n            if (d <= endDistance && d <= r && navPoly.constains(endPoint)) {\r\n                endPoly = navPoly;\r\n                endDistance = d;\r\n            }\r\n        }\r\n\r\n        // If the start point wasn't inside a polygon, run a more liberal check that allows a point\r\n        // to be within meshShrinkAmount radius of a polygon\r\n        if (!startPoly && this._meshShrinkAmount > 0) {\r\n            for (const navPoly of this._navPolygons) {\r\n                // Check if point is within bounding circle to avoid extra projection calculations\r\n                r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n                d = navPoly.centroid.distance(startPoint);\r\n                if (d <= r) {\r\n                    // Check if projected point is within range of a polgyon and is closer than the\r\n                    // previous point\r\n                    const {distance} = this._projectPointToPolygon(startPoint, navPoly);\r\n                    if (distance <= this._meshShrinkAmount && distance < startDistance) {\r\n                        startPoly = navPoly;\r\n                        startDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Same check as above, but for the end point\r\n        if (!endPoly && this._meshShrinkAmount > 0) {\r\n            for (const navPoly of this._navPolygons) {\r\n                r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n                d = navPoly.centroid.distance(endPoint);\r\n                if (d <= r) {\r\n                    const {distance}  = this._projectPointToPolygon(endPoint, navPoly);\r\n                    if (distance <= this._meshShrinkAmount && distance < endDistance) {\r\n                        endPoly = navPoly;\r\n                        endDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // No matching polygons locations for the start or end, so no path found\r\n        if (!startPoly || !endPoly) return null;\r\n        \r\n        // Search!\r\n        const astarPath = jsastar.astar.search(this._graph, startPoly, endPoly, {\r\n            heuristic: this._graph.navHeuristic\r\n        });\r\n        // jsastar drops the first point from the path, but the funnel algorithm needs it\r\n        astarPath.unshift(startPoly);\r\n        \r\n        // We have a path, so now time for the funnel algorithm\r\n        const channel = new Channel();\r\n        channel.push(startPoint);\r\n        for (let i = 0; i < astarPath.length - 1; i++) {\r\n            const navPolygon = astarPath[i];\r\n            const nextNavPolygon = astarPath[i + 1];\r\n\r\n            // Find the portal\r\n            let portal = null;\r\n            for (let i = 0; i < navPolygon.neighbors.length; i++) {\r\n                if (navPolygon.neighbors[i].id === nextNavPolygon.id) {\r\n                    portal = navPolygon.portals[i];\r\n                }\r\n            }\r\n\r\n            // Push the portal vertices into the channel\r\n            channel.push(portal.start, portal.end);\r\n        }\r\n        channel.push(endPoint);\r\n\r\n        // Pull a string along the channel to run the funnel\r\n        channel.stringPull();\r\n\r\n        // Clone path, excluding duplicates\r\n        let lastPoint = null;\r\n        const phaserPath = [];\r\n        for (const p of channel.path) {\r\n            const newPoint = p.clone();\r\n            if (!lastPoint || !newPoint.equals(lastPoint)) phaserPath.push(newPoint);\r\n            lastPoint = newPoint;\r\n        }\r\n\r\n        // Call debug drawing\r\n        if (drawPolyPath) {\r\n            const polyPath = astarPath.map((elem) => elem.centroid);\r\n            this.debugDrawPath(polyPath, 0x00ff00, 5);\r\n        }\r\n        if (drawFinalPath) this.debugDrawPath(phaserPath, 0xffd900, 10);\r\n\r\n        return phaserPath;\r\n    }\r\n\r\n    _calculateNeighbors() {\r\n        // Fill out the neighbor information for each navpoly\r\n        for (let i = 0; i < this._navPolygons.length; i++) {\r\n            const navPoly = this._navPolygons[i];\r\n\r\n            for (let j = i + 1; j < this._navPolygons.length; j++) {\r\n                const otherNavPoly = this._navPolygons[j];\r\n\r\n                // Check if the other navpoly is within range to touch\r\n                const d = navPoly.centroid.distance(otherNavPoly.centroid);\r\n                if (d > (navPoly.boundingRadius + otherNavPoly.boundingRadius)) continue;\r\n\r\n                // The are in range, so check each edge pairing\r\n                for (const edge of navPoly.edges) {\r\n                    for (const otherEdge of otherNavPoly.edges) {\r\n                        \r\n                        // If edges aren't collinear, not an option for connecting navpolys\r\n                        if (!areCollinear(edge, otherEdge)) continue;\r\n\r\n                        // If they are collinear, check if they overlap\r\n                        const overlap = this._getSegmentOverlap(edge, otherEdge);\r\n                        if (!overlap) continue;\r\n                        \r\n                        // Connections are symmetric!\r\n                        navPoly.neighbors.push(otherNavPoly);\r\n                        otherNavPoly.neighbors.push(navPoly);\r\n\r\n                        // Calculate the portal between the two polygons - this needs to be in\r\n                        // counter-clockwise order, relative to each polygon\r\n                        const [p1, p2] = overlap;\r\n                        let edgeStartAngle = navPoly.centroid.angle(edge.start);\r\n                        let a1 = navPoly.centroid.angle(overlap[0]);\r\n                        let a2 = navPoly.centroid.angle(overlap[1]);\r\n                        let d1 = angleDifference(edgeStartAngle, a1);\r\n                        let d2 = angleDifference(edgeStartAngle, a2);\r\n                        if (d1 < d2) {\r\n                            navPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n                        } else {\r\n                            navPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\r\n                        }\r\n\r\n                        edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);\r\n                        a1 = otherNavPoly.centroid.angle(overlap[0]);\r\n                        a2 = otherNavPoly.centroid.angle(overlap[1]);\r\n                        d1 = angleDifference(edgeStartAngle, a1);\r\n                        d2 = angleDifference(edgeStartAngle, a2);\r\n                        if (d1 < d2) {\r\n                            otherNavPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n                        } else {\r\n                            otherNavPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\r\n                        }\r\n                            \r\n                        // Two convex polygons shouldn't be connected more than once! (Unless\r\n                        // there are unnecessary vertices...)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check two collinear line segments to see if they overlap by sorting the points.\r\n    // Algorithm source: http://stackoverflow.com/a/17152247\r\n    _getSegmentOverlap(line1, line2) {\r\n        const points = [\r\n            {line: line1, point: line1.start}, \r\n            {line: line1, point: line1.end}, \r\n            {line: line2, point: line2.start}, \r\n            {line: line2, point: line2.end}\r\n        ]; \r\n        points.sort(function (a, b) {\r\n            if (a.point.x < b.point.x) return -1;\r\n            else if (a.point.x > b.point.x) return 1;\r\n            else {\r\n                if (a.point.y < b.point.y) return -1;\r\n                else if (a.point.y > b.point.y) return 1;\r\n                else return 0;\r\n            }\r\n        });\r\n        // If the first two points in the array come from the same line, no overlap\r\n        const noOverlap = points[0].line === points[1].line;\r\n        // If the two middle points in the array are the same coordinates, then there is a \r\n        // single point of overlap.\r\n        const singlePointOverlap = points[1].point.equals(points[2].point);\r\n        if (noOverlap || singlePointOverlap) return null;\r\n        else return [points[1].point, points[2].point];\r\n    }\r\n\r\n    /**\r\n     * Project a point onto a polygon in the shortest distance possible.\r\n     * \r\n     * @param {Phaser.Point} point The point to project\r\n     * @param {NavPoly} navPoly The navigation polygon to test against\r\n     * @returns {{point: Phaser.Point, distance: number}}\r\n     * \r\n     * @private\r\n     * @memberof NavMesh\r\n     */\r\n    _projectPointToPolygon(point, navPoly) {\r\n        let closestProjection = null;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        for (const edge of navPoly.edges) {\r\n            const projectedPoint = this._projectPointToEdge(point, edge);\r\n            const d = point.distance(projectedPoint);\r\n            if (closestProjection === null || d < closestDistance) {\r\n                closestDistance = d;\r\n                closestProjection = projectedPoint;\r\n            }\r\n        }\r\n        return {point: closestProjection, distance: closestDistance};\r\n    }\r\n\r\n    _distanceSquared(a, b) {\r\n        const dx = b.x - a.x;\r\n        const dy = b.y - a.y;\r\n        return dx * dx + dy * dy;\r\n    }\r\n\r\n    // Project a point onto a line segment\r\n    // JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\r\n    _projectPointToEdge(point, line) {\r\n        const a = line.start;\r\n        const b = line.end;\r\n        // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find\r\n        // where our point lies on the line by solving for t:\r\n        //  t = [(p-a) . (b-a)] / |b-a|^2\r\n        const l2 = this._distanceSquared(a, b);\r\n        let t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;\r\n        // We clamp t from [0,1] to handle points outside the segment vw.\r\n        t = Phaser.Math.clamp(t, 0, 1);\r\n        // Project onto the segment\r\n        const p = new Phaser.Point(\r\n            a.x + t * (b.x - a.x),\r\n            a.y + t * (b.y - a.y)\r\n        );\r\n        return p;        \r\n    }\r\n\r\n    /**\r\n     * Enable debug and create graphics overlay (if it hasn't already been created) \r\n     */\r\n    enableDebug() {\r\n        if (!this._debugGraphics) {\r\n            this._debugGraphics = this.game.add.graphics(0, 0);\r\n            this._debugGraphics.alpha = 0.5;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable debug and destroy associated graphics\r\n     */\r\n    disableDebug() {\r\n        if (this._debugGraphics) {\r\n            this._debugGraphics.destroy();\r\n            this._debugGraphics = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check whether debug is enabled\r\n     * \r\n     * @returns {boolean}\r\n     */\r\n    isDebugEnabled() {\r\n        return this._debugGraphics !== null;\r\n    }\r\n\r\n    /**\r\n     * Clear the debug overlay\r\n     */\r\n    debugClear() {\r\n        if (this._debugGraphics) this._debugGraphics.clear();\r\n    }\r\n    \r\n    /**\r\n     * Visualize the polygons in the nav mesh as an overlay on top of the game\r\n     *\r\n     * @param {object} options\r\n     * @param {boolean} [options.drawCentroid=true] For each polygon, show the approx centroid\r\n     * @param {boolean} [options.drawBounds=false] For each polygon, show the bounding radius\r\n     * @param {boolean} [options.drawNeighbors=true] For each polygon, show the connections to\r\n     * neighbors\r\n     * @param {boolean} [options.drawPortals=true] For each polygon, show the portal edges\r\n     */\r\n    debugDrawMesh({drawCentroid = true, drawBounds = false, drawNeighbors = true, \r\n            drawPortals = true} = {}) {\r\n        if (!this._debugGraphics) this.enableDebug();\r\n        // Visualize the navigation mesh\r\n        for (const navPoly of this._navPolygons) {\r\n            navPoly.draw(this._debugGraphics, drawCentroid, drawBounds, drawNeighbors, drawPortals);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Visualize a path (array of points) on the debug graphics overlay\r\n     * \r\n     * @param {Phaser.Point[]} path \r\n     * @param {number} [color=0x00FF00] \r\n     * @param {number} [thickness=10] \r\n     */\r\n    debugDrawPath(path, color = 0x00FF00, thickness = 10) {\r\n        if (!this._debugGraphics) this.enableDebug();\r\n        if (path.length) {\r\n            // Draw line for path\r\n            this._debugGraphics.lineStyle(thickness, color);\r\n            this._debugGraphics.drawShape(new Phaser.Polygon(...path)); \r\n            this._debugGraphics.beginFill(color);\r\n            // Draw circle at start and end of path\r\n            const d = 0.5 * thickness;\r\n            this._debugGraphics.drawEllipse(path[0].x, path[0].y, d, d);\r\n            const lastPoint = path[path.length - 1];\r\n            this._debugGraphics.drawEllipse(lastPoint.x, lastPoint.y, d, d);\r\n            this._debugGraphics.endFill();\r\n        }\r\n    }\r\n}\r\n\r\nexport default NavMesh;\n\n\n// WEBPACK FOOTER //\n// ./nav-mesh.js","// Debug color palette\r\nconst palette = [0x00A0B0, 0x6A4A3C, 0xCC333F, 0xEB6841, 0xEDC951];\r\n\r\n/**\r\n * A class that represents a navigable polygon in a navmesh. It is build from a Phaser.Polygon. It\r\n * has a drawing function to help visualize it's features:\r\n *  - polygon\r\n *  - neighbors - any navpolys that can be reached from this navpoly\r\n *  - portals - overlapping edges between neighbors\r\n *  - centroid - not a true centroid, just an approximation.\r\n *  - boundingRadius - the radius of a circle at the centroid that fits all the points of the poly \r\n * \r\n * It implements the properties and fields that javascript-astar needs - weight, toString, isWall\r\n * and getCost. See GPS test from astar repo for structure: \r\n * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavPoly\r\n * @private\r\n */\r\nclass NavPoly {\r\n    /**\r\n     * Creates an instance of NavPoly.\r\n     * @param {Phaser.Game} game \r\n     * @param {number} id \r\n     * @param {Phaser.Polygon} polygon \r\n     * \r\n     * @memberof NavPoly\r\n     */\r\n    constructor(game, id, polygon) {\r\n        this.game = game;\r\n        this.id = id;\r\n        this.polygon = polygon;\r\n        this.edges = this._calculateEdges();\r\n        this.neighbors = [];\r\n        this.portals = [];\r\n        this.centroid = this._calculateCentroid();\r\n        this.boundingRadius = this._calculateRadius();\r\n\r\n        this.weight = 1; // jsastar property\r\n        \r\n        const i = this.id % palette.length;\r\n        this._color = palette[i];\r\n    }\r\n\r\n    constains(point) {\r\n        return this.polygon.contains(point.x, point.y);\r\n    }\r\n\r\n    destroy() {\r\n        this.game = null;\r\n        this.neighbors = [];\r\n        this.portals = [];\r\n    }\r\n\r\n    // jsastar methods\r\n    toString() {\r\n        return `NavPoly(id: ${this.id} at: ${this.centroid})`;\r\n    }\r\n    isWall() {\r\n        return this.weight === 0;\r\n    }\r\n    centroidDistance(navPolygon) {\r\n        return this.centroid.distance(navPolygon.centroid);\r\n    }\r\n    getCost(navPolygon) {\r\n        return this.centroidDistance(navPolygon);\r\n    }\r\n\r\n    _calculateEdges() {\r\n        const points = this.polygon.points;\r\n        const edges = [];\r\n        for (let i = 1; i < points.length; i++) {\r\n            const p1 = points[i - 1];\r\n            const p2 = points[i];\r\n            edges.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n        }\r\n        const first = points[0];\r\n        const last = points[points.length - 1]\r\n        edges.push(new Phaser.Line(first.x, first.y, last.x, last.y));\r\n        return edges;\r\n    }\r\n    \r\n    _calculateCentroid() {\r\n        // NOTE: this is not actually the centroid, it's the average of the vertices - not the same\r\n        // thing!\r\n        const centroid = new Phaser.Point(0, 0);\r\n        const length = this.polygon.points.length;\r\n        for (const point of this.polygon.points) {\r\n            centroid.add(point.x, point.y);\r\n        }\r\n        centroid.divide(length, length);\r\n        return centroid;\r\n    }\r\n\r\n    _calculateRadius() {\r\n        let boundingRadius = 0;\r\n        for (const point of this.polygon.points) {\r\n            const d = this.centroid.distance(point);\r\n            if (d > boundingRadius) boundingRadius = d;\r\n        }\r\n        return boundingRadius;\r\n    }\r\n\r\n    /**\r\n     * Draw the polygon to given graphics object\r\n     * \r\n     * @param {Phaser.Graphics} graphics \r\n     * @param {boolean} [drawCentroid=true] Show the approx centroid\r\n     * @param {boolean} [drawBounds=false] Show the bounding radius\r\n     * @param {boolean} [drawNeighbors=true] Show the connections to neighbors\r\n     * @param {boolean} [drawPortals=true] Show the portal edges\r\n     * \r\n     * @memberof NavPoly\r\n     */\r\n    draw(graphics, drawCentroid = true, drawBounds = false, drawNeighbors = true, \r\n            drawPortals = true) {\r\n        graphics.lineWidth = 0;\r\n        graphics.beginFill(this._color);\r\n        graphics.drawPolygon(this.polygon);\r\n        graphics.endFill();\r\n\r\n        if (drawCentroid) {\r\n            graphics.beginFill(0x000000);\r\n            graphics.drawEllipse(this.centroid.x, this.centroid.y, 4, 4);\r\n            graphics.endFill();\r\n        }\r\n\r\n        if (drawBounds) {\r\n            graphics.lineStyle(1, 0xFFFFFF);\r\n            const r = this.boundingRadius;\r\n            graphics.drawEllipse(this.centroid.x, this.centroid.y, r, r);\r\n        }\r\n\r\n        if (drawNeighbors) {\r\n            graphics.lineStyle(2, 0x000000);\r\n            for (const n of this.neighbors) {\r\n                graphics.moveTo(this.centroid.x, this.centroid.y);\r\n                graphics.lineTo(n.centroid.x, n.centroid.y);\r\n            }\r\n        }\r\n\r\n        if (drawPortals) {\r\n            graphics.lineStyle(10, 0x000000);\r\n            for (const p of this.portals) {\r\n                graphics.moveTo(p.start.x, p.start.y);\r\n                graphics.lineTo(p.end.x, p.end.y);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default NavPoly;\n\n\n// WEBPACK FOOTER //\n// ./nav-poly.js"],"sourceRoot":""}