{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 148d0aa2c9e9142cf15a","webpack:///./utils.js","webpack:///E:/Github/navmesh-phaser-plugin/~/javascript-astar/astar.js","webpack:///./nav-mesh.js","webpack:///./channel.js","webpack:///./index.js","webpack:///./nav-graph.js","webpack:///./nav-poly.js"],"names":["triarea2","a","b","c","ax","x","ay","y","bx","by","almostEqual","value1","value2","errorMargin","Math","abs","angleDifference","i","PI","j","floor","areCollinear","line1","line2","area1","start","end","area2","NavMesh","game","polygons","meshShrinkAmount","_debugGraphics","_meshShrinkAmount","_navPolygons","entries","polygon","push","_calculateNeighbors","_graph","destroy","poly","disableDebug","startPoint","endPoint","drawPolyPath","drawFinalPath","startPoly","endPoly","startDistance","Number","MAX_VALUE","endDistance","d","r","navPoly","boundingRadius","centroid","distance","constains","_projectPointToPolygon","astarPath","jsastar","astar","search","heuristic","navHeuristic","unshift","channel","length","navPolygon","nextNavPolygon","portal","neighbors","id","portals","stringPull","lastPoint","phaserPath","path","p","newPoint","clone","equals","polyPath","map","elem","debugDrawPath","otherNavPoly","edges","edge","otherEdge","overlap","_getSegmentOverlap","p1","p2","edgeStartAngle","angle","a1","a2","d1","d2","Phaser","Line","points","line","point","sort","noOverlap","singlePointOverlap","closestProjection","closestDistance","projectedPoint","_projectPointToEdge","dx","dy","l2","_distanceSquared","t","clamp","Point","add","graphics","alpha","clear","drawCentroid","drawBounds","drawNeighbors","drawPortals","enableDebug","draw","color","thickness","lineStyle","drawShape","Polygon","beginFill","drawEllipse","endFill","Channel","left","right","pts","portalApex","portalLeft","portalRight","apexIndex","leftIndex","rightIndex","NavMeshPlugin","manager","_navMeshes","tilemap","objectKey","rects","objects","top","bottom","height","width","mesh","Plugin","NavGraph","navPolygons","nodes","init","navPolygon1","navPolygon2","centroidDistance","cleanDirty","prototype","Graph","markDirty","palette","NavPoly","_calculateEdges","_calculateCentroid","_calculateRadius","weight","_color","contains","first","last","divide","lineWidth","drawPolygon","n","moveTo","lineTo"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;AChEA;AAAA;;;;AAIO,SAASA,QAAT,CAAkBC,CAAlB,EAAqBC,CAArB,EAAwBC,CAAxB,EAA2B;AAC9B,QAAMC,KAAKF,EAAEG,CAAF,GAAMJ,EAAEI,CAAnB;AACA,QAAMC,KAAKJ,EAAEK,CAAF,GAAMN,EAAEM,CAAnB;AACA,QAAMC,KAAKL,EAAEE,CAAF,GAAMJ,EAAEI,CAAnB;AACA,QAAMI,KAAKN,EAAEI,CAAF,GAAMN,EAAEM,CAAnB;AACA,WAAOC,KAAKF,EAAL,GAAUF,KAAKK,EAAtB;AACH;;AAED;;;AAGO,SAASC,WAAT,CAAqBC,MAArB,EAA6BC,MAA7B,EAA2D;AAAA,QAAtBC,WAAsB,uEAAR,MAAQ;;AAC9D,QAAIC,KAAKC,GAAL,CAASJ,SAASC,MAAlB,KAA6BC,WAAjC,EAA8C,OAAO,IAAP,CAA9C,KACK,OAAO,KAAP;AACR;;AAED;;;;AAIO,SAASG,eAAT,CAAyBX,CAAzB,EAA4BE,CAA5B,EAA+B;AAClC,QAAIN,IAAII,IAAIE,CAAZ;AACA,QAAMU,IAAIhB,IAAIa,KAAKI,EAAnB;AACA,QAAMC,IAAIL,KAAKI,EAAL,GAAU,CAApB;AACAjB,QAAIgB,IAAIH,KAAKM,KAAL,CAAWH,IAAIE,CAAf,IAAoBA,CAA5B,CAJkC,CAIH;AAC/BlB,SAAKa,KAAKI,EAAV;AACA,WAAOjB,CAAP;AACH;;AAED;;;AAGO,SAASoB,YAAT,CAAsBC,KAAtB,EAA6BC,KAA7B,EAAwD;AAAA,QAApBV,WAAoB,uEAAR,MAAQ;;AAC3D;AACA;AACA,QAAMW,QAAQxB,SAASsB,MAAMG,KAAf,EAAsBH,MAAMI,GAA5B,EAAiCH,MAAME,KAAvC,CAAd;AACA,QAAME,QAAQ3B,SAASsB,MAAMG,KAAf,EAAsBH,MAAMI,GAA5B,EAAiCH,MAAMG,GAAvC,CAAd;AACA,QAAIhB,YAAYc,KAAZ,EAAmB,CAAnB,EAAsBX,WAAtB,KAAsCH,YAAYiB,KAAZ,EAAmB,CAAnB,EAAsBd,WAAtB,CAA1C,EAA8E;AAC1E,eAAO,IAAP;AACH,KAFD,MAEO,OAAO,KAAP;AACV,C;;;;;;AC5CD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AAAA;AAAA;AAAA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4CAA4C,QAAQ;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;;AAEA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;;AAEA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","file":"phaser-navmesh.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserNavmesh\"] = factory();\n\telse\n\t\troot[\"PhaserNavmesh\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 148d0aa2c9e9142cf15a","/**\r\n * Twice the area of the triangle formed by a, b and c\r\n * @private\r\n */\r\nexport function triarea2(a, b, c) {\r\n    const ax = b.x - a.x;\r\n    const ay = b.y - a.y;\r\n    const bx = c.x - a.x;\r\n    const by = c.y - a.y;\r\n    return bx * ay - ax * by;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function almostEqual(value1, value2, errorMargin = 0.0001) {\r\n    if (Math.abs(value1 - value2) <= errorMargin) return true;\r\n    else return false;\r\n}\r\n\r\n/**\r\n * https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0\r\n * @private\r\n */\r\nexport function angleDifference(x, y) {\r\n    let a = x - y;\r\n    const i = a + Math.PI;\r\n    const j = Math.PI * 2;\r\n    a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign\r\n    a -= Math.PI;\r\n    return a;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function areCollinear(line1, line2, errorMargin=0.0001) {\r\n    // Figure out if the two lines are equal by looking at the area of the triangle formed\r\n    // by their points\r\n    const area1 = triarea2(line1.start, line1.end, line2.start);\r\n    const area2 = triarea2(line1.start, line1.end, line2.end);\r\n    if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {\r\n        return true;\r\n    } else return false;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./utils.js","// javascript-astar 0.4.2\r\n// http://github.com/bgrins/javascript-astar\r\n// Freely distributable under the MIT License.\r\n// Implements the astar search algorithm in javascript using a Binary Heap.\r\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\r\n// http://eloquentjavascript.net/appendix2.html\r\n(function(definition) {\r\n  /* global module, define */\r\n  if (typeof module === 'object' && typeof module.exports === 'object') {\r\n    module.exports = definition();\r\n  } else if (typeof define === 'function' && define.amd) {\r\n    define([], definition);\r\n  } else {\r\n    var exports = definition();\r\n    window.astar = exports.astar;\r\n    window.Graph = exports.Graph;\r\n  }\r\n})(function() {\r\n\r\nfunction pathTo(node) {\r\n  var curr = node;\r\n  var path = [];\r\n  while (curr.parent) {\r\n    path.unshift(curr);\r\n    curr = curr.parent;\r\n  }\r\n  return path;\r\n}\r\n\r\nfunction getHeap() {\r\n  return new BinaryHeap(function(node) {\r\n    return node.f;\r\n  });\r\n}\r\n\r\nvar astar = {\r\n  /**\r\n  * Perform an A* Search on a graph given a start and end node.\r\n  * @param {Graph} graph\r\n  * @param {GridNode} start\r\n  * @param {GridNode} end\r\n  * @param {Object} [options]\r\n  * @param {bool} [options.closest] Specifies whether to return the\r\n             path to the closest node if the target is unreachable.\r\n  * @param {Function} [options.heuristic] Heuristic function (see\r\n  *          astar.heuristics).\r\n  */\r\n  search: function(graph, start, end, options) {\r\n    graph.cleanDirty();\r\n    options = options || {};\r\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\r\n    var closest = options.closest || false;\r\n\r\n    var openHeap = getHeap();\r\n    var closestNode = start; // set the start node to be the closest if required\r\n\r\n    start.h = heuristic(start, end);\r\n    graph.markDirty(start);\r\n\r\n    openHeap.push(start);\r\n\r\n    while (openHeap.size() > 0) {\r\n\r\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\r\n      var currentNode = openHeap.pop();\r\n\r\n      // End case -- result has been found, return the traced path.\r\n      if (currentNode === end) {\r\n        return pathTo(currentNode);\r\n      }\r\n\r\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\r\n      currentNode.closed = true;\r\n\r\n      // Find all neighbors for the current node.\r\n      var neighbors = graph.neighbors(currentNode);\r\n\r\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\r\n        var neighbor = neighbors[i];\r\n\r\n        if (neighbor.closed || neighbor.isWall()) {\r\n          // Not a valid node to process, skip to next neighbor.\r\n          continue;\r\n        }\r\n\r\n        // The g score is the shortest distance from start to current node.\r\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\r\n        var gScore = currentNode.g + neighbor.getCost(currentNode);\r\n        var beenVisited = neighbor.visited;\r\n\r\n        if (!beenVisited || gScore < neighbor.g) {\r\n\r\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\r\n          neighbor.visited = true;\r\n          neighbor.parent = currentNode;\r\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\r\n          neighbor.g = gScore;\r\n          neighbor.f = neighbor.g + neighbor.h;\r\n          graph.markDirty(neighbor);\r\n          if (closest) {\r\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\r\n            // a cheaper path than the current closest node then it becomes the closest node\r\n            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\r\n              closestNode = neighbor;\r\n            }\r\n          }\r\n\r\n          if (!beenVisited) {\r\n            // Pushing to heap will put it in proper place based on the 'f' value.\r\n            openHeap.push(neighbor);\r\n          } else {\r\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\r\n            openHeap.rescoreElement(neighbor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (closest) {\r\n      return pathTo(closestNode);\r\n    }\r\n\r\n    // No result was found - empty array signifies failure to find path.\r\n    return [];\r\n  },\r\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\r\n  heuristics: {\r\n    manhattan: function(pos0, pos1) {\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return d1 + d2;\r\n    },\r\n    diagonal: function(pos0, pos1) {\r\n      var D = 1;\r\n      var D2 = Math.sqrt(2);\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\r\n    }\r\n  },\r\n  cleanNode: function(node) {\r\n    node.f = 0;\r\n    node.g = 0;\r\n    node.h = 0;\r\n    node.visited = false;\r\n    node.closed = false;\r\n    node.parent = null;\r\n  }\r\n};\r\n\r\n/**\r\n * A graph memory structure\r\n * @param {Array} gridIn 2D array of input weights\r\n * @param {Object} [options]\r\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\r\n */\r\nfunction Graph(gridIn, options) {\r\n  options = options || {};\r\n  this.nodes = [];\r\n  this.diagonal = !!options.diagonal;\r\n  this.grid = [];\r\n  for (var x = 0; x < gridIn.length; x++) {\r\n    this.grid[x] = [];\r\n\r\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\r\n      var node = new GridNode(x, y, row[y]);\r\n      this.grid[x][y] = node;\r\n      this.nodes.push(node);\r\n    }\r\n  }\r\n  this.init();\r\n}\r\n\r\nGraph.prototype.init = function() {\r\n  this.dirtyNodes = [];\r\n  for (var i = 0; i < this.nodes.length; i++) {\r\n    astar.cleanNode(this.nodes[i]);\r\n  }\r\n};\r\n\r\nGraph.prototype.cleanDirty = function() {\r\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\r\n    astar.cleanNode(this.dirtyNodes[i]);\r\n  }\r\n  this.dirtyNodes = [];\r\n};\r\n\r\nGraph.prototype.markDirty = function(node) {\r\n  this.dirtyNodes.push(node);\r\n};\r\n\r\nGraph.prototype.neighbors = function(node) {\r\n  var ret = [];\r\n  var x = node.x;\r\n  var y = node.y;\r\n  var grid = this.grid;\r\n\r\n  // West\r\n  if (grid[x - 1] && grid[x - 1][y]) {\r\n    ret.push(grid[x - 1][y]);\r\n  }\r\n\r\n  // East\r\n  if (grid[x + 1] && grid[x + 1][y]) {\r\n    ret.push(grid[x + 1][y]);\r\n  }\r\n\r\n  // South\r\n  if (grid[x] && grid[x][y - 1]) {\r\n    ret.push(grid[x][y - 1]);\r\n  }\r\n\r\n  // North\r\n  if (grid[x] && grid[x][y + 1]) {\r\n    ret.push(grid[x][y + 1]);\r\n  }\r\n\r\n  if (this.diagonal) {\r\n    // Southwest\r\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\r\n      ret.push(grid[x - 1][y - 1]);\r\n    }\r\n\r\n    // Southeast\r\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\r\n      ret.push(grid[x + 1][y - 1]);\r\n    }\r\n\r\n    // Northwest\r\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\r\n      ret.push(grid[x - 1][y + 1]);\r\n    }\r\n\r\n    // Northeast\r\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\r\n      ret.push(grid[x + 1][y + 1]);\r\n    }\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nGraph.prototype.toString = function() {\r\n  var graphString = [];\r\n  var nodes = this.grid;\r\n  for (var x = 0; x < nodes.length; x++) {\r\n    var rowDebug = [];\r\n    var row = nodes[x];\r\n    for (var y = 0; y < row.length; y++) {\r\n      rowDebug.push(row[y].weight);\r\n    }\r\n    graphString.push(rowDebug.join(\" \"));\r\n  }\r\n  return graphString.join(\"\\n\");\r\n};\r\n\r\nfunction GridNode(x, y, weight) {\r\n  this.x = x;\r\n  this.y = y;\r\n  this.weight = weight;\r\n}\r\n\r\nGridNode.prototype.toString = function() {\r\n  return \"[\" + this.x + \" \" + this.y + \"]\";\r\n};\r\n\r\nGridNode.prototype.getCost = function(fromNeighbor) {\r\n  // Take diagonal weight into consideration.\r\n  if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\r\n    return this.weight * 1.41421;\r\n  }\r\n  return this.weight;\r\n};\r\n\r\nGridNode.prototype.isWall = function() {\r\n  return this.weight === 0;\r\n};\r\n\r\nfunction BinaryHeap(scoreFunction) {\r\n  this.content = [];\r\n  this.scoreFunction = scoreFunction;\r\n}\r\n\r\nBinaryHeap.prototype = {\r\n  push: function(element) {\r\n    // Add the new element to the end of the array.\r\n    this.content.push(element);\r\n\r\n    // Allow it to sink down.\r\n    this.sinkDown(this.content.length - 1);\r\n  },\r\n  pop: function() {\r\n    // Store the first element so we can return it later.\r\n    var result = this.content[0];\r\n    // Get the element at the end of the array.\r\n    var end = this.content.pop();\r\n    // If there are any elements left, put the end element at the\r\n    // start, and let it bubble up.\r\n    if (this.content.length > 0) {\r\n      this.content[0] = end;\r\n      this.bubbleUp(0);\r\n    }\r\n    return result;\r\n  },\r\n  remove: function(node) {\r\n    var i = this.content.indexOf(node);\r\n\r\n    // When it is found, the process seen in 'pop' is repeated\r\n    // to fill up the hole.\r\n    var end = this.content.pop();\r\n\r\n    if (i !== this.content.length - 1) {\r\n      this.content[i] = end;\r\n\r\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n        this.sinkDown(i);\r\n      } else {\r\n        this.bubbleUp(i);\r\n      }\r\n    }\r\n  },\r\n  size: function() {\r\n    return this.content.length;\r\n  },\r\n  rescoreElement: function(node) {\r\n    this.sinkDown(this.content.indexOf(node));\r\n  },\r\n  sinkDown: function(n) {\r\n    // Fetch the element that has to be sunk.\r\n    var element = this.content[n];\r\n\r\n    // When at 0, an element can not sink any further.\r\n    while (n > 0) {\r\n\r\n      // Compute the parent element's index, and fetch it.\r\n      var parentN = ((n + 1) >> 1) - 1;\r\n      var parent = this.content[parentN];\r\n      // Swap the elements if the parent is greater.\r\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n        this.content[parentN] = element;\r\n        this.content[n] = parent;\r\n        // Update 'n' to continue at the new position.\r\n        n = parentN;\r\n      }\r\n      // Found a parent that is less, no need to sink any further.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  },\r\n  bubbleUp: function(n) {\r\n    // Look up the target element and its score.\r\n    var length = this.content.length;\r\n    var element = this.content[n];\r\n    var elemScore = this.scoreFunction(element);\r\n\r\n    while (true) {\r\n      // Compute the indices of the child elements.\r\n      var child2N = (n + 1) << 1;\r\n      var child1N = child2N - 1;\r\n      // This is used to store the new position of the element, if any.\r\n      var swap = null;\r\n      var child1Score;\r\n      // If the first child exists (is inside the array)...\r\n      if (child1N < length) {\r\n        // Look it up and compute its score.\r\n        var child1 = this.content[child1N];\r\n        child1Score = this.scoreFunction(child1);\r\n\r\n        // If the score is less than our element's, we need to swap.\r\n        if (child1Score < elemScore) {\r\n          swap = child1N;\r\n        }\r\n      }\r\n\r\n      // Do the same checks for the other child.\r\n      if (child2N < length) {\r\n        var child2 = this.content[child2N];\r\n        var child2Score = this.scoreFunction(child2);\r\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\r\n          swap = child2N;\r\n        }\r\n      }\r\n\r\n      // If the element needs to be moved, swap it, and continue.\r\n      if (swap !== null) {\r\n        this.content[n] = this.content[swap];\r\n        this.content[swap] = element;\r\n        n = swap;\r\n      }\r\n      // Otherwise, we are done.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nreturn {\r\n  astar: astar,\r\n  Graph: Graph\r\n};\r\n\r\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/navmesh-phaser-plugin/~/javascript-astar/astar.js\n// module id = 1\n// module chunks = 0 1","import jsastar from \"javascript-astar\";\r\nimport NavPoly from \"./nav-poly\";\r\nimport NavGraph from \"./nav-graph\";\r\nimport Channel from \"./channel\";\r\nimport {angleDifference, areCollinear} from \"./utils\";\r\n\r\n/**\r\n * The workhorse that represents a navigation mesh built from a series of polygons. Once built, the\r\n * mesh can be asked for a path from one point to another point. It has debug methods for \r\n * visualizing paths and visualizing the individual polygons. Some internal terminology usage:\r\n * \r\n * - neighbor: a polygon that shares part of an edge with another polygon\r\n * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment\r\n * - channel: the path of polygons from starting point to end point\r\n * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the\r\n *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut.\r\n */\r\nclass NavMesh {\r\n    /**\r\n     * Creates an instance of NavMesh.\r\n     * \r\n     * @param {Phaser.Game} game\r\n     * @param {Phaser.Polygon[]} polygons\r\n     * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n     * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n     */\r\n    constructor(game, polygons, meshShrinkAmount = 0) {\r\n        this.game = game;\r\n        this._debugGraphics = null;\r\n        this._meshShrinkAmount = meshShrinkAmount;\r\n\r\n        // Construct NavPoly instances for each polygon\r\n        this._navPolygons = [];\r\n        for (const [i, polygon] of polygons.entries()) {\r\n            this._navPolygons.push(new NavPoly(game, i, polygon));\r\n        }\r\n\r\n        this._calculateNeighbors();\r\n\r\n        // Astar graph of connections between polygons\r\n        this._graph = new NavGraph(this._navPolygons);\r\n    }\r\n\r\n    /**\r\n     * Cleanup method to remove references so that navmeshes don't hang around from state to state.\r\n     * You don't have to invoke this directly. If you call destroy on the plugin, it will destroy\r\n     * all navmeshes that have been created. \r\n     * \r\n     * @memberof NavMesh\r\n     */\r\n    destroy() {\r\n        this._graph.destroy();\r\n        for (const poly of this._navPolygons) poly.destroy();\r\n        this._navPolygons = [];\r\n        this.game = null;\r\n        this.disableDebug();\r\n    }\r\n\r\n    /**\r\n     * Find a path from the start point to the end point using this nav mesh.\r\n     *\r\n     * @param {Phaser.Point} startPoint\r\n     * @param {Phaser.Point} endPoint\r\n     * @param {object} [drawOptions={}] Options for controlling debug drawing\r\n     * @param {boolean} [drawOptions.drawPolyPath=false] Whether or not to visualize the path\r\n     * through the polygons - e.g. the path that astar found.\r\n     * @param {boolean} [drawOptions.drawFinalPath=false] Whether or not to visualize the path\r\n     * through the path that was returned.\r\n     * @returns {Phaser.Point[]|null} An array of points if a path is found, or null if no path\r\n     *\r\n     * @memberof NavMesh\r\n     */\r\n    findPath(startPoint, endPoint, {drawPolyPath = false, drawFinalPath = false} = {}) {\r\n        let startPoly = null;\r\n        let endPoly = null;\r\n        let startDistance = Number.MAX_VALUE;\r\n        let endDistance = Number.MAX_VALUE;\r\n        let d, r;\r\n\r\n        // Find the closest poly for the starting and ending point\r\n        for (const navPoly of this._navPolygons) {\r\n            r = navPoly.boundingRadius;\r\n            // Start\r\n            d = navPoly.centroid.distance(startPoint);\r\n            if (d <= startDistance && d <= r && navPoly.constains(startPoint)) {\r\n                startPoly = navPoly;\r\n                startDistance = d;\r\n            }\r\n            // End\r\n            d = navPoly.centroid.distance(endPoint);\r\n            if (d <= endDistance && d <= r && navPoly.constains(endPoint)) {\r\n                endPoly = navPoly;\r\n                endDistance = d;\r\n            }\r\n        }\r\n\r\n        // If the start point wasn't inside a polygon, run a more liberal check that allows a point\r\n        // to be within meshShrinkAmount radius of a polygon\r\n        if (!startPoly && this._meshShrinkAmount > 0) {\r\n            for (const navPoly of this._navPolygons) {\r\n                // Check if point is within bounding circle to avoid extra projection calculations\r\n                r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n                d = navPoly.centroid.distance(startPoint);\r\n                if (d <= r) {\r\n                    // Check if projected point is within range of a polgyon and is closer than the\r\n                    // previous point\r\n                    const {distance} = this._projectPointToPolygon(startPoint, navPoly);\r\n                    if (distance <= this._meshShrinkAmount && distance < startDistance) {\r\n                        startPoly = navPoly;\r\n                        startDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Same check as above, but for the end point\r\n        if (!endPoly && this._meshShrinkAmount > 0) {\r\n            for (const navPoly of this._navPolygons) {\r\n                r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n                d = navPoly.centroid.distance(endPoint);\r\n                if (d <= r) {\r\n                    const {distance}  = this._projectPointToPolygon(endPoint, navPoly);\r\n                    if (distance <= this._meshShrinkAmount && distance < endDistance) {\r\n                        endPoly = navPoly;\r\n                        endDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // No matching polygons locations for the start or end, so no path found\r\n        if (!startPoly || !endPoly) return null;\r\n        \r\n        // Search!\r\n        const astarPath = jsastar.astar.search(this._graph, startPoly, endPoly, {\r\n            heuristic: this._graph.navHeuristic\r\n        });\r\n        // jsastar drops the first point from the path, but the funnel algorithm needs it\r\n        astarPath.unshift(startPoly);\r\n        \r\n        // We have a path, so now time for the funnel algorithm\r\n        const channel = new Channel();\r\n        channel.push(startPoint);\r\n        for (let i = 0; i < astarPath.length - 1; i++) {\r\n            const navPolygon = astarPath[i];\r\n            const nextNavPolygon = astarPath[i + 1];\r\n\r\n            // Find the portal\r\n            let portal = null;\r\n            for (let i = 0; i < navPolygon.neighbors.length; i++) {\r\n                if (navPolygon.neighbors[i].id === nextNavPolygon.id) {\r\n                    portal = navPolygon.portals[i];\r\n                }\r\n            }\r\n\r\n            // Push the portal vertices into the channel\r\n            channel.push(portal.start, portal.end);\r\n        }\r\n        channel.push(endPoint);\r\n\r\n        // Pull a string along the channel to run the funnel\r\n        channel.stringPull();\r\n\r\n        // Clone path, excluding duplicates\r\n        let lastPoint = null;\r\n        const phaserPath = [];\r\n        for (const p of channel.path) {\r\n            const newPoint = p.clone();\r\n            if (!lastPoint || !newPoint.equals(lastPoint)) phaserPath.push(newPoint);\r\n            lastPoint = newPoint;\r\n        }\r\n\r\n        // Call debug drawing\r\n        if (drawPolyPath) {\r\n            const polyPath = astarPath.map((elem) => elem.centroid);\r\n            this.debugDrawPath(polyPath, 0x00ff00, 5);\r\n        }\r\n        if (drawFinalPath) this.debugDrawPath(phaserPath, 0xffd900, 10);\r\n\r\n        return phaserPath;\r\n    }\r\n\r\n    _calculateNeighbors() {\r\n        // Fill out the neighbor information for each navpoly\r\n        for (let i = 0; i < this._navPolygons.length; i++) {\r\n            const navPoly = this._navPolygons[i];\r\n\r\n            for (let j = i + 1; j < this._navPolygons.length; j++) {\r\n                const otherNavPoly = this._navPolygons[j];\r\n\r\n                // Check if the other navpoly is within range to touch\r\n                const d = navPoly.centroid.distance(otherNavPoly.centroid);\r\n                if (d > (navPoly.boundingRadius + otherNavPoly.boundingRadius)) continue;\r\n\r\n                // The are in range, so check each edge pairing\r\n                for (const edge of navPoly.edges) {\r\n                    for (const otherEdge of otherNavPoly.edges) {\r\n                        \r\n                        // If edges aren't collinear, not an option for connecting navpolys\r\n                        if (!areCollinear(edge, otherEdge)) continue;\r\n\r\n                        // If they are collinear, check if they overlap\r\n                        const overlap = this._getSegmentOverlap(edge, otherEdge);\r\n                        if (!overlap) continue;\r\n                        \r\n                        // Connections are symmetric!\r\n                        navPoly.neighbors.push(otherNavPoly);\r\n                        otherNavPoly.neighbors.push(navPoly);\r\n\r\n                        // Calculate the portal between the two polygons - this needs to be in\r\n                        // counter-clockwise order, relative to each polygon\r\n                        const [p1, p2] = overlap;\r\n                        let edgeStartAngle = navPoly.centroid.angle(edge.start);\r\n                        let a1 = navPoly.centroid.angle(overlap[0]);\r\n                        let a2 = navPoly.centroid.angle(overlap[1]);\r\n                        let d1 = angleDifference(edgeStartAngle, a1);\r\n                        let d2 = angleDifference(edgeStartAngle, a2);\r\n                        if (d1 < d2) {\r\n                            navPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n                        } else {\r\n                            navPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\r\n                        }\r\n\r\n                        edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);\r\n                        a1 = otherNavPoly.centroid.angle(overlap[0]);\r\n                        a2 = otherNavPoly.centroid.angle(overlap[1]);\r\n                        d1 = angleDifference(edgeStartAngle, a1);\r\n                        d2 = angleDifference(edgeStartAngle, a2);\r\n                        if (d1 < d2) {\r\n                            otherNavPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n                        } else {\r\n                            otherNavPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\r\n                        }\r\n                            \r\n                        // Two convex polygons shouldn't be connected more than once! (Unless\r\n                        // there are unnecessary vertices...)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check two collinear line segments to see if they overlap by sorting the points.\r\n    // Algorithm source: http://stackoverflow.com/a/17152247\r\n    _getSegmentOverlap(line1, line2) {\r\n        const points = [\r\n            {line: line1, point: line1.start}, \r\n            {line: line1, point: line1.end}, \r\n            {line: line2, point: line2.start}, \r\n            {line: line2, point: line2.end}\r\n        ]; \r\n        points.sort(function (a, b) {\r\n            if (a.point.x < b.point.x) return -1;\r\n            else if (a.point.x > b.point.x) return 1;\r\n            else {\r\n                if (a.point.y < b.point.y) return -1;\r\n                else if (a.point.y > b.point.y) return 1;\r\n                else return 0;\r\n            }\r\n        });\r\n        // If the first two points in the array come from the same line, no overlap\r\n        const noOverlap = points[0].line === points[1].line;\r\n        // If the two middle points in the array are the same coordinates, then there is a \r\n        // single point of overlap.\r\n        const singlePointOverlap = points[1].point.equals(points[2].point);\r\n        if (noOverlap || singlePointOverlap) return null;\r\n        else return [points[1].point, points[2].point];\r\n    }\r\n\r\n    /**\r\n     * Project a point onto a polygon in the shortest distance possible.\r\n     * \r\n     * @param {Phaser.Point} point The point to project\r\n     * @param {NavPoly} navPoly The navigation polygon to test against\r\n     * @returns {{point: Phaser.Point, distance: number}}\r\n     * \r\n     * @private\r\n     * @memberof NavMesh\r\n     */\r\n    _projectPointToPolygon(point, navPoly) {\r\n        let closestProjection = null;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        for (const edge of navPoly.edges) {\r\n            const projectedPoint = this._projectPointToEdge(point, edge);\r\n            const d = point.distance(projectedPoint);\r\n            if (closestProjection === null || d < closestDistance) {\r\n                closestDistance = d;\r\n                closestProjection = projectedPoint;\r\n            }\r\n        }\r\n        return {point: closestProjection, distance: closestDistance};\r\n    }\r\n\r\n    _distanceSquared(a, b) {\r\n        const dx = b.x - a.x;\r\n        const dy = b.y - a.y;\r\n        return dx * dx + dy * dy;\r\n    }\r\n\r\n    // Project a point onto a line segment\r\n    // JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\r\n    _projectPointToEdge(point, line) {\r\n        const a = line.start;\r\n        const b = line.end;\r\n        // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find\r\n        // where our point lies on the line by solving for t:\r\n        //  t = [(p-a) . (b-a)] / |b-a|^2\r\n        const l2 = this._distanceSquared(a, b);\r\n        let t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;\r\n        // We clamp t from [0,1] to handle points outside the segment vw.\r\n        t = Phaser.Math.clamp(t, 0, 1);\r\n        // Project onto the segment\r\n        const p = new Phaser.Point(\r\n            a.x + t * (b.x - a.x),\r\n            a.y + t * (b.y - a.y)\r\n        );\r\n        return p;        \r\n    }\r\n\r\n    /**\r\n     * Enable debug and create graphics overlay (if it hasn't already been created) \r\n     */\r\n    enableDebug() {\r\n        if (!this._debugGraphics) {\r\n            this._debugGraphics = this.game.add.graphics(0, 0);\r\n            this._debugGraphics.alpha = 0.5;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable debug and destroy associated graphics\r\n     */\r\n    disableDebug() {\r\n        if (this._debugGraphics) {\r\n            this._debugGraphics.destroy();\r\n            this._debugGraphics = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check whether debug is enabled\r\n     * \r\n     * @returns {boolean}\r\n     */\r\n    isDebugEnabled() {\r\n        return this._debugGraphics !== null;\r\n    }\r\n\r\n    /**\r\n     * Clear the debug overlay\r\n     */\r\n    debugClear() {\r\n        if (this._debugGraphics) this._debugGraphics.clear();\r\n    }\r\n    \r\n    /**\r\n     * Visualize the polygons in the nav mesh as an overlay on top of the game\r\n     *\r\n     * @param {object} options\r\n     * @param {boolean} [options.drawCentroid=true] For each polygon, show the approx centroid\r\n     * @param {boolean} [options.drawBounds=false] For each polygon, show the bounding radius\r\n     * @param {boolean} [options.drawNeighbors=true] For each polygon, show the connections to\r\n     * neighbors\r\n     * @param {boolean} [options.drawPortals=true] For each polygon, show the portal edges\r\n     */\r\n    debugDrawMesh({drawCentroid = true, drawBounds = false, drawNeighbors = true, \r\n            drawPortals = true} = {}) {\r\n        if (!this._debugGraphics) this.enableDebug();\r\n        // Visualize the navigation mesh\r\n        for (const navPoly of this._navPolygons) {\r\n            navPoly.draw(this._debugGraphics, drawCentroid, drawBounds, drawNeighbors, drawPortals);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Visualize a path (array of points) on the debug graphics overlay\r\n     * \r\n     * @param {Phaser.Point[]} path \r\n     * @param {number} [color=0x00FF00] \r\n     * @param {number} [thickness=10] \r\n     */\r\n    debugDrawPath(path, color = 0x00FF00, thickness = 10) {\r\n        if (!this._debugGraphics) this.enableDebug();\r\n        if (path.length) {\r\n            // Draw line for path\r\n            this._debugGraphics.lineStyle(thickness, color);\r\n            this._debugGraphics.drawShape(new Phaser.Polygon(...path)); \r\n            this._debugGraphics.beginFill(color);\r\n            // Draw circle at start and end of path\r\n            const d = 0.5 * thickness;\r\n            this._debugGraphics.drawEllipse(path[0].x, path[0].y, d, d);\r\n            const lastPoint = path[path.length - 1];\r\n            this._debugGraphics.drawEllipse(lastPoint.x, lastPoint.y, d, d);\r\n            this._debugGraphics.endFill();\r\n        }\r\n    }\r\n}\r\n\r\nexport default NavMesh;\n\n\n// WEBPACK FOOTER //\n// ./nav-mesh.js","// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete\r\n// funnel algorithm so astar checks can be more accurate.\r\n\r\nimport {triarea2} from \"./utils\";\r\n\r\n/**\r\n * @private\r\n */\r\nclass Channel {\r\n    constructor() {\r\n        this.portals = [];\r\n    }\r\n\r\n    /**\r\n     * @param {Phaser.Point} p1 \r\n     * @param {Phaser.Point} p2 \r\n     * \r\n     * @memberof Channel\r\n     */\r\n    push(p1, p2 = null) {\r\n        if (p2 === null) p2 = p1;\r\n        this.portals.push({\r\n            left: p1, \r\n            right: p2\r\n        });\r\n    }\r\n\r\n    stringPull() {\r\n        var portals = this.portals;\r\n        var pts = [];\r\n        // Init scan state\r\n        var portalApex, portalLeft, portalRight;\r\n        var apexIndex = 0,\r\n            leftIndex = 0,\r\n            rightIndex = 0;\r\n\r\n        portalApex = portals[0].left;\r\n        portalLeft = portals[0].left;\r\n        portalRight = portals[0].right;\r\n\r\n        // Add start point.\r\n        pts.push(portalApex);\r\n\r\n        for (var i = 1; i < portals.length; i++) {\r\n            // Find the next portal vertices\r\n            var left = portals[i].left;\r\n            var right = portals[i].right;\r\n\r\n            // Update right vertex.\r\n            if (triarea2(portalApex, portalRight, right) <= 0.0) {\r\n                if (portalApex.equals(portalRight) || \r\n                        triarea2(portalApex, portalLeft, right) > 0.0) {\r\n                    // Tighten the funnel.\r\n                    portalRight = right;\r\n                    rightIndex = i;\r\n                } else {\r\n                    // Right vertex just crossed over the left vertex, so the left vertex should\r\n                    // now be part of the path.\r\n                    pts.push(portalLeft);\r\n                    \r\n                    // Restart scan from portal left point.\r\n\r\n                    // Make current left the new apex.\r\n                    portalApex = portalLeft;\r\n                    apexIndex = leftIndex;\r\n                    // Reset portal\r\n                    portalLeft = portalApex;\r\n                    portalRight = portalApex;\r\n                    leftIndex = apexIndex;\r\n                    rightIndex = apexIndex;\r\n                    // Restart scan\r\n                    i = apexIndex;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // Update left vertex.\r\n            if (triarea2(portalApex, portalLeft, left) >= 0.0) {\r\n                if (portalApex.equals(portalLeft) || \r\n                        triarea2(portalApex, portalRight, left) < 0.0) {\r\n                    // Tighten the funnel.\r\n                    portalLeft = left;\r\n                    leftIndex = i;\r\n                } else {\r\n                    // Left vertex just crossed over the right vertex, so the right vertex should\r\n                    // now be part of the path\r\n                    pts.push(portalRight);\r\n                    \r\n                    // Restart scan from portal right point.\r\n\r\n                    // Make current right the new apex.\r\n                    portalApex = portalRight;\r\n                    apexIndex = rightIndex;\r\n                    // Reset portal\r\n                    portalLeft = portalApex;\r\n                    portalRight = portalApex;\r\n                    leftIndex = apexIndex;\r\n                    rightIndex = apexIndex;\r\n                    // Restart scan\r\n                    i = apexIndex;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        if ((pts.length === 0) || (!pts[pts.length - 1].equals(portals[portals.length - 1].left))) {\r\n            // Append last point to path.\r\n            pts.push(portals[portals.length - 1].left);\r\n        }\r\n\r\n        this.path = pts;\r\n        return pts;\r\n    }\r\n}\r\n\r\nexport default Channel;\n\n\n// WEBPACK FOOTER //\n// ./channel.js","// const triangulate = require(\"./triangulate\");\r\nimport NavMesh from \"./nav-mesh\";\r\n\r\n/**\r\n * This plugin can create navigation meshes for use in Phaser. The navmeshes can be constructed from\r\n * convex polygons embedded in a Tiled map. Instantiate this using game.plugins.add(NavMeshPlugin).\r\n *\r\n * @param {Phaser.Game} game\r\n * @param {Phaser.PluginManager} manager\r\n */\r\nexport default class NavMeshPlugin extends Phaser.Plugin {\r\n    constructor(game, manager) {\r\n        super(game, manager);\r\n        this._navMeshes = [];\r\n    }\r\n\r\n    /**\r\n     * Load a navmesh from Tiled and switch it to be the current navmesh. Currently assumes that the\r\n     * polygons are squares!\r\n     * \r\n     * @param {Phaser.Tilemap} tilemap The tilemap that contains polygons under an object layer\r\n     * @param {string} objectKey The name of the object layer in the tilemap\r\n     * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n     * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n     * \r\n     * @memberof NavMeshPlugin\r\n     */\r\n    buildMeshFromTiled(tilemap, objectKey, meshShrinkAmount = 0) {\r\n        // Load up the object layer\r\n        const rects = tilemap.objects[objectKey] || [];\r\n        // Loop over the objects and construct a polygon\r\n        const polygons = [];\r\n        for (const r of rects) {\r\n            const top = r.y;\r\n            const bottom = r.y + r.height;\r\n            const left = r.x;\r\n            const right = r.x + r.width;\r\n            const poly = new Phaser.Polygon(left,top, left,bottom, right,bottom, right,top);\r\n            polygons.push(poly);\r\n        }\r\n        // Build the navmesh\r\n        const mesh = new NavMesh(this.game, polygons, meshShrinkAmount);\r\n        this._navMeshes.push(mesh);\r\n        return mesh;\r\n    }\r\n\r\n    destroy() {\r\n        for (const mesh of this._navMeshes) mesh.destroy();\r\n        this._navMeshes = [];\r\n        super.destroy();\r\n    }\r\n\r\n    // /**\r\n    //  * Build a navmesh from an array of convex polygons. This currently tesselates the polygons into\r\n    //  * triangles. They aren't as efficient or as well designed as ones made by hand in Tiled. \r\n    //  *\r\n    //  * @param {string} levelName The key to use to store the navmesh in the plugin  \r\n    //  * @param {[]} hulls An array of convex polygons describing the obstacles in the\r\n    //  * level. See lighting-plugin/hull-from-tiles.\r\n    //  *\r\n    //  * @memberof NavMeshPlugin\r\n    //  */\r\n    // buildMesh(levelName, hulls) {\r\n    //     const contours = this._buildContours(hulls);\r\n    //     // Get an array of triangulated vertices\r\n    //     const triangles = triangulate(contours, false); // Counter-clockwise ordering!\r\n    //     const polygons = [];\r\n    //     for (let i = 0; i < triangles.length; i += 6) {\r\n    //         const poly = new Phaser.Polygon(\r\n    //             // These should be in counter-clockwise order from triangulate\r\n    //             triangles[i + 0], triangles[i + 1], \r\n    //             triangles[i + 2], triangles[i + 3], \r\n    //             triangles[i + 4], triangles[i + 5]\r\n    //         );\r\n    //         polygons.push(poly);\r\n    //     }\r\n    //     const navMesh = new NavMesh(this.game, polygons);\r\n    //     this._navMeshes[levelName] = navMesh;\r\n    //     this._currentNavMesh = navMesh;\r\n    // }\r\n\r\n    // /**\r\n    //  * @param {[]} hulls \r\n    //  * @returns \r\n    //  * \r\n    //  * @memberof NavMeshPlugin\r\n    //  */\r\n    // _buildContours(hulls) {\r\n    //     const w = this.game.width;\r\n    //     const h = this.game.height;\r\n    //     // Start the contours\r\n    //     const contours = [\r\n    //         // Full screen - counter clockwise\r\n    //         Float32Array.of(0,0, 0,h, w,h, w,0)\r\n    //     ];\r\n    //     // For each convex hull add the contour\r\n    //     for (const hull of hulls) {\r\n    //         const contour = [];\r\n    //         for (const lineInfo of hull) {\r\n    //             contour.push(lineInfo.line.start.x, lineInfo.line.start.y);\r\n    //         }\r\n    //         contours.push(Float32Array.from(contour));\r\n    //     }\r\n    //     return contours;\r\n    // }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./index.js","import jsastar from \"javascript-astar\";\r\n\r\n/**\r\n * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar\r\n * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavGraph \r\n * @private\r\n */\r\nclass NavGraph {\r\n    constructor(navPolygons) {\r\n        this.nodes = navPolygons;\r\n        this.init();\r\n    }\r\n\r\n    neighbors(navPolygon) {\r\n        return navPolygon.neighbors;\r\n    }\r\n\r\n    navHeuristic(navPolygon1, navPolygon2) {\r\n        return navPolygon1.centroidDistance(navPolygon2);\r\n    }\r\n\r\n    destroy() {\r\n        this.cleanDirty();\r\n        this.nodes = [];\r\n    }\r\n}\r\n\r\nNavGraph.prototype.init = jsastar.Graph.prototype.init;\r\nNavGraph.prototype.cleanDirty = jsastar.Graph.prototype.cleanDirty;\r\nNavGraph.prototype.markDirty = jsastar.Graph.prototype.markDirty;\r\n\r\nexport default NavGraph;\n\n\n// WEBPACK FOOTER //\n// ./nav-graph.js","// Debug color palette\r\nconst palette = [0x00A0B0, 0x6A4A3C, 0xCC333F, 0xEB6841, 0xEDC951];\r\n\r\n/**\r\n * A class that represents a navigable polygon in a navmesh. It is build from a Phaser.Polygon. It\r\n * has a drawing function to help visualize it's features:\r\n *  - polygon\r\n *  - neighbors - any navpolys that can be reached from this navpoly\r\n *  - portals - overlapping edges between neighbors\r\n *  - centroid - not a true centroid, just an approximation.\r\n *  - boundingRadius - the radius of a circle at the centroid that fits all the points of the poly \r\n * \r\n * It implements the properties and fields that javascript-astar needs - weight, toString, isWall\r\n * and getCost. See GPS test from astar repo for structure: \r\n * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavPoly\r\n * @private\r\n */\r\nclass NavPoly {\r\n    /**\r\n     * Creates an instance of NavPoly.\r\n     * @param {Phaser.Game} game \r\n     * @param {number} id \r\n     * @param {Phaser.Polygon} polygon \r\n     * \r\n     * @memberof NavPoly\r\n     */\r\n    constructor(game, id, polygon) {\r\n        this.game = game;\r\n        this.id = id;\r\n        this.polygon = polygon;\r\n        this.edges = this._calculateEdges();\r\n        this.neighbors = [];\r\n        this.portals = [];\r\n        this.centroid = this._calculateCentroid();\r\n        this.boundingRadius = this._calculateRadius();\r\n\r\n        this.weight = 1; // jsastar property\r\n        \r\n        const i = this.id % palette.length;\r\n        this._color = palette[i];\r\n    }\r\n\r\n    constains(point) {\r\n        return this.polygon.contains(point.x, point.y);\r\n    }\r\n\r\n    destroy() {\r\n        this.game = null;\r\n        this.neighbors = [];\r\n        this.portals = [];\r\n    }\r\n\r\n    // jsastar methods\r\n    toString() {\r\n        return `NavPoly(id: ${this.id} at: ${this.centroid})`;\r\n    }\r\n    isWall() {\r\n        return this.weight === 0;\r\n    }\r\n    centroidDistance(navPolygon) {\r\n        return this.centroid.distance(navPolygon.centroid);\r\n    }\r\n    getCost(navPolygon) {\r\n        return this.centroidDistance(navPolygon);\r\n    }\r\n\r\n    _calculateEdges() {\r\n        const points = this.polygon.points;\r\n        const edges = [];\r\n        for (let i = 1; i < points.length; i++) {\r\n            const p1 = points[i - 1];\r\n            const p2 = points[i];\r\n            edges.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n        }\r\n        const first = points[0];\r\n        const last = points[points.length - 1]\r\n        edges.push(new Phaser.Line(first.x, first.y, last.x, last.y));\r\n        return edges;\r\n    }\r\n    \r\n    _calculateCentroid() {\r\n        // NOTE: this is not actually the centroid, it's the average of the vertices - not the same\r\n        // thing!\r\n        const centroid = new Phaser.Point(0, 0);\r\n        const length = this.polygon.points.length;\r\n        for (const point of this.polygon.points) {\r\n            centroid.add(point.x, point.y);\r\n        }\r\n        centroid.divide(length, length);\r\n        return centroid;\r\n    }\r\n\r\n    _calculateRadius() {\r\n        let boundingRadius = 0;\r\n        for (const point of this.polygon.points) {\r\n            const d = this.centroid.distance(point);\r\n            if (d > boundingRadius) boundingRadius = d;\r\n        }\r\n        return boundingRadius;\r\n    }\r\n\r\n    /**\r\n     * Draw the polygon to given graphics object\r\n     * \r\n     * @param {Phaser.Graphics} graphics \r\n     * @param {boolean} [drawCentroid=true] Show the approx centroid\r\n     * @param {boolean} [drawBounds=false] Show the bounding radius\r\n     * @param {boolean} [drawNeighbors=true] Show the connections to neighbors\r\n     * @param {boolean} [drawPortals=true] Show the portal edges\r\n     * \r\n     * @memberof NavPoly\r\n     */\r\n    draw(graphics, drawCentroid = true, drawBounds = false, drawNeighbors = true, \r\n            drawPortals = true) {\r\n        graphics.lineWidth = 0;\r\n        graphics.beginFill(this._color);\r\n        graphics.drawPolygon(this.polygon);\r\n        graphics.endFill();\r\n\r\n        if (drawCentroid) {\r\n            graphics.beginFill(0x000000);\r\n            graphics.drawEllipse(this.centroid.x, this.centroid.y, 4, 4);\r\n            graphics.endFill();\r\n        }\r\n\r\n        if (drawBounds) {\r\n            graphics.lineStyle(1, 0xFFFFFF);\r\n            const r = this.boundingRadius;\r\n            graphics.drawEllipse(this.centroid.x, this.centroid.y, r, r);\r\n        }\r\n\r\n        if (drawNeighbors) {\r\n            graphics.lineStyle(2, 0x000000);\r\n            for (const n of this.neighbors) {\r\n                graphics.moveTo(this.centroid.x, this.centroid.y);\r\n                graphics.lineTo(n.centroid.x, n.centroid.y);\r\n            }\r\n        }\r\n\r\n        if (drawPortals) {\r\n            graphics.lineStyle(10, 0x000000);\r\n            for (const p of this.portals) {\r\n                graphics.moveTo(p.start.x, p.start.y);\r\n                graphics.lineTo(p.end.x, p.end.y);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default NavPoly;\n\n\n// WEBPACK FOOTER //\n// ./nav-poly.js"],"sourceRoot":""}