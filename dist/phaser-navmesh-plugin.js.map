{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap b3956335bfed79eef32c","webpack:///./utils.js","webpack:///E:/Github/navmesh-phaser-plugin/~/javascript-astar/astar.js","webpack:///./nav-mesh.js","webpack:///./channel.js","webpack:///./index.js","webpack:///./nav-graph.js","webpack:///./nav-poly.js"],"names":["triarea2","a","b","c","ax","x","ay","y","bx","by","almostEqual","value1","value2","errorMargin","Math","abs","angleDifference","i","PI","j","floor","areCollinear","line1","line2","area1","start","end","area2","NavMesh","game","polygons","meshShrinkAmount","_debugGraphics","_meshShrinkAmount","_navPolygons","entries","polygon","push","_calculateNeighbors","graph","startPoint","endPoint","drawPolyPath","drawFinalPath","startPoly","endPoly","startDistance","Number","MAX_VALUE","endDistance","d","r","navPoly","boundingRadius","centroid","distance","constains","_projectPointToPolygon","astarPath","jsastar","astar","search","heuristic","navHeuristic","unshift","channel","length","navPolygon","nextNavPolygon","portal","neighbors","id","portals","stringPull","lastPoint","phaserPath","path","p","newPoint","clone","equals","debugDraw","otherNavPoly","edges","edge","otherEdge","overlap","_getSegmentOverlap","p1","p2","edgeStartAngle","angle","a1","a2","d1","d2","Phaser","Line","points","line","point","sort","noOverlap","singlePointOverlap","closestProjection","closestDistance","projectedPoint","_projectPointToEdge","dx","dy","l2","_distanceSquared","t","clamp","Point","add","graphics","alpha","destroy","clear","drawCentroid","drawBounds","drawNeighbors","drawPortals","enableDebug","draw","polyPath","funnelPath","lineStyle","moveTo","lineTo","lastPoly","Polygon","closed","drawShape","beginFill","drawEllipse","endFill","Channel","left","right","pts","portalApex","portalLeft","portalRight","apexIndex","leftIndex","rightIndex","NavMeshPlugin","manager","_pluginManager","_navmeshes","_currentLevel","levelName","tilemap","objectKey","rects","objects","top","bottom","height","width","poly","navMesh","_currentNavMesh","findPath","Plugin","NavGraph","navPolygons","nodes","init","navPolygon1","navPolygon2","centroidDistance","prototype","Graph","cleanDirty","markDirty","palette","NavPoly","_calculateEdges","_calculateCentroid","_calculateRadius","weight","_color","contains","first","last","divide","lineWidth","drawPolygon","n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;AChEA;AAAA;AACO,SAASA,QAAT,CAAkBC,CAAlB,EAAqBC,CAArB,EAAwBC,CAAxB,EAA2B;AAC9B,QAAMC,KAAKF,EAAEG,CAAF,GAAMJ,EAAEI,CAAnB;AACA,QAAMC,KAAKJ,EAAEK,CAAF,GAAMN,EAAEM,CAAnB;AACA,QAAMC,KAAKL,EAAEE,CAAF,GAAMJ,EAAEI,CAAnB;AACA,QAAMI,KAAKN,EAAEI,CAAF,GAAMN,EAAEM,CAAnB;AACA,WAAOC,KAAKF,EAAL,GAAUF,KAAKK,EAAtB;AACH;;AAEM,SAASC,WAAT,CAAqBC,MAArB,EAA6BC,MAA7B,EAA2D;AAAA,QAAtBC,WAAsB,uEAAR,MAAQ;;AAC9D,QAAIC,KAAKC,GAAL,CAASJ,SAASC,MAAlB,KAA6BC,WAAjC,EAA8C,OAAO,IAAP,CAA9C,KACK,OAAO,KAAP;AACR;;AAED;AACO,SAASG,eAAT,CAAyBX,CAAzB,EAA4BE,CAA5B,EAA+B;AAClC,QAAIN,IAAII,IAAIE,CAAZ;AACA,QAAMU,IAAIhB,IAAIa,KAAKI,EAAnB;AACA,QAAMC,IAAIL,KAAKI,EAAL,GAAU,CAApB;AACAjB,QAAIgB,IAAIH,KAAKM,KAAL,CAAWH,IAAIE,CAAf,IAAoBA,CAA5B,CAJkC,CAIH;AAC/BlB,SAAKa,KAAKI,EAAV;AACA,WAAOjB,CAAP;AACH;;AAEM,SAASoB,YAAT,CAAsBC,KAAtB,EAA6BC,KAA7B,EAAwD;AAAA,QAApBV,WAAoB,uEAAR,MAAQ;;AAC3D;AACA;AACA,QAAMW,QAAQxB,SAASsB,MAAMG,KAAf,EAAsBH,MAAMI,GAA5B,EAAiCH,MAAME,KAAvC,CAAd;AACA,QAAME,QAAQ3B,SAASsB,MAAMG,KAAf,EAAsBH,MAAMI,GAA5B,EAAiCH,MAAMG,GAAvC,CAAd;AACA,QAAIhB,YAAYc,KAAZ,EAAmB,CAAnB,EAAsBX,WAAtB,KAAsCH,YAAYiB,KAAZ,EAAmB,CAAnB,EAAsBd,WAAtB,CAA1C,EAA8E;AAC1E,eAAO,IAAP;AACH,KAFD,MAEO,OAAO,KAAP;AACV,C;;;;;;AChCD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AAAA;AAAA;AAAA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4CAA4C,QAAQ;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;;AAEA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;;AAEA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;A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","file":"phaser-navmesh-plugin.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"phaserNavmeshPlugin\"] = factory();\n\telse\n\t\troot[\"phaserNavmeshPlugin\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b3956335bfed79eef32c","// Twice the area of the triangle formed by a, b and c\r\nexport function triarea2(a, b, c) {\r\n    const ax = b.x - a.x;\r\n    const ay = b.y - a.y;\r\n    const bx = c.x - a.x;\r\n    const by = c.y - a.y;\r\n    return bx * ay - ax * by;\r\n}\r\n\r\nexport function almostEqual(value1, value2, errorMargin = 0.0001) {\r\n    if (Math.abs(value1 - value2) <= errorMargin) return true;\r\n    else return false;\r\n}\r\n\r\n// https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0\r\nexport function angleDifference(x, y) {\r\n    let a = x - y;\r\n    const i = a + Math.PI;\r\n    const j = Math.PI * 2;\r\n    a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign\r\n    a -= Math.PI;\r\n    return a;\r\n}\r\n\r\nexport function areCollinear(line1, line2, errorMargin=0.0001) {\r\n    // Figure out if the two lines are equal by looking at the area of the triangle formed\r\n    // by their points\r\n    const area1 = triarea2(line1.start, line1.end, line2.start);\r\n    const area2 = triarea2(line1.start, line1.end, line2.end);\r\n    if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {\r\n        return true;\r\n    } else return false;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./utils.js","// javascript-astar 0.4.2\r\n// http://github.com/bgrins/javascript-astar\r\n// Freely distributable under the MIT License.\r\n// Implements the astar search algorithm in javascript using a Binary Heap.\r\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\r\n// http://eloquentjavascript.net/appendix2.html\r\n(function(definition) {\r\n  /* global module, define */\r\n  if (typeof module === 'object' && typeof module.exports === 'object') {\r\n    module.exports = definition();\r\n  } else if (typeof define === 'function' && define.amd) {\r\n    define([], definition);\r\n  } else {\r\n    var exports = definition();\r\n    window.astar = exports.astar;\r\n    window.Graph = exports.Graph;\r\n  }\r\n})(function() {\r\n\r\nfunction pathTo(node) {\r\n  var curr = node;\r\n  var path = [];\r\n  while (curr.parent) {\r\n    path.unshift(curr);\r\n    curr = curr.parent;\r\n  }\r\n  return path;\r\n}\r\n\r\nfunction getHeap() {\r\n  return new BinaryHeap(function(node) {\r\n    return node.f;\r\n  });\r\n}\r\n\r\nvar astar = {\r\n  /**\r\n  * Perform an A* Search on a graph given a start and end node.\r\n  * @param {Graph} graph\r\n  * @param {GridNode} start\r\n  * @param {GridNode} end\r\n  * @param {Object} [options]\r\n  * @param {bool} [options.closest] Specifies whether to return the\r\n             path to the closest node if the target is unreachable.\r\n  * @param {Function} [options.heuristic] Heuristic function (see\r\n  *          astar.heuristics).\r\n  */\r\n  search: function(graph, start, end, options) {\r\n    graph.cleanDirty();\r\n    options = options || {};\r\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\r\n    var closest = options.closest || false;\r\n\r\n    var openHeap = getHeap();\r\n    var closestNode = start; // set the start node to be the closest if required\r\n\r\n    start.h = heuristic(start, end);\r\n    graph.markDirty(start);\r\n\r\n    openHeap.push(start);\r\n\r\n    while (openHeap.size() > 0) {\r\n\r\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\r\n      var currentNode = openHeap.pop();\r\n\r\n      // End case -- result has been found, return the traced path.\r\n      if (currentNode === end) {\r\n        return pathTo(currentNode);\r\n      }\r\n\r\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\r\n      currentNode.closed = true;\r\n\r\n      // Find all neighbors for the current node.\r\n      var neighbors = graph.neighbors(currentNode);\r\n\r\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\r\n        var neighbor = neighbors[i];\r\n\r\n        if (neighbor.closed || neighbor.isWall()) {\r\n          // Not a valid node to process, skip to next neighbor.\r\n          continue;\r\n        }\r\n\r\n        // The g score is the shortest distance from start to current node.\r\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\r\n        var gScore = currentNode.g + neighbor.getCost(currentNode);\r\n        var beenVisited = neighbor.visited;\r\n\r\n        if (!beenVisited || gScore < neighbor.g) {\r\n\r\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\r\n          neighbor.visited = true;\r\n          neighbor.parent = currentNode;\r\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\r\n          neighbor.g = gScore;\r\n          neighbor.f = neighbor.g + neighbor.h;\r\n          graph.markDirty(neighbor);\r\n          if (closest) {\r\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\r\n            // a cheaper path than the current closest node then it becomes the closest node\r\n            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\r\n              closestNode = neighbor;\r\n            }\r\n          }\r\n\r\n          if (!beenVisited) {\r\n            // Pushing to heap will put it in proper place based on the 'f' value.\r\n            openHeap.push(neighbor);\r\n          } else {\r\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\r\n            openHeap.rescoreElement(neighbor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (closest) {\r\n      return pathTo(closestNode);\r\n    }\r\n\r\n    // No result was found - empty array signifies failure to find path.\r\n    return [];\r\n  },\r\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\r\n  heuristics: {\r\n    manhattan: function(pos0, pos1) {\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return d1 + d2;\r\n    },\r\n    diagonal: function(pos0, pos1) {\r\n      var D = 1;\r\n      var D2 = Math.sqrt(2);\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\r\n    }\r\n  },\r\n  cleanNode: function(node) {\r\n    node.f = 0;\r\n    node.g = 0;\r\n    node.h = 0;\r\n    node.visited = false;\r\n    node.closed = false;\r\n    node.parent = null;\r\n  }\r\n};\r\n\r\n/**\r\n * A graph memory structure\r\n * @param {Array} gridIn 2D array of input weights\r\n * @param {Object} [options]\r\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\r\n */\r\nfunction Graph(gridIn, options) {\r\n  options = options || {};\r\n  this.nodes = [];\r\n  this.diagonal = !!options.diagonal;\r\n  this.grid = [];\r\n  for (var x = 0; x < gridIn.length; x++) {\r\n    this.grid[x] = [];\r\n\r\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\r\n      var node = new GridNode(x, y, row[y]);\r\n      this.grid[x][y] = node;\r\n      this.nodes.push(node);\r\n    }\r\n  }\r\n  this.init();\r\n}\r\n\r\nGraph.prototype.init = function() {\r\n  this.dirtyNodes = [];\r\n  for (var i = 0; i < this.nodes.length; i++) {\r\n    astar.cleanNode(this.nodes[i]);\r\n  }\r\n};\r\n\r\nGraph.prototype.cleanDirty = function() {\r\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\r\n    astar.cleanNode(this.dirtyNodes[i]);\r\n  }\r\n  this.dirtyNodes = [];\r\n};\r\n\r\nGraph.prototype.markDirty = function(node) {\r\n  this.dirtyNodes.push(node);\r\n};\r\n\r\nGraph.prototype.neighbors = function(node) {\r\n  var ret = [];\r\n  var x = node.x;\r\n  var y = node.y;\r\n  var grid = this.grid;\r\n\r\n  // West\r\n  if (grid[x - 1] && grid[x - 1][y]) {\r\n    ret.push(grid[x - 1][y]);\r\n  }\r\n\r\n  // East\r\n  if (grid[x + 1] && grid[x + 1][y]) {\r\n    ret.push(grid[x + 1][y]);\r\n  }\r\n\r\n  // South\r\n  if (grid[x] && grid[x][y - 1]) {\r\n    ret.push(grid[x][y - 1]);\r\n  }\r\n\r\n  // North\r\n  if (grid[x] && grid[x][y + 1]) {\r\n    ret.push(grid[x][y + 1]);\r\n  }\r\n\r\n  if (this.diagonal) {\r\n    // Southwest\r\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\r\n      ret.push(grid[x - 1][y - 1]);\r\n    }\r\n\r\n    // Southeast\r\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\r\n      ret.push(grid[x + 1][y - 1]);\r\n    }\r\n\r\n    // Northwest\r\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\r\n      ret.push(grid[x - 1][y + 1]);\r\n    }\r\n\r\n    // Northeast\r\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\r\n      ret.push(grid[x + 1][y + 1]);\r\n    }\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nGraph.prototype.toString = function() {\r\n  var graphString = [];\r\n  var nodes = this.grid;\r\n  for (var x = 0; x < nodes.length; x++) {\r\n    var rowDebug = [];\r\n    var row = nodes[x];\r\n    for (var y = 0; y < row.length; y++) {\r\n      rowDebug.push(row[y].weight);\r\n    }\r\n    graphString.push(rowDebug.join(\" \"));\r\n  }\r\n  return graphString.join(\"\\n\");\r\n};\r\n\r\nfunction GridNode(x, y, weight) {\r\n  this.x = x;\r\n  this.y = y;\r\n  this.weight = weight;\r\n}\r\n\r\nGridNode.prototype.toString = function() {\r\n  return \"[\" + this.x + \" \" + this.y + \"]\";\r\n};\r\n\r\nGridNode.prototype.getCost = function(fromNeighbor) {\r\n  // Take diagonal weight into consideration.\r\n  if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\r\n    return this.weight * 1.41421;\r\n  }\r\n  return this.weight;\r\n};\r\n\r\nGridNode.prototype.isWall = function() {\r\n  return this.weight === 0;\r\n};\r\n\r\nfunction BinaryHeap(scoreFunction) {\r\n  this.content = [];\r\n  this.scoreFunction = scoreFunction;\r\n}\r\n\r\nBinaryHeap.prototype = {\r\n  push: function(element) {\r\n    // Add the new element to the end of the array.\r\n    this.content.push(element);\r\n\r\n    // Allow it to sink down.\r\n    this.sinkDown(this.content.length - 1);\r\n  },\r\n  pop: function() {\r\n    // Store the first element so we can return it later.\r\n    var result = this.content[0];\r\n    // Get the element at the end of the array.\r\n    var end = this.content.pop();\r\n    // If there are any elements left, put the end element at the\r\n    // start, and let it bubble up.\r\n    if (this.content.length > 0) {\r\n      this.content[0] = end;\r\n      this.bubbleUp(0);\r\n    }\r\n    return result;\r\n  },\r\n  remove: function(node) {\r\n    var i = this.content.indexOf(node);\r\n\r\n    // When it is found, the process seen in 'pop' is repeated\r\n    // to fill up the hole.\r\n    var end = this.content.pop();\r\n\r\n    if (i !== this.content.length - 1) {\r\n      this.content[i] = end;\r\n\r\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n        this.sinkDown(i);\r\n      } else {\r\n        this.bubbleUp(i);\r\n      }\r\n    }\r\n  },\r\n  size: function() {\r\n    return this.content.length;\r\n  },\r\n  rescoreElement: function(node) {\r\n    this.sinkDown(this.content.indexOf(node));\r\n  },\r\n  sinkDown: function(n) {\r\n    // Fetch the element that has to be sunk.\r\n    var element = this.content[n];\r\n\r\n    // When at 0, an element can not sink any further.\r\n    while (n > 0) {\r\n\r\n      // Compute the parent element's index, and fetch it.\r\n      var parentN = ((n + 1) >> 1) - 1;\r\n      var parent = this.content[parentN];\r\n      // Swap the elements if the parent is greater.\r\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n        this.content[parentN] = element;\r\n        this.content[n] = parent;\r\n        // Update 'n' to continue at the new position.\r\n        n = parentN;\r\n      }\r\n      // Found a parent that is less, no need to sink any further.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  },\r\n  bubbleUp: function(n) {\r\n    // Look up the target element and its score.\r\n    var length = this.content.length;\r\n    var element = this.content[n];\r\n    var elemScore = this.scoreFunction(element);\r\n\r\n    while (true) {\r\n      // Compute the indices of the child elements.\r\n      var child2N = (n + 1) << 1;\r\n      var child1N = child2N - 1;\r\n      // This is used to store the new position of the element, if any.\r\n      var swap = null;\r\n      var child1Score;\r\n      // If the first child exists (is inside the array)...\r\n      if (child1N < length) {\r\n        // Look it up and compute its score.\r\n        var child1 = this.content[child1N];\r\n        child1Score = this.scoreFunction(child1);\r\n\r\n        // If the score is less than our element's, we need to swap.\r\n        if (child1Score < elemScore) {\r\n          swap = child1N;\r\n        }\r\n      }\r\n\r\n      // Do the same checks for the other child.\r\n      if (child2N < length) {\r\n        var child2 = this.content[child2N];\r\n        var child2Score = this.scoreFunction(child2);\r\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\r\n          swap = child2N;\r\n        }\r\n      }\r\n\r\n      // If the element needs to be moved, swap it, and continue.\r\n      if (swap !== null) {\r\n        this.content[n] = this.content[swap];\r\n        this.content[swap] = element;\r\n        n = swap;\r\n      }\r\n      // Otherwise, we are done.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nreturn {\r\n  astar: astar,\r\n  Graph: Graph\r\n};\r\n\r\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/navmesh-phaser-plugin/~/javascript-astar/astar.js\n// module id = 1\n// module chunks = 0 1","import jsastar from \"javascript-astar\";\r\nimport NavPoly from \"./nav-poly\";\r\nimport NavGraph from \"./nav-graph\";\r\nimport Channel from \"./channel\";\r\nimport {angleDifference, areCollinear} from \"./utils\";\r\n\r\n/**\r\n * The workhorse that builds a navigation mesh from a series of polygons. Once built, the mesh can\r\n * be asked for a path from one point to another point. It has debug methods for visualizing paths\r\n * and visualizing the individual polygons. Some internal terminology usage:\r\n * \r\n * - neighbor: a polygon that shares part of an edge with another polygon\r\n * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment\r\n * - channel: the path of polygons from starting point to end point\r\n * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the\r\n *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut\r\n * \r\n * @class NavMesh\r\n */\r\nclass NavMesh {\r\n\r\n    /**\r\n     * Creates an instance of NavMesh.\r\n     * @param {Phaser.Game} game\r\n     * @param {Phaser.Polygon[]} polygons\r\n     * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n     * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n     *\r\n     * @memberof NavMesh\r\n     */\r\n    constructor(game, polygons, meshShrinkAmount = 0) {\r\n        this.game = game;\r\n        this._debugGraphics = null;\r\n        this._meshShrinkAmount = meshShrinkAmount;\r\n\r\n        // Construct NavPoly instances for each polygon\r\n        this._navPolygons = [];\r\n        for (const [i, polygon] of polygons.entries()) {\r\n            this._navPolygons.push(new NavPoly(game, i, polygon));\r\n        }\r\n\r\n        this._calculateNeighbors();\r\n\r\n        // Astar graph of connections between polygons\r\n        this.graph = new NavGraph(this._navPolygons);\r\n    }\r\n\r\n    /**\r\n     * Find a path from the start point to the end point using this nav mesh.\r\n     *\r\n     * @param {Phaser.Point} startPoint\r\n     * @param {Phaser.Point} endPoint\r\n     * @param {object} [drawOptions={}] Options for controlling debug drawing\r\n     * @param {boolean} [drawOptions.drawPolyPath=false] Whether or not to visualize the path\r\n     * through the polygons - e.g. the path that astar found.\r\n     * @param {boolean} [drawOptions.drawFinalPath=false] Whether or not to visualize the path\r\n     * through the path that was returned.\r\n     * @returns {Phaser.Point[]|null} An array of points if a path is found, or null if no path\r\n     *\r\n     * @memberof NavMesh\r\n     */\r\n    findPath(startPoint, endPoint, {drawPolyPath = false, drawFinalPath = false} = {}) {\r\n        let startPoly = null;\r\n        let endPoly = null;\r\n        let startDistance = Number.MAX_VALUE;\r\n        let endDistance = Number.MAX_VALUE;\r\n        let d, r;\r\n\r\n        // Find the closest poly for the starting and ending point\r\n        for (const navPoly of this._navPolygons) {\r\n            r = navPoly.boundingRadius;\r\n            // Start\r\n            d = navPoly.centroid.distance(startPoint);\r\n            if (d <= startDistance && d <= r && navPoly.constains(startPoint)) {\r\n                startPoly = navPoly;\r\n                startDistance = d;\r\n            }\r\n            // End\r\n            d = navPoly.centroid.distance(endPoint);\r\n            if (d <= endDistance && d <= r && navPoly.constains(endPoint)) {\r\n                endPoly = navPoly;\r\n                endDistance = d;\r\n            }\r\n        }\r\n\r\n        // If the start point wasn't inside a polygon, run a more liberal check that allows a point\r\n        // to be within meshShrinkAmount radius of a polygon\r\n        if (!startPoly && this._meshShrinkAmount > 0) {\r\n            for (const navPoly of this._navPolygons) {\r\n                // Check if point is within bounding circle to avoid extra projection calculations\r\n                r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n                d = navPoly.centroid.distance(startPoint);\r\n                if (d <= r) {\r\n                    // Check if projected point is within range of a polgyon and is closer than the\r\n                    // previous point\r\n                    const {distance} = this._projectPointToPolygon(startPoint, navPoly);\r\n                    if (distance <= this._meshShrinkAmount && distance < startDistance) {\r\n                        startPoly = navPoly;\r\n                        startDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Same check as above, but for the end point\r\n        if (!endPoly && this._meshShrinkAmount > 0) {\r\n            for (const navPoly of this._navPolygons) {\r\n                r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n                d = navPoly.centroid.distance(endPoint);\r\n                if (d <= r) {\r\n                    const {distance}  = this._projectPointToPolygon(endPoint, navPoly);\r\n                    if (distance <= this._meshShrinkAmount && distance < endDistance) {\r\n                        endPoly = navPoly;\r\n                        endDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // No matching polygons locations for the start or end, so no path found\r\n        if (!startPoly || !endPoly) return null;\r\n        \r\n        // Search!\r\n        const astarPath = jsastar.astar.search(this.graph, startPoly, endPoly, {\r\n            heuristic: this.graph.navHeuristic\r\n        });\r\n        // jsastar drops the first point from the path, but the funnel algorithm needs it\r\n        astarPath.unshift(startPoly);\r\n        \r\n        // We have a path, so now time for the funnel algorithm\r\n        const channel = new Channel();\r\n        channel.push(startPoint);\r\n        for (let i = 0; i < astarPath.length - 1; i++) {\r\n            const navPolygon = astarPath[i];\r\n            const nextNavPolygon = astarPath[i + 1];\r\n\r\n            // Find the portal\r\n            let portal = null;\r\n            for (let i = 0; i < navPolygon.neighbors.length; i++) {\r\n                if (navPolygon.neighbors[i].id === nextNavPolygon.id) {\r\n                    portal = navPolygon.portals[i];\r\n                }\r\n            }\r\n\r\n            // Push the portal vertices into the channel\r\n            channel.push(portal.start, portal.end);\r\n        }\r\n        channel.push(endPoint);\r\n\r\n        // Pull a string along the channel to run the funnel\r\n        channel.stringPull();\r\n\r\n        // Clone path, excluding duplicates\r\n        let lastPoint = null;\r\n        const phaserPath = [];\r\n        for (const p of channel.path) {\r\n            const newPoint = p.clone();\r\n            if (!lastPoint || !newPoint.equals(lastPoint)) phaserPath.push(newPoint);\r\n            lastPoint = newPoint;\r\n        }\r\n\r\n        // Call debug drawing\r\n        if (drawFinalPath || drawPolyPath) {\r\n            this.debugDraw(\r\n                drawPolyPath ? astarPath : null,\r\n                drawFinalPath ? phaserPath : null \r\n            );\r\n        }\r\n\r\n        return phaserPath;\r\n    }\r\n\r\n    _calculateNeighbors() {\r\n        // Fill out the neighbor information for each navpoly\r\n        for (let i = 0; i < this._navPolygons.length; i++) {\r\n            const navPoly = this._navPolygons[i];\r\n\r\n            for (let j = i + 1; j < this._navPolygons.length; j++) {\r\n                const otherNavPoly = this._navPolygons[j];\r\n\r\n                // Check if the other navpoly is within range to touch\r\n                const d = navPoly.centroid.distance(otherNavPoly.centroid);\r\n                if (d > (navPoly.boundingRadius + otherNavPoly.boundingRadius)) continue;\r\n\r\n                // The are in range, so check each edge pairing\r\n                for (const edge of navPoly.edges) {\r\n                    for (const otherEdge of otherNavPoly.edges) {\r\n                        \r\n                        // If edges aren't collinear, not an option for connecting navpolys\r\n                        if (!areCollinear(edge, otherEdge)) continue;\r\n\r\n                        // If they are collinear, check if they overlap\r\n                        const overlap = this._getSegmentOverlap(edge, otherEdge);\r\n                        if (!overlap) continue;\r\n                        \r\n                        // Connections are symmetric!\r\n                        navPoly.neighbors.push(otherNavPoly);\r\n                        otherNavPoly.neighbors.push(navPoly);\r\n\r\n                        // Calculate the portal between the two polygons - this needs to be in\r\n                        // counter-clockwise order, relative to each polygon\r\n                        const [p1, p2] = overlap;\r\n                        let edgeStartAngle = navPoly.centroid.angle(edge.start);\r\n                        let a1 = navPoly.centroid.angle(overlap[0]);\r\n                        let a2 = navPoly.centroid.angle(overlap[1]);\r\n                        let d1 = angleDifference(edgeStartAngle, a1);\r\n                        let d2 = angleDifference(edgeStartAngle, a2);\r\n                        if (d1 < d2) {\r\n                            navPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n                        } else {\r\n                            navPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\r\n                        }\r\n\r\n                        edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);\r\n                        a1 = otherNavPoly.centroid.angle(overlap[0]);\r\n                        a2 = otherNavPoly.centroid.angle(overlap[1]);\r\n                        d1 = angleDifference(edgeStartAngle, a1);\r\n                        d2 = angleDifference(edgeStartAngle, a2);\r\n                        if (d1 < d2) {\r\n                            otherNavPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n                        } else {\r\n                            otherNavPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\r\n                        }\r\n                            \r\n                        // Two convex polygons shouldn't be connected more than once! (Unless\r\n                        // there are unnecessary vertices...)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check two collinear line segments to see if they overlap by sorting the points.\r\n    // Algorithm source: http://stackoverflow.com/a/17152247\r\n    _getSegmentOverlap(line1, line2) {\r\n        const points = [\r\n            {line: line1, point: line1.start}, \r\n            {line: line1, point: line1.end}, \r\n            {line: line2, point: line2.start}, \r\n            {line: line2, point: line2.end}\r\n        ]; \r\n        points.sort(function (a, b) {\r\n            if (a.point.x < b.point.x) return -1;\r\n            else if (a.point.x > b.point.x) return 1;\r\n            else {\r\n                if (a.point.y < b.point.y) return -1;\r\n                else if (a.point.y > b.point.y) return 1;\r\n                else return 0;\r\n            }\r\n        });\r\n        // If the first two points in the array come from the same line, no overlap\r\n        const noOverlap = points[0].line === points[1].line;\r\n        // If the two middle points in the array are the same coordinates, then there is a \r\n        // single point of overlap.\r\n        const singlePointOverlap = points[1].point.equals(points[2].point);\r\n        if (noOverlap || singlePointOverlap) return null;\r\n        else return [points[1].point, points[2].point];\r\n    }\r\n\r\n    /**\r\n     * Project a point onto a polygon in the shortest distance possible.\r\n     * \r\n     * @param {Phaser.Point} point The point to project\r\n     * @param {NavPoly} navPoly The navigation polygon to test against\r\n     * @returns {{point: Phaser.Point, distance: number}}\r\n     * \r\n     * @memberof NavMesh\r\n     */\r\n    _projectPointToPolygon(point, navPoly) {\r\n        let closestProjection = null;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        for (const edge of navPoly.edges) {\r\n            const projectedPoint = this._projectPointToEdge(point, edge);\r\n            const d = point.distance(projectedPoint);\r\n            if (closestProjection === null || d < closestDistance) {\r\n                closestDistance = d;\r\n                closestProjection = projectedPoint;\r\n            }\r\n        }\r\n        return {point: closestProjection, distance: closestDistance};\r\n    }\r\n\r\n    _distanceSquared(a, b) {\r\n        const dx = b.x - a.x;\r\n        const dy = b.y - a.y;\r\n        return dx * dx + dy * dy;\r\n    }\r\n\r\n    // Project a point onto a line segment\r\n    // JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\r\n    _projectPointToEdge(point, line) {\r\n        const a = line.start;\r\n        const b = line.end;\r\n        // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find\r\n        // where our point lies on the line by solving for t:\r\n        //  t = [(p-a) . (b-a)] / |b-a|^2\r\n        const l2 = this._distanceSquared(a, b);\r\n        let t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;\r\n        // We clamp t from [0,1] to handle points outside the segment vw.\r\n        t = Phaser.Math.clamp(t, 0, 1);\r\n        // Project onto the segment\r\n        const p = new Phaser.Point(\r\n            a.x + t * (b.x - a.x),\r\n            a.y + t * (b.y - a.y)\r\n        );\r\n        return p;        \r\n    }\r\n\r\n    enableDebug() {\r\n        this._debugGraphics = this.game.add.graphics(0, 0);\r\n        this._debugGraphics.alpha = 0.5;\r\n    }\r\n\r\n    disableDebug() {\r\n        if (this._debugGraphics) {\r\n            this._debugGraphics.destroy();\r\n            this._debugGraphics = null;\r\n        }\r\n    }\r\n\r\n    isDebugEnabled() {\r\n        return this._debugGraphics !== null;\r\n    }\r\n\r\n    debugClear() {\r\n        if (this._debugGraphics) this._debugGraphics.clear();\r\n    }\r\n    \r\n    /**\r\n     * Visualize the polygons in the nav mesh as an overlay on top of the game\r\n     *\r\n     * @param {object} options\r\n     * @param {boolean} [options.drawCentroid=true] For each polygon, show the approx centroid\r\n     * @param {boolean} [options.drawBounds=false] For each polygon, show the bounding radius\r\n     * @param {boolean} [options.drawNeighbors=true] For each polygon, show the connections to\r\n     * neighbors\r\n     * @param {boolean} [options.drawPortals=true] For each polygon, show the portal edges\r\n     *\r\n     * @memberof NavMesh\r\n     */\r\n    debugDrawMesh({drawCentroid = true, drawBounds = false, drawNeighbors = true, \r\n            drawPortals = true} = {}) {\r\n        if (!this._debugGraphics) this.enableDebug();\r\n        this._debugGraphics.clear();\r\n        // Visualize the navigation mesh\r\n        for (const navPoly of this._navPolygons) {\r\n            navPoly.draw(this._debugGraphics, drawCentroid, drawBounds, drawNeighbors, drawPortals);\r\n        }\r\n    }\r\n\r\n    debugDraw(polyPath = null, funnelPath = null) {\r\n        if (!this._debugGraphics) this.enableDebug();\r\n\r\n        // Draw astar path through the polygons\r\n        if (polyPath) {\r\n            this._debugGraphics.lineStyle(10, 0x00FF00);\r\n            this._debugGraphics.moveTo(polyPath[0].centroid.x, polyPath[0].centroid.y);\r\n            for (const navPoly of polyPath) {\r\n                this._debugGraphics.lineTo(navPoly.centroid.x, navPoly.centroid.y);\r\n            }\r\n            const lastPoly = polyPath[polyPath.length - 1];\r\n            this._debugGraphics.lineTo(lastPoly.centroid.x, lastPoly.centroid.y);\r\n        }\r\n\r\n        // Draw the funneled path\r\n        if (funnelPath) {\r\n            this._debugGraphics.lineStyle(5, 0xffd900);\r\n            const p = new Phaser.Polygon(...funnelPath);\r\n            p.closed = false;\r\n            this._debugGraphics.drawShape(p); \r\n            this._debugGraphics.beginFill(0xffd900);\r\n            this._debugGraphics.drawEllipse(funnelPath[0].x, funnelPath[0].y, 10, 10);\r\n            const lastPoint = funnelPath[funnelPath.length - 1];\r\n            this._debugGraphics.drawEllipse(lastPoint.x, lastPoint.y, 10, 10);\r\n            this._debugGraphics.endFill();\r\n        }\r\n    }\r\n}\r\n\r\nexport default NavMesh;\n\n\n// WEBPACK FOOTER //\n// ./nav-mesh.js","// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete\r\n// funnel algorithm so astar checks can be more accurate.\r\n\r\nimport {triarea2} from \"./utils\";\r\n\r\nclass Channel {\r\n    constructor() {\r\n        this.portals = [];\r\n    }\r\n\r\n    /**\r\n     * @param {Phaser.Point} p1 \r\n     * @param {Phaser.Point} p2 \r\n     * \r\n     * @memberof Channel\r\n     */\r\n    push(p1, p2 = null) {\r\n        if (p2 === null) p2 = p1;\r\n        this.portals.push({\r\n            left: p1, \r\n            right: p2\r\n        });\r\n    }\r\n\r\n    stringPull() {\r\n        var portals = this.portals;\r\n        var pts = [];\r\n        // Init scan state\r\n        var portalApex, portalLeft, portalRight;\r\n        var apexIndex = 0,\r\n            leftIndex = 0,\r\n            rightIndex = 0;\r\n\r\n        portalApex = portals[0].left;\r\n        portalLeft = portals[0].left;\r\n        portalRight = portals[0].right;\r\n\r\n        // Add start point.\r\n        pts.push(portalApex);\r\n\r\n        for (var i = 1; i < portals.length; i++) {\r\n            // Find the next portal vertices\r\n            var left = portals[i].left;\r\n            var right = portals[i].right;\r\n\r\n            // Update right vertex.\r\n            if (triarea2(portalApex, portalRight, right) <= 0.0) {\r\n                if (portalApex.equals(portalRight) || \r\n                        triarea2(portalApex, portalLeft, right) > 0.0) {\r\n                    // Tighten the funnel.\r\n                    portalRight = right;\r\n                    rightIndex = i;\r\n                } else {\r\n                    // Right vertex just crossed over the left vertex, so the left vertex should\r\n                    // now be part of the path.\r\n                    pts.push(portalLeft);\r\n                    \r\n                    // Restart scan from portal left point.\r\n\r\n                    // Make current left the new apex.\r\n                    portalApex = portalLeft;\r\n                    apexIndex = leftIndex;\r\n                    // Reset portal\r\n                    portalLeft = portalApex;\r\n                    portalRight = portalApex;\r\n                    leftIndex = apexIndex;\r\n                    rightIndex = apexIndex;\r\n                    // Restart scan\r\n                    i = apexIndex;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // Update left vertex.\r\n            if (triarea2(portalApex, portalLeft, left) >= 0.0) {\r\n                if (portalApex.equals(portalLeft) || \r\n                        triarea2(portalApex, portalRight, left) < 0.0) {\r\n                    // Tighten the funnel.\r\n                    portalLeft = left;\r\n                    leftIndex = i;\r\n                } else {\r\n                    // Left vertex just crossed over the right vertex, so the right vertex should\r\n                    // now be part of the path\r\n                    pts.push(portalRight);\r\n                    \r\n                    // Restart scan from portal right point.\r\n\r\n                    // Make current right the new apex.\r\n                    portalApex = portalRight;\r\n                    apexIndex = rightIndex;\r\n                    // Reset portal\r\n                    portalLeft = portalApex;\r\n                    portalRight = portalApex;\r\n                    leftIndex = apexIndex;\r\n                    rightIndex = apexIndex;\r\n                    // Restart scan\r\n                    i = apexIndex;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        if ((pts.length === 0) || (!pts[pts.length - 1].equals(portals[portals.length - 1].left))) {\r\n            // Append last point to path.\r\n            pts.push(portals[portals.length - 1].left);\r\n        }\r\n\r\n        this.path = pts;\r\n        return pts;\r\n    }\r\n}\r\n\r\nexport default Channel;\n\n\n// WEBPACK FOOTER //\n// ./channel.js","// const triangulate = require(\"./triangulate\");\r\nimport NavMesh from \"./nav-mesh\";\r\n\r\n/**\r\n * This plugin can create and manage a set of navmeshes for a game. Each is stored in the plugin\r\n * under a user-supplied key. The navmeshes can either be constructed algorithmically from convex\r\n * polygons that describe the obstacles in the map or from convex polygons embedded in a Tiled map.\r\n *\r\n * @class NavMeshPlugin\r\n * @extends {Phaser.Plugin}\r\n */\r\nclass NavMeshPlugin extends Phaser.Plugin {\r\n    /**\r\n     * Creates an instance of NavMeshPlugin.\r\n     * \r\n     * @param {Phaser.Game} game \r\n     * @param {Phaser.PluginManager} manager \r\n     * \r\n     * @memberOf NavMeshPlugin\r\n     */\r\n    constructor(game, manager) {\r\n        super(game, manager);\r\n        this.game = game;\r\n        this._pluginManager = manager;\r\n        this._navmeshes = {};\r\n        this._currentLevel = null;\r\n    }\r\n\r\n    /**\r\n     * Load a navmesh from Tiled and switch it to be the current navmesh. Currently assumes that the\r\n     * polygons are squares!\r\n     * \r\n     * @param {string} levelName The key to use to store the navmesh in the plugin \r\n     * @param {Phaser.Tilemap} tilemap The tilemap that contains polygons under an object layer\r\n     * @param {string} objectKey The name of the object layer in the tilemap\r\n     * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n     * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n     * \r\n     * @memberof NavMeshPlugin\r\n     */\r\n    buildMeshFromTiled(levelName, tilemap, objectKey, meshShrinkAmount = 0) {\r\n        // Load up the object layer\r\n        const rects = tilemap.objects[objectKey];\r\n        // Loop over the objects and construct a polygon\r\n        const polygons = [];\r\n        for (const r of rects) {\r\n            const top = r.y;\r\n            const bottom = r.y + r.height;\r\n            const left = r.x;\r\n            const right = r.x + r.width;\r\n            const poly = new Phaser.Polygon(left,top, left,bottom, right,bottom, right,top);\r\n            polygons.push(poly);\r\n        }\r\n        // Build the navmesh, cache it and set it to be the current\r\n        const navMesh = new NavMesh(this.game, polygons, meshShrinkAmount);\r\n        this._navmeshes[levelName] = navMesh;\r\n        this._currentNavMesh = navMesh;\r\n        return navMesh;\r\n    }  \r\n\r\n    // /**\r\n    //  * Build a navmesh from an array of convex polygons. This currently tesselates the polygons into\r\n    //  * triangles. They aren't as efficient or as well designed as ones made by hand in Tiled. \r\n    //  *\r\n    //  * @param {string} levelName The key to use to store the navmesh in the plugin  \r\n    //  * @param {[]} hulls An array of convex polygons describing the obstacles in the\r\n    //  * level. See lighting-plugin/hull-from-tiles.\r\n    //  *\r\n    //  * @memberof NavMeshPlugin\r\n    //  */\r\n    // buildMesh(levelName, hulls) {\r\n    //     const contours = this._buildContours(hulls);\r\n    //     // Get an array of triangulated vertices\r\n    //     const triangles = triangulate(contours, false); // Counter-clockwise ordering!\r\n    //     const polygons = [];\r\n    //     for (let i = 0; i < triangles.length; i += 6) {\r\n    //         const poly = new Phaser.Polygon(\r\n    //             // These should be in counter-clockwise order from triangulate\r\n    //             triangles[i + 0], triangles[i + 1], \r\n    //             triangles[i + 2], triangles[i + 3], \r\n    //             triangles[i + 4], triangles[i + 5]\r\n    //         );\r\n    //         polygons.push(poly);\r\n    //     }\r\n    //     const navMesh = new NavMesh(this.game, polygons);\r\n    //     this._navMeshes[levelName] = navMesh;\r\n    //     this._currentNavMesh = navMesh;\r\n    // }\r\n\r\n    /**\r\n     * Switch the currently loaded navmesh\r\n     *\r\n     * @param {string} levelName Name of the level to look up in the cache of loaded levels \r\n     * \r\n     * @memberof NavMeshPlugin\r\n     */\r\n    switchLevel(levelName) {\r\n        if (this._navmeshes[levelName]) this._currentNavMesh = this._navmeshes[levelName];\r\n    }\r\n    \r\n    /**\r\n     * Find a path from the start point to the end point using the currently loaded nav mesh.\r\n     * \r\n     * @param {Phaser.Point} startPoint The starting point in world coordinates\r\n     * @param {Phaser.Point} endPoint The end point in world coordinates\r\n     * @param {boolean} [debugDraw=false] Whether or not to draw debug graphics for the path\r\n     * @returns {Phaser.Point[]|null} An array of points if a path is found, or null if no path\r\n     * \r\n     * @memberof NavMeshPlugin\r\n     */\r\n    findPath(startPoint, endPoint, debugDraw = false) {\r\n        if (!this._currentNavMesh) return null;\r\n        return this._currentNavMesh.findPath(startPoint, endPoint, debugDraw);\r\n    }\r\n\r\n    // /**\r\n    //  * @param {[]} hulls \r\n    //  * @returns \r\n    //  * \r\n    //  * @memberof NavMeshPlugin\r\n    //  */\r\n    // _buildContours(hulls) {\r\n    //     const w = this.game.width;\r\n    //     const h = this.game.height;\r\n    //     // Start the contours\r\n    //     const contours = [\r\n    //         // Full screen - counter clockwise\r\n    //         Float32Array.of(0,0, 0,h, w,h, w,0)\r\n    //     ];\r\n    //     // For each convex hull add the contour\r\n    //     for (const hull of hulls) {\r\n    //         const contour = [];\r\n    //         for (const lineInfo of hull) {\r\n    //             contour.push(lineInfo.line.start.x, lineInfo.line.start.y);\r\n    //         }\r\n    //         contours.push(Float32Array.from(contour));\r\n    //     }\r\n    //     return contours;\r\n    // }\r\n}\r\n\r\nPhaser.NavMeshPlugin = NavMeshPlugin;\r\nexport default NavMeshPlugin;\n\n\n// WEBPACK FOOTER //\n// ./index.js","import jsastar from \"javascript-astar\";\r\n\r\n/**\r\n * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar\r\n * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavGraph\r\n */\r\nclass NavGraph {\r\n    constructor(navPolygons) {\r\n        this.nodes = navPolygons;\r\n        this.init();\r\n    }\r\n\r\n    neighbors(navPolygon) {\r\n        return navPolygon.neighbors;\r\n    }\r\n\r\n    navHeuristic(navPolygon1, navPolygon2) {\r\n        return navPolygon1.centroidDistance(navPolygon2);\r\n    }\r\n}\r\n\r\nNavGraph.prototype.init = jsastar.Graph.prototype.init;\r\nNavGraph.prototype.cleanDirty = jsastar.Graph.prototype.cleanDirty;\r\nNavGraph.prototype.markDirty = jsastar.Graph.prototype.markDirty;\r\n\r\nexport default NavGraph;\n\n\n// WEBPACK FOOTER //\n// ./nav-graph.js","// Debug color palette\r\nconst palette = [0x00A0B0, 0x6A4A3C, 0xCC333F, 0xEB6841, 0xEDC951];\r\n\r\n/**\r\n * A class that represents a navigable polygon in a navmesh. It is build from a Phaser.Polygon. It\r\n * has a drawing function to help visualize it's features:\r\n *  - polygon\r\n *  - neighbors - any navpolys that can be reached from this navpoly\r\n *  - portals - overlapping edges between neighbors\r\n *  - centroid - not a true centroid, just an approximation.\r\n *  - boundingRadius - the radius of a circle at the centroid that fits all the points of the poly \r\n * \r\n * It implements the properties and fields that javascript-astar needs - weight, toString, isWall\r\n * and getCost. See GPS test from astar repo for structure: \r\n * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavPoly\r\n */\r\nclass NavPoly {\r\n    /**\r\n     * Creates an instance of NavPoly.\r\n     * @param {Phaser.Game} game \r\n     * @param {number} id \r\n     * @param {Phaser.Polygon} polygon \r\n     * \r\n     * @memberof NavPoly\r\n     */\r\n    constructor(game, id, polygon) {\r\n        this.game = game;\r\n        this.id = id;\r\n        this.polygon = polygon;\r\n        this.edges = this._calculateEdges();\r\n        this.neighbors = [];\r\n        this.portals = [];\r\n        this.centroid = this._calculateCentroid();\r\n        this.boundingRadius = this._calculateRadius();\r\n\r\n        this.weight = 1; // jsastar property\r\n        \r\n        const i = this.id % palette.length;\r\n        this._color = palette[i];\r\n    }\r\n\r\n    constains(point) {\r\n        return this.polygon.contains(point.x, point.y);\r\n    }\r\n\r\n    // jsastar methods\r\n    toString() {\r\n        return `NavPoly(id: ${this.id} at: ${this.centroid})`;\r\n    }\r\n    isWall() {\r\n        return this.weight === 0;\r\n    }\r\n    centroidDistance(navPolygon) {\r\n        return this.centroid.distance(navPolygon.centroid);\r\n    }\r\n    getCost(navPolygon) {\r\n        return this.centroidDistance(navPolygon);\r\n    }\r\n\r\n    _calculateEdges() {\r\n        const points = this.polygon.points;\r\n        const edges = [];\r\n        for (let i = 1; i < points.length; i++) {\r\n            const p1 = points[i - 1];\r\n            const p2 = points[i];\r\n            edges.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n        }\r\n        const first = points[0];\r\n        const last = points[points.length - 1]\r\n        edges.push(new Phaser.Line(first.x, first.y, last.x, last.y));\r\n        return edges;\r\n    }\r\n    \r\n    _calculateCentroid() {\r\n        // NOTE: this is not actually the centroid, it's the average of the vertices - not the same\r\n        // thing!\r\n        const centroid = new Phaser.Point(0, 0);\r\n        const length = this.polygon.points.length;\r\n        for (const point of this.polygon.points) {\r\n            centroid.add(point.x, point.y);\r\n        }\r\n        centroid.divide(length, length);\r\n        return centroid;\r\n    }\r\n\r\n    _calculateRadius() {\r\n        let boundingRadius = 0;\r\n        for (const point of this.polygon.points) {\r\n            const d = this.centroid.distance(point);\r\n            if (d > boundingRadius) boundingRadius = d;\r\n        }\r\n        return boundingRadius;\r\n    }\r\n\r\n    /**\r\n     * Draw the polygon to given graphics object\r\n     * \r\n     * @param {Phaser.Graphics} graphics \r\n     * @param {boolean} [drawCentroid=true] Show the approx centroid\r\n     * @param {boolean} [drawBounds=false] Show the bounding radius\r\n     * @param {boolean} [drawNeighbors=true] Show the connections to neighbors\r\n     * @param {boolean} [drawPortals=true] Show the portal edges\r\n     * \r\n     * @memberof NavPoly\r\n     */\r\n    draw(graphics, drawCentroid = true, drawBounds = false, drawNeighbors = true, \r\n            drawPortals = true) {\r\n        graphics.lineWidth = 0;\r\n        graphics.beginFill(this._color);\r\n        graphics.drawPolygon(this.polygon);\r\n        graphics.endFill();\r\n\r\n        if (drawCentroid) {\r\n            graphics.beginFill(0x000000);\r\n            graphics.drawEllipse(this.centroid.x, this.centroid.y, 4, 4);\r\n            graphics.endFill();\r\n        }\r\n\r\n        if (drawBounds) {\r\n            graphics.lineStyle(1, 0xFFFFFF);\r\n            const r = this.boundingRadius;\r\n            graphics.drawEllipse(this.centroid.x, this.centroid.y, r, r);\r\n        }\r\n\r\n        if (drawNeighbors) {\r\n            graphics.lineStyle(2, 0x000000);\r\n            for (const n of this.neighbors) {\r\n                graphics.moveTo(this.centroid.x, this.centroid.y);\r\n                graphics.lineTo(n.centroid.x, n.centroid.y);\r\n            }\r\n        }\r\n\r\n        if (drawPortals) {\r\n            graphics.lineStyle(10, 0x000000);\r\n            for (const p of this.portals) {\r\n                graphics.moveTo(p.start.x, p.start.y);\r\n                graphics.lineTo(p.end.x, p.end.y);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default NavPoly;\n\n\n// WEBPACK FOOTER //\n// ./nav-poly.js"],"sourceRoot":""}