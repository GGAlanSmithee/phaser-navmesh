{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///phaser-navmesh.min.js","webpack:///webpack/bootstrap 7c2d548790e295d9b34b?28fc","webpack:///./utils.js?e8fb","webpack:///E:/Github/navmesh-phaser-plugin/~/javascript-astar/astar.js?e4f8","webpack:///./nav-mesh-plugin.js?5f0d","webpack:///./channel.js?5df9","webpack:///./index.js?2645","webpack:///./nav-graph.js?63ca","webpack:///./nav-mesh.js?f576","webpack:///./nav-poly.js?b51a"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","triarea2","a","b","ax","x","ay","y","almostEqual","value1","value2","errorMargin","arguments","length","undefined","Math","abs","angleDifference","PI","j","floor","areCollinear","line1","line2","area1","start","end","area2","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","definition","apply","pathTo","node","curr","path","parent","unshift","getHeap","BinaryHeap","f","Graph","gridIn","options","nodes","diagonal","grid","row","GridNode","push","init","weight","scoreFunction","content","astar","search","graph","cleanDirty","heuristic","heuristics","manhattan","closest","openHeap","closestNode","h","markDirty","size","currentNode","pop","closed","neighbors","il","neighbor","isWall","gScore","g","getCost","beenVisited","visited","rescoreElement","pos0","pos1","D2","sqrt","d1","d2","min","cleanNode","dirtyNodes","ret","toString","graphString","rowDebug","join","fromNeighbor","element","sinkDown","result","bubbleUp","remove","indexOf","parentN","elemScore","child1Score","child2N","child1N","swap","child1","child2","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0__nav_mesh__","_createClass","defineProperties","target","props","descriptor","key","protoProps","staticProps","_get","receiver","Function","desc","getOwnPropertyDescriptor","getPrototypeOf","NavMeshPlugin","_Phaser$Plugin","game","manager","_this","_navMeshes","tilemap","objectKey","meshShrinkAmount","rects","objects","polygons","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","r","top","bottom","height","left","right","width","poly","Phaser","Polygon","err","return","mesh","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","destroy","Plugin","__WEBPACK_IMPORTED_MODULE_0__utils__","Channel","portals","p1","p2","portalApex","portalLeft","portalRight","pts","apexIndex","leftIndex","rightIndex","equals","default","__WEBPACK_IMPORTED_MODULE_0_javascript_astar__","__WEBPACK_IMPORTED_MODULE_0_javascript_astar___default","NavGraph","navPolygons","navPolygon","navPolygon1","navPolygon2","centroidDistance","_toConsumableArray","arr","Array","isArray","arr2","from","__WEBPACK_IMPORTED_MODULE_1__nav_poly__","__WEBPACK_IMPORTED_MODULE_2__nav_graph__","__WEBPACK_IMPORTED_MODULE_3__channel__","__WEBPACK_IMPORTED_MODULE_4__utils__","_slicedToArray","sliceIterator","_arr","_n","_d","_e","_s","_i","NavMesh","_debugGraphics","_meshShrinkAmount","_navPolygons","entries","_ref","_ref2","polygon","_calculateNeighbors","_graph","disableDebug","startPoint","endPoint","_ref3","_ref3$drawPolyPath","drawPolyPath","_ref3$drawFinalPath","drawFinalPath","startPoly","endPoly","startDistance","Number","MAX_VALUE","endDistance","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","navPoly","boundingRadius","centroid","distance","constains","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_projectPointToPolygo","_projectPointToPolygon","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","_projectPointToPolygo2","astarPath","navHeuristic","channel","nextNavPolygon","portal","id","stringPull","lastPoint","phaserPath","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","newPoint","clone","polyPath","map","elem","debugDrawPath","otherNavPoly","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","edges","edge","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_iterator8","otherEdge","overlap","_getSegmentOverlap","_overlap","edgeStartAngle","angle","a1","a2","Line","points","line","point","sort","noOverlap","singlePointOverlap","closestProjection","closestDistance","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_step9","_iterator9","projectedPoint","_projectPointToEdge","dx","dy","l2","_distanceSquared","t","clamp","Point","add","graphics","alpha","clear","_ref4","_ref4$drawCentroid","drawCentroid","_ref4$drawBounds","drawBounds","_ref4$drawNeighbors","drawNeighbors","_ref4$drawPortals","drawPortals","enableDebug","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_step10","_iterator10","draw","color","thickness","lineStyle","drawShape","bind","concat","beginFill","drawEllipse","endFill","palette","NavPoly","_calculateEdges","_calculateCentroid","_calculateRadius","_color","contains","first","last","divide","lineWidth","drawPolygon","moveTo","lineTo"],"mappings":"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","file":"phaser-navmesh.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserNavmesh\"] = factory();\n\telse\n\t\troot[\"PhaserNavmesh\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserNavmesh\"] = factory();\n\telse\n\t\troot[\"PhaserNavmesh\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = triarea2;\n/* unused harmony export almostEqual */\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = angleDifference;\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = areCollinear;\n/**\r\n * Twice the area of the triangle formed by a, b and c\r\n * @private\r\n */\nfunction triarea2(a, b, c) {\n    var ax = b.x - a.x;\n    var ay = b.y - a.y;\n    var bx = c.x - a.x;\n    var by = c.y - a.y;\n    return bx * ay - ax * by;\n}\n\n/**\r\n * @private\r\n */\nfunction almostEqual(value1, value2) {\n    var errorMargin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0001;\n\n    if (Math.abs(value1 - value2) <= errorMargin) return true;else return false;\n}\n\n/**\r\n * https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0\r\n * @private\r\n */\nfunction angleDifference(x, y) {\n    var a = x - y;\n    var i = a + Math.PI;\n    var j = Math.PI * 2;\n    a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign\n    a -= Math.PI;\n    return a;\n}\n\n/**\r\n * @private\r\n */\nfunction areCollinear(line1, line2) {\n    var errorMargin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0001;\n\n    // Figure out if the two lines are equal by looking at the area of the triangle formed\n    // by their points\n    var area1 = triarea2(line1.start, line1.end, line2.start);\n    var area2 = triarea2(line1.start, line1.end, line2.end);\n    if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {\n        return true;\n    } else return false;\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// javascript-astar 0.4.2\r\n// http://github.com/bgrins/javascript-astar\r\n// Freely distributable under the MIT License.\r\n// Implements the astar search algorithm in javascript using a Binary Heap.\r\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\r\n// http://eloquentjavascript.net/appendix2.html\r\n(function(definition) {\r\n  /* global module, define */\r\n  if (typeof module === 'object' && typeof module.exports === 'object') {\r\n    module.exports = definition();\r\n  } else if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n  } else {\r\n    var exports = definition();\r\n    window.astar = exports.astar;\r\n    window.Graph = exports.Graph;\r\n  }\r\n})(function() {\r\n\r\nfunction pathTo(node) {\r\n  var curr = node;\r\n  var path = [];\r\n  while (curr.parent) {\r\n    path.unshift(curr);\r\n    curr = curr.parent;\r\n  }\r\n  return path;\r\n}\r\n\r\nfunction getHeap() {\r\n  return new BinaryHeap(function(node) {\r\n    return node.f;\r\n  });\r\n}\r\n\r\nvar astar = {\r\n  /**\r\n  * Perform an A* Search on a graph given a start and end node.\r\n  * @param {Graph} graph\r\n  * @param {GridNode} start\r\n  * @param {GridNode} end\r\n  * @param {Object} [options]\r\n  * @param {bool} [options.closest] Specifies whether to return the\r\n             path to the closest node if the target is unreachable.\r\n  * @param {Function} [options.heuristic] Heuristic function (see\r\n  *          astar.heuristics).\r\n  */\r\n  search: function(graph, start, end, options) {\r\n    graph.cleanDirty();\r\n    options = options || {};\r\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\r\n    var closest = options.closest || false;\r\n\r\n    var openHeap = getHeap();\r\n    var closestNode = start; // set the start node to be the closest if required\r\n\r\n    start.h = heuristic(start, end);\r\n    graph.markDirty(start);\r\n\r\n    openHeap.push(start);\r\n\r\n    while (openHeap.size() > 0) {\r\n\r\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\r\n      var currentNode = openHeap.pop();\r\n\r\n      // End case -- result has been found, return the traced path.\r\n      if (currentNode === end) {\r\n        return pathTo(currentNode);\r\n      }\r\n\r\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\r\n      currentNode.closed = true;\r\n\r\n      // Find all neighbors for the current node.\r\n      var neighbors = graph.neighbors(currentNode);\r\n\r\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\r\n        var neighbor = neighbors[i];\r\n\r\n        if (neighbor.closed || neighbor.isWall()) {\r\n          // Not a valid node to process, skip to next neighbor.\r\n          continue;\r\n        }\r\n\r\n        // The g score is the shortest distance from start to current node.\r\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\r\n        var gScore = currentNode.g + neighbor.getCost(currentNode);\r\n        var beenVisited = neighbor.visited;\r\n\r\n        if (!beenVisited || gScore < neighbor.g) {\r\n\r\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\r\n          neighbor.visited = true;\r\n          neighbor.parent = currentNode;\r\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\r\n          neighbor.g = gScore;\r\n          neighbor.f = neighbor.g + neighbor.h;\r\n          graph.markDirty(neighbor);\r\n          if (closest) {\r\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\r\n            // a cheaper path than the current closest node then it becomes the closest node\r\n            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\r\n              closestNode = neighbor;\r\n            }\r\n          }\r\n\r\n          if (!beenVisited) {\r\n            // Pushing to heap will put it in proper place based on the 'f' value.\r\n            openHeap.push(neighbor);\r\n          } else {\r\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\r\n            openHeap.rescoreElement(neighbor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (closest) {\r\n      return pathTo(closestNode);\r\n    }\r\n\r\n    // No result was found - empty array signifies failure to find path.\r\n    return [];\r\n  },\r\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\r\n  heuristics: {\r\n    manhattan: function(pos0, pos1) {\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return d1 + d2;\r\n    },\r\n    diagonal: function(pos0, pos1) {\r\n      var D = 1;\r\n      var D2 = Math.sqrt(2);\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\r\n    }\r\n  },\r\n  cleanNode: function(node) {\r\n    node.f = 0;\r\n    node.g = 0;\r\n    node.h = 0;\r\n    node.visited = false;\r\n    node.closed = false;\r\n    node.parent = null;\r\n  }\r\n};\r\n\r\n/**\r\n * A graph memory structure\r\n * @param {Array} gridIn 2D array of input weights\r\n * @param {Object} [options]\r\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\r\n */\r\nfunction Graph(gridIn, options) {\r\n  options = options || {};\r\n  this.nodes = [];\r\n  this.diagonal = !!options.diagonal;\r\n  this.grid = [];\r\n  for (var x = 0; x < gridIn.length; x++) {\r\n    this.grid[x] = [];\r\n\r\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\r\n      var node = new GridNode(x, y, row[y]);\r\n      this.grid[x][y] = node;\r\n      this.nodes.push(node);\r\n    }\r\n  }\r\n  this.init();\r\n}\r\n\r\nGraph.prototype.init = function() {\r\n  this.dirtyNodes = [];\r\n  for (var i = 0; i < this.nodes.length; i++) {\r\n    astar.cleanNode(this.nodes[i]);\r\n  }\r\n};\r\n\r\nGraph.prototype.cleanDirty = function() {\r\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\r\n    astar.cleanNode(this.dirtyNodes[i]);\r\n  }\r\n  this.dirtyNodes = [];\r\n};\r\n\r\nGraph.prototype.markDirty = function(node) {\r\n  this.dirtyNodes.push(node);\r\n};\r\n\r\nGraph.prototype.neighbors = function(node) {\r\n  var ret = [];\r\n  var x = node.x;\r\n  var y = node.y;\r\n  var grid = this.grid;\r\n\r\n  // West\r\n  if (grid[x - 1] && grid[x - 1][y]) {\r\n    ret.push(grid[x - 1][y]);\r\n  }\r\n\r\n  // East\r\n  if (grid[x + 1] && grid[x + 1][y]) {\r\n    ret.push(grid[x + 1][y]);\r\n  }\r\n\r\n  // South\r\n  if (grid[x] && grid[x][y - 1]) {\r\n    ret.push(grid[x][y - 1]);\r\n  }\r\n\r\n  // North\r\n  if (grid[x] && grid[x][y + 1]) {\r\n    ret.push(grid[x][y + 1]);\r\n  }\r\n\r\n  if (this.diagonal) {\r\n    // Southwest\r\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\r\n      ret.push(grid[x - 1][y - 1]);\r\n    }\r\n\r\n    // Southeast\r\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\r\n      ret.push(grid[x + 1][y - 1]);\r\n    }\r\n\r\n    // Northwest\r\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\r\n      ret.push(grid[x - 1][y + 1]);\r\n    }\r\n\r\n    // Northeast\r\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\r\n      ret.push(grid[x + 1][y + 1]);\r\n    }\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nGraph.prototype.toString = function() {\r\n  var graphString = [];\r\n  var nodes = this.grid;\r\n  for (var x = 0; x < nodes.length; x++) {\r\n    var rowDebug = [];\r\n    var row = nodes[x];\r\n    for (var y = 0; y < row.length; y++) {\r\n      rowDebug.push(row[y].weight);\r\n    }\r\n    graphString.push(rowDebug.join(\" \"));\r\n  }\r\n  return graphString.join(\"\\n\");\r\n};\r\n\r\nfunction GridNode(x, y, weight) {\r\n  this.x = x;\r\n  this.y = y;\r\n  this.weight = weight;\r\n}\r\n\r\nGridNode.prototype.toString = function() {\r\n  return \"[\" + this.x + \" \" + this.y + \"]\";\r\n};\r\n\r\nGridNode.prototype.getCost = function(fromNeighbor) {\r\n  // Take diagonal weight into consideration.\r\n  if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\r\n    return this.weight * 1.41421;\r\n  }\r\n  return this.weight;\r\n};\r\n\r\nGridNode.prototype.isWall = function() {\r\n  return this.weight === 0;\r\n};\r\n\r\nfunction BinaryHeap(scoreFunction) {\r\n  this.content = [];\r\n  this.scoreFunction = scoreFunction;\r\n}\r\n\r\nBinaryHeap.prototype = {\r\n  push: function(element) {\r\n    // Add the new element to the end of the array.\r\n    this.content.push(element);\r\n\r\n    // Allow it to sink down.\r\n    this.sinkDown(this.content.length - 1);\r\n  },\r\n  pop: function() {\r\n    // Store the first element so we can return it later.\r\n    var result = this.content[0];\r\n    // Get the element at the end of the array.\r\n    var end = this.content.pop();\r\n    // If there are any elements left, put the end element at the\r\n    // start, and let it bubble up.\r\n    if (this.content.length > 0) {\r\n      this.content[0] = end;\r\n      this.bubbleUp(0);\r\n    }\r\n    return result;\r\n  },\r\n  remove: function(node) {\r\n    var i = this.content.indexOf(node);\r\n\r\n    // When it is found, the process seen in 'pop' is repeated\r\n    // to fill up the hole.\r\n    var end = this.content.pop();\r\n\r\n    if (i !== this.content.length - 1) {\r\n      this.content[i] = end;\r\n\r\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n        this.sinkDown(i);\r\n      } else {\r\n        this.bubbleUp(i);\r\n      }\r\n    }\r\n  },\r\n  size: function() {\r\n    return this.content.length;\r\n  },\r\n  rescoreElement: function(node) {\r\n    this.sinkDown(this.content.indexOf(node));\r\n  },\r\n  sinkDown: function(n) {\r\n    // Fetch the element that has to be sunk.\r\n    var element = this.content[n];\r\n\r\n    // When at 0, an element can not sink any further.\r\n    while (n > 0) {\r\n\r\n      // Compute the parent element's index, and fetch it.\r\n      var parentN = ((n + 1) >> 1) - 1;\r\n      var parent = this.content[parentN];\r\n      // Swap the elements if the parent is greater.\r\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n        this.content[parentN] = element;\r\n        this.content[n] = parent;\r\n        // Update 'n' to continue at the new position.\r\n        n = parentN;\r\n      }\r\n      // Found a parent that is less, no need to sink any further.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  },\r\n  bubbleUp: function(n) {\r\n    // Look up the target element and its score.\r\n    var length = this.content.length;\r\n    var element = this.content[n];\r\n    var elemScore = this.scoreFunction(element);\r\n\r\n    while (true) {\r\n      // Compute the indices of the child elements.\r\n      var child2N = (n + 1) << 1;\r\n      var child1N = child2N - 1;\r\n      // This is used to store the new position of the element, if any.\r\n      var swap = null;\r\n      var child1Score;\r\n      // If the first child exists (is inside the array)...\r\n      if (child1N < length) {\r\n        // Look it up and compute its score.\r\n        var child1 = this.content[child1N];\r\n        child1Score = this.scoreFunction(child1);\r\n\r\n        // If the score is less than our element's, we need to swap.\r\n        if (child1Score < elemScore) {\r\n          swap = child1N;\r\n        }\r\n      }\r\n\r\n      // Do the same checks for the other child.\r\n      if (child2N < length) {\r\n        var child2 = this.content[child2N];\r\n        var child2Score = this.scoreFunction(child2);\r\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\r\n          swap = child2N;\r\n        }\r\n      }\r\n\r\n      // If the element needs to be moved, swap it, and continue.\r\n      if (swap !== null) {\r\n        this.content[n] = this.content[swap];\r\n        this.content[swap] = element;\r\n        n = swap;\r\n      }\r\n      // Otherwise, we are done.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nreturn {\r\n  astar: astar,\r\n  Graph: Graph\r\n};\r\n\r\n});\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__nav_mesh__ = __webpack_require__(6);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// const triangulate = require(\"./triangulate\");\n\n\n/**\r\n * This plugin can create navigation meshes for use in Phaser. The navmeshes can be constructed from\r\n * convex polygons embedded in a Tiled map. Instantiate this using game.plugins.add(NavMeshPlugin).\r\n *\r\n * @param {Phaser.Game} game\r\n * @param {Phaser.PluginManager} manager\r\n */\n\nvar NavMeshPlugin = function (_Phaser$Plugin) {\n    _inherits(NavMeshPlugin, _Phaser$Plugin);\n\n    function NavMeshPlugin(game, manager) {\n        _classCallCheck(this, NavMeshPlugin);\n\n        var _this = _possibleConstructorReturn(this, (NavMeshPlugin.__proto__ || Object.getPrototypeOf(NavMeshPlugin)).call(this, game, manager));\n\n        _this._navMeshes = [];\n        return _this;\n    }\n\n    /**\r\n     * Load a navmesh from Tiled and switch it to be the current navmesh. Currently assumes that the\r\n     * polygons are squares!\r\n     * \r\n     * @param {Phaser.Tilemap} tilemap The tilemap that contains polygons under an object layer\r\n     * @param {string} objectKey The name of the object layer in the tilemap\r\n     * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n     * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n     * \r\n     * @memberof NavMeshPlugin\r\n     */\n\n\n    _createClass(NavMeshPlugin, [{\n        key: \"buildMeshFromTiled\",\n        value: function buildMeshFromTiled(tilemap, objectKey) {\n            var meshShrinkAmount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n            // Load up the object layer\n            var rects = tilemap.objects[objectKey] || [];\n            // Loop over the objects and construct a polygon\n            var polygons = [];\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = rects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var r = _step.value;\n\n                    var top = r.y;\n                    var bottom = r.y + r.height;\n                    var left = r.x;\n                    var right = r.x + r.width;\n                    var poly = new Phaser.Polygon(left, top, left, bottom, right, bottom, right, top);\n                    polygons.push(poly);\n                }\n                // Build the navmesh\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            var mesh = new __WEBPACK_IMPORTED_MODULE_0__nav_mesh__[\"a\" /* default */](this.game, polygons, meshShrinkAmount);\n            this._navMeshes.push(mesh);\n            return mesh;\n        }\n    }, {\n        key: \"destroy\",\n        value: function destroy() {\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this._navMeshes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var mesh = _step2.value;\n                    mesh.destroy();\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            this._navMeshes = [];\n            _get(NavMeshPlugin.prototype.__proto__ || Object.getPrototypeOf(NavMeshPlugin.prototype), \"destroy\", this).call(this);\n        }\n\n        // /**\n        //  * Build a navmesh from an array of convex polygons. This currently tesselates the polygons into\n        //  * triangles. They aren't as efficient or as well designed as ones made by hand in Tiled. \n        //  *\n        //  * @param {string} levelName The key to use to store the navmesh in the plugin  \n        //  * @param {[]} hulls An array of convex polygons describing the obstacles in the\n        //  * level. See lighting-plugin/hull-from-tiles.\n        //  *\n        //  * @memberof NavMeshPlugin\n        //  */\n        // buildMesh(levelName, hulls) {\n        //     const contours = this._buildContours(hulls);\n        //     // Get an array of triangulated vertices\n        //     const triangles = triangulate(contours, false); // Counter-clockwise ordering!\n        //     const polygons = [];\n        //     for (let i = 0; i < triangles.length; i += 6) {\n        //         const poly = new Phaser.Polygon(\n        //             // These should be in counter-clockwise order from triangulate\n        //             triangles[i + 0], triangles[i + 1], \n        //             triangles[i + 2], triangles[i + 3], \n        //             triangles[i + 4], triangles[i + 5]\n        //         );\n        //         polygons.push(poly);\n        //     }\n        //     const navMesh = new NavMesh(this.game, polygons);\n        //     this._navMeshes[levelName] = navMesh;\n        //     this._currentNavMesh = navMesh;\n        // }\n\n        // /**\n        //  * @param {[]} hulls \n        //  * @returns \n        //  * \n        //  * @memberof NavMeshPlugin\n        //  */\n        // _buildContours(hulls) {\n        //     const w = this.game.width;\n        //     const h = this.game.height;\n        //     // Start the contours\n        //     const contours = [\n        //         // Full screen - counter clockwise\n        //         Float32Array.of(0,0, 0,h, w,h, w,0)\n        //     ];\n        //     // For each convex hull add the contour\n        //     for (const hull of hulls) {\n        //         const contour = [];\n        //         for (const lineInfo of hull) {\n        //             contour.push(lineInfo.line.start.x, lineInfo.line.start.y);\n        //         }\n        //         contours.push(Float32Array.from(contour));\n        //     }\n        //     return contours;\n        // }\n\n    }]);\n\n    return NavMeshPlugin;\n}(Phaser.Plugin);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (NavMeshPlugin);\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete\n// funnel algorithm so astar checks can be more accurate.\n\n\n\n/**\r\n * @private\r\n */\n\nvar Channel = function () {\n    function Channel() {\n        _classCallCheck(this, Channel);\n\n        this.portals = [];\n    }\n\n    /**\r\n     * @param {Phaser.Point} p1 \r\n     * @param {Phaser.Point} p2 \r\n     * \r\n     * @memberof Channel\r\n     */\n\n\n    _createClass(Channel, [{\n        key: \"push\",\n        value: function push(p1) {\n            var p2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            if (p2 === null) p2 = p1;\n            this.portals.push({\n                left: p1,\n                right: p2\n            });\n        }\n    }, {\n        key: \"stringPull\",\n        value: function stringPull() {\n            var portals = this.portals;\n            var pts = [];\n            // Init scan state\n            var portalApex, portalLeft, portalRight;\n            var apexIndex = 0,\n                leftIndex = 0,\n                rightIndex = 0;\n\n            portalApex = portals[0].left;\n            portalLeft = portals[0].left;\n            portalRight = portals[0].right;\n\n            // Add start point.\n            pts.push(portalApex);\n\n            for (var i = 1; i < portals.length; i++) {\n                // Find the next portal vertices\n                var left = portals[i].left;\n                var right = portals[i].right;\n\n                // Update right vertex.\n                if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__[\"c\" /* triarea2 */])(portalApex, portalRight, right) <= 0.0) {\n                    if (portalApex.equals(portalRight) || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__[\"c\" /* triarea2 */])(portalApex, portalLeft, right) > 0.0) {\n                        // Tighten the funnel.\n                        portalRight = right;\n                        rightIndex = i;\n                    } else {\n                        // Right vertex just crossed over the left vertex, so the left vertex should\n                        // now be part of the path.\n                        pts.push(portalLeft);\n\n                        // Restart scan from portal left point.\n\n                        // Make current left the new apex.\n                        portalApex = portalLeft;\n                        apexIndex = leftIndex;\n                        // Reset portal\n                        portalLeft = portalApex;\n                        portalRight = portalApex;\n                        leftIndex = apexIndex;\n                        rightIndex = apexIndex;\n                        // Restart scan\n                        i = apexIndex;\n                        continue;\n                    }\n                }\n\n                // Update left vertex.\n                if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__[\"c\" /* triarea2 */])(portalApex, portalLeft, left) >= 0.0) {\n                    if (portalApex.equals(portalLeft) || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__[\"c\" /* triarea2 */])(portalApex, portalRight, left) < 0.0) {\n                        // Tighten the funnel.\n                        portalLeft = left;\n                        leftIndex = i;\n                    } else {\n                        // Left vertex just crossed over the right vertex, so the right vertex should\n                        // now be part of the path\n                        pts.push(portalRight);\n\n                        // Restart scan from portal right point.\n\n                        // Make current right the new apex.\n                        portalApex = portalRight;\n                        apexIndex = rightIndex;\n                        // Reset portal\n                        portalLeft = portalApex;\n                        portalRight = portalApex;\n                        leftIndex = apexIndex;\n                        rightIndex = apexIndex;\n                        // Restart scan\n                        i = apexIndex;\n                        continue;\n                    }\n                }\n            }\n\n            if (pts.length === 0 || !pts[pts.length - 1].equals(portals[portals.length - 1].left)) {\n                // Append last point to path.\n                pts.push(portals[portals.length - 1].left);\n            }\n\n            this.path = pts;\n            return pts;\n        }\n    }]);\n\n    return Channel;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Channel);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Fix for webpack not exporting ES6 module default properly when using global mode of UMD. It ends\n// up with someone having to do \"PhaserNavmesh.default\" instead of \"PhaserNavmesh\"\nmodule.exports = __webpack_require__(2).default;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_javascript_astar__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_javascript_astar__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n/**\r\n * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar\r\n * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavGraph \r\n * @private\r\n */\n\nvar NavGraph = function () {\n    function NavGraph(navPolygons) {\n        _classCallCheck(this, NavGraph);\n\n        this.nodes = navPolygons;\n        this.init();\n    }\n\n    _createClass(NavGraph, [{\n        key: \"neighbors\",\n        value: function neighbors(navPolygon) {\n            return navPolygon.neighbors;\n        }\n    }, {\n        key: \"navHeuristic\",\n        value: function navHeuristic(navPolygon1, navPolygon2) {\n            return navPolygon1.centroidDistance(navPolygon2);\n        }\n    }, {\n        key: \"destroy\",\n        value: function destroy() {\n            this.cleanDirty();\n            this.nodes = [];\n        }\n    }]);\n\n    return NavGraph;\n}();\n\nNavGraph.prototype.init = __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default.a.Graph.prototype.init;\nNavGraph.prototype.cleanDirty = __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default.a.Graph.prototype.cleanDirty;\nNavGraph.prototype.markDirty = __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default.a.Graph.prototype.markDirty;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (NavGraph);\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_javascript_astar__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_javascript_astar__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__nav_poly__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__nav_graph__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__channel__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils__ = __webpack_require__(0);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\n\n\n/**\r\n * The workhorse that represents a navigation mesh built from a series of polygons. Once built, the\r\n * mesh can be asked for a path from one point to another point. It has debug methods for \r\n * visualizing paths and visualizing the individual polygons. Some internal terminology usage:\r\n * \r\n * - neighbor: a polygon that shares part of an edge with another polygon\r\n * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment\r\n * - channel: the path of polygons from starting point to end point\r\n * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the\r\n *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut.\r\n */\n\nvar NavMesh = function () {\n    /**\r\n     * Creates an instance of NavMesh.\r\n     * \r\n     * @param {Phaser.Game} game\r\n     * @param {Phaser.Polygon[]} polygons\r\n     * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n     * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n     */\n    function NavMesh(game, polygons) {\n        var meshShrinkAmount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n        _classCallCheck(this, NavMesh);\n\n        this.game = game;\n        this._debugGraphics = null;\n        this._meshShrinkAmount = meshShrinkAmount;\n\n        // Construct NavPoly instances for each polygon\n        this._navPolygons = [];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = polygons.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var _ref = _step.value;\n\n                var _ref2 = _slicedToArray(_ref, 2);\n\n                var i = _ref2[0];\n                var polygon = _ref2[1];\n\n                this._navPolygons.push(new __WEBPACK_IMPORTED_MODULE_1__nav_poly__[\"a\" /* default */](game, i, polygon));\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        this._calculateNeighbors();\n\n        // Astar graph of connections between polygons\n        this._graph = new __WEBPACK_IMPORTED_MODULE_2__nav_graph__[\"a\" /* default */](this._navPolygons);\n    }\n\n    /**\r\n     * Cleanup method to remove references so that navmeshes don't hang around from state to state.\r\n     * You don't have to invoke this directly. If you call destroy on the plugin, it will destroy\r\n     * all navmeshes that have been created. \r\n     * \r\n     * @memberof NavMesh\r\n     */\n\n\n    _createClass(NavMesh, [{\n        key: \"destroy\",\n        value: function destroy() {\n            this._graph.destroy();\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this._navPolygons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var poly = _step2.value;\n                    poly.destroy();\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            this._navPolygons = [];\n            this.game = null;\n            this.disableDebug();\n        }\n\n        /**\r\n         * Find a path from the start point to the end point using this nav mesh.\r\n         *\r\n         * @param {Phaser.Point} startPoint\r\n         * @param {Phaser.Point} endPoint\r\n         * @param {object} [drawOptions={}] Options for controlling debug drawing\r\n         * @param {boolean} [drawOptions.drawPolyPath=false] Whether or not to visualize the path\r\n         * through the polygons - e.g. the path that astar found.\r\n         * @param {boolean} [drawOptions.drawFinalPath=false] Whether or not to visualize the path\r\n         * through the path that was returned.\r\n         * @returns {Phaser.Point[]|null} An array of points if a path is found, or null if no path\r\n         *\r\n         * @memberof NavMesh\r\n         */\n\n    }, {\n        key: \"findPath\",\n        value: function findPath(startPoint, endPoint) {\n            var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n                _ref3$drawPolyPath = _ref3.drawPolyPath,\n                drawPolyPath = _ref3$drawPolyPath === undefined ? false : _ref3$drawPolyPath,\n                _ref3$drawFinalPath = _ref3.drawFinalPath,\n                drawFinalPath = _ref3$drawFinalPath === undefined ? false : _ref3$drawFinalPath;\n\n            var startPoly = null;\n            var endPoly = null;\n            var startDistance = Number.MAX_VALUE;\n            var endDistance = Number.MAX_VALUE;\n            var d = void 0,\n                r = void 0;\n\n            // Find the closest poly for the starting and ending point\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = this._navPolygons[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var navPoly = _step3.value;\n\n                    r = navPoly.boundingRadius;\n                    // Start\n                    d = navPoly.centroid.distance(startPoint);\n                    if (d <= startDistance && d <= r && navPoly.constains(startPoint)) {\n                        startPoly = navPoly;\n                        startDistance = d;\n                    }\n                    // End\n                    d = navPoly.centroid.distance(endPoint);\n                    if (d <= endDistance && d <= r && navPoly.constains(endPoint)) {\n                        endPoly = navPoly;\n                        endDistance = d;\n                    }\n                }\n\n                // If the start point wasn't inside a polygon, run a more liberal check that allows a point\n                // to be within meshShrinkAmount radius of a polygon\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n\n            if (!startPoly && this._meshShrinkAmount > 0) {\n                var _iteratorNormalCompletion4 = true;\n                var _didIteratorError4 = false;\n                var _iteratorError4 = undefined;\n\n                try {\n                    for (var _iterator4 = this._navPolygons[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                        var _navPoly = _step4.value;\n\n                        // Check if point is within bounding circle to avoid extra projection calculations\n                        r = _navPoly.boundingRadius + this._meshShrinkAmount;\n                        d = _navPoly.centroid.distance(startPoint);\n                        if (d <= r) {\n                            // Check if projected point is within range of a polgyon and is closer than the\n                            // previous point\n                            var _projectPointToPolygo = this._projectPointToPolygon(startPoint, _navPoly),\n                                distance = _projectPointToPolygo.distance;\n\n                            if (distance <= this._meshShrinkAmount && distance < startDistance) {\n                                startPoly = _navPoly;\n                                startDistance = distance;\n                            }\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError4 = true;\n                    _iteratorError4 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                            _iterator4.return();\n                        }\n                    } finally {\n                        if (_didIteratorError4) {\n                            throw _iteratorError4;\n                        }\n                    }\n                }\n            }\n\n            // Same check as above, but for the end point\n            if (!endPoly && this._meshShrinkAmount > 0) {\n                var _iteratorNormalCompletion5 = true;\n                var _didIteratorError5 = false;\n                var _iteratorError5 = undefined;\n\n                try {\n                    for (var _iterator5 = this._navPolygons[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                        var _navPoly2 = _step5.value;\n\n                        r = _navPoly2.boundingRadius + this._meshShrinkAmount;\n                        d = _navPoly2.centroid.distance(endPoint);\n                        if (d <= r) {\n                            var _projectPointToPolygo2 = this._projectPointToPolygon(endPoint, _navPoly2),\n                                _distance = _projectPointToPolygo2.distance;\n\n                            if (_distance <= this._meshShrinkAmount && _distance < endDistance) {\n                                endPoly = _navPoly2;\n                                endDistance = _distance;\n                            }\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError5 = true;\n                    _iteratorError5 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                            _iterator5.return();\n                        }\n                    } finally {\n                        if (_didIteratorError5) {\n                            throw _iteratorError5;\n                        }\n                    }\n                }\n            }\n\n            // No matching polygons locations for the start or end, so no path found\n            if (!startPoly || !endPoly) return null;\n\n            // Search!\n            var astarPath = __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default.a.astar.search(this._graph, startPoly, endPoly, {\n                heuristic: this._graph.navHeuristic\n            });\n            // jsastar drops the first point from the path, but the funnel algorithm needs it\n            astarPath.unshift(startPoly);\n\n            // We have a path, so now time for the funnel algorithm\n            var channel = new __WEBPACK_IMPORTED_MODULE_3__channel__[\"a\" /* default */]();\n            channel.push(startPoint);\n            for (var i = 0; i < astarPath.length - 1; i++) {\n                var navPolygon = astarPath[i];\n                var nextNavPolygon = astarPath[i + 1];\n\n                // Find the portal\n                var portal = null;\n                for (var _i = 0; _i < navPolygon.neighbors.length; _i++) {\n                    if (navPolygon.neighbors[_i].id === nextNavPolygon.id) {\n                        portal = navPolygon.portals[_i];\n                    }\n                }\n\n                // Push the portal vertices into the channel\n                channel.push(portal.start, portal.end);\n            }\n            channel.push(endPoint);\n\n            // Pull a string along the channel to run the funnel\n            channel.stringPull();\n\n            // Clone path, excluding duplicates\n            var lastPoint = null;\n            var phaserPath = [];\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n                for (var _iterator6 = channel.path[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                    var p = _step6.value;\n\n                    var newPoint = p.clone();\n                    if (!lastPoint || !newPoint.equals(lastPoint)) phaserPath.push(newPoint);\n                    lastPoint = newPoint;\n                }\n\n                // Call debug drawing\n            } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                        _iterator6.return();\n                    }\n                } finally {\n                    if (_didIteratorError6) {\n                        throw _iteratorError6;\n                    }\n                }\n            }\n\n            if (drawPolyPath) {\n                var polyPath = astarPath.map(function (elem) {\n                    return elem.centroid;\n                });\n                this.debugDrawPath(polyPath, 0x00ff00, 5);\n            }\n            if (drawFinalPath) this.debugDrawPath(phaserPath, 0xffd900, 10);\n\n            return phaserPath;\n        }\n    }, {\n        key: \"_calculateNeighbors\",\n        value: function _calculateNeighbors() {\n            // Fill out the neighbor information for each navpoly\n            for (var i = 0; i < this._navPolygons.length; i++) {\n                var navPoly = this._navPolygons[i];\n\n                for (var j = i + 1; j < this._navPolygons.length; j++) {\n                    var otherNavPoly = this._navPolygons[j];\n\n                    // Check if the other navpoly is within range to touch\n                    var d = navPoly.centroid.distance(otherNavPoly.centroid);\n                    if (d > navPoly.boundingRadius + otherNavPoly.boundingRadius) continue;\n\n                    // The are in range, so check each edge pairing\n                    var _iteratorNormalCompletion7 = true;\n                    var _didIteratorError7 = false;\n                    var _iteratorError7 = undefined;\n\n                    try {\n                        for (var _iterator7 = navPoly.edges[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                            var edge = _step7.value;\n                            var _iteratorNormalCompletion8 = true;\n                            var _didIteratorError8 = false;\n                            var _iteratorError8 = undefined;\n\n                            try {\n                                for (var _iterator8 = otherNavPoly.edges[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                                    var otherEdge = _step8.value;\n\n\n                                    // If edges aren't collinear, not an option for connecting navpolys\n                                    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__[\"a\" /* areCollinear */])(edge, otherEdge)) continue;\n\n                                    // If they are collinear, check if they overlap\n                                    var overlap = this._getSegmentOverlap(edge, otherEdge);\n                                    if (!overlap) continue;\n\n                                    // Connections are symmetric!\n                                    navPoly.neighbors.push(otherNavPoly);\n                                    otherNavPoly.neighbors.push(navPoly);\n\n                                    // Calculate the portal between the two polygons - this needs to be in\n                                    // counter-clockwise order, relative to each polygon\n\n                                    var _overlap = _slicedToArray(overlap, 2),\n                                        p1 = _overlap[0],\n                                        p2 = _overlap[1];\n\n                                    var edgeStartAngle = navPoly.centroid.angle(edge.start);\n                                    var a1 = navPoly.centroid.angle(overlap[0]);\n                                    var a2 = navPoly.centroid.angle(overlap[1]);\n                                    var d1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__[\"b\" /* angleDifference */])(edgeStartAngle, a1);\n                                    var d2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__[\"b\" /* angleDifference */])(edgeStartAngle, a2);\n                                    if (d1 < d2) {\n                                        navPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\n                                    } else {\n                                        navPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\n                                    }\n\n                                    edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);\n                                    a1 = otherNavPoly.centroid.angle(overlap[0]);\n                                    a2 = otherNavPoly.centroid.angle(overlap[1]);\n                                    d1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__[\"b\" /* angleDifference */])(edgeStartAngle, a1);\n                                    d2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__[\"b\" /* angleDifference */])(edgeStartAngle, a2);\n                                    if (d1 < d2) {\n                                        otherNavPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\n                                    } else {\n                                        otherNavPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\n                                    }\n\n                                    // Two convex polygons shouldn't be connected more than once! (Unless\n                                    // there are unnecessary vertices...)\n                                }\n                            } catch (err) {\n                                _didIteratorError8 = true;\n                                _iteratorError8 = err;\n                            } finally {\n                                try {\n                                    if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                                        _iterator8.return();\n                                    }\n                                } finally {\n                                    if (_didIteratorError8) {\n                                        throw _iteratorError8;\n                                    }\n                                }\n                            }\n                        }\n                    } catch (err) {\n                        _didIteratorError7 = true;\n                        _iteratorError7 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                                _iterator7.return();\n                            }\n                        } finally {\n                            if (_didIteratorError7) {\n                                throw _iteratorError7;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Check two collinear line segments to see if they overlap by sorting the points.\n        // Algorithm source: http://stackoverflow.com/a/17152247\n\n    }, {\n        key: \"_getSegmentOverlap\",\n        value: function _getSegmentOverlap(line1, line2) {\n            var points = [{ line: line1, point: line1.start }, { line: line1, point: line1.end }, { line: line2, point: line2.start }, { line: line2, point: line2.end }];\n            points.sort(function (a, b) {\n                if (a.point.x < b.point.x) return -1;else if (a.point.x > b.point.x) return 1;else {\n                    if (a.point.y < b.point.y) return -1;else if (a.point.y > b.point.y) return 1;else return 0;\n                }\n            });\n            // If the first two points in the array come from the same line, no overlap\n            var noOverlap = points[0].line === points[1].line;\n            // If the two middle points in the array are the same coordinates, then there is a \n            // single point of overlap.\n            var singlePointOverlap = points[1].point.equals(points[2].point);\n            if (noOverlap || singlePointOverlap) return null;else return [points[1].point, points[2].point];\n        }\n\n        /**\r\n         * Project a point onto a polygon in the shortest distance possible.\r\n         * \r\n         * @param {Phaser.Point} point The point to project\r\n         * @param {NavPoly} navPoly The navigation polygon to test against\r\n         * @returns {{point: Phaser.Point, distance: number}}\r\n         * \r\n         * @private\r\n         * @memberof NavMesh\r\n         */\n\n    }, {\n        key: \"_projectPointToPolygon\",\n        value: function _projectPointToPolygon(point, navPoly) {\n            var closestProjection = null;\n            var closestDistance = Number.MAX_VALUE;\n            var _iteratorNormalCompletion9 = true;\n            var _didIteratorError9 = false;\n            var _iteratorError9 = undefined;\n\n            try {\n                for (var _iterator9 = navPoly.edges[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                    var edge = _step9.value;\n\n                    var projectedPoint = this._projectPointToEdge(point, edge);\n                    var d = point.distance(projectedPoint);\n                    if (closestProjection === null || d < closestDistance) {\n                        closestDistance = d;\n                        closestProjection = projectedPoint;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError9 = true;\n                _iteratorError9 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                        _iterator9.return();\n                    }\n                } finally {\n                    if (_didIteratorError9) {\n                        throw _iteratorError9;\n                    }\n                }\n            }\n\n            return { point: closestProjection, distance: closestDistance };\n        }\n    }, {\n        key: \"_distanceSquared\",\n        value: function _distanceSquared(a, b) {\n            var dx = b.x - a.x;\n            var dy = b.y - a.y;\n            return dx * dx + dy * dy;\n        }\n\n        // Project a point onto a line segment\n        // JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\n\n    }, {\n        key: \"_projectPointToEdge\",\n        value: function _projectPointToEdge(point, line) {\n            var a = line.start;\n            var b = line.end;\n            // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find\n            // where our point lies on the line by solving for t:\n            //  t = [(p-a) . (b-a)] / |b-a|^2\n            var l2 = this._distanceSquared(a, b);\n            var t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;\n            // We clamp t from [0,1] to handle points outside the segment vw.\n            t = Phaser.Math.clamp(t, 0, 1);\n            // Project onto the segment\n            var p = new Phaser.Point(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));\n            return p;\n        }\n\n        /**\r\n         * Enable debug and create graphics overlay (if it hasn't already been created) \r\n         */\n\n    }, {\n        key: \"enableDebug\",\n        value: function enableDebug() {\n            if (!this._debugGraphics) {\n                this._debugGraphics = this.game.add.graphics(0, 0);\n                this._debugGraphics.alpha = 0.5;\n            }\n        }\n\n        /**\r\n         * Disable debug and destroy associated graphics\r\n         */\n\n    }, {\n        key: \"disableDebug\",\n        value: function disableDebug() {\n            if (this._debugGraphics) {\n                this._debugGraphics.destroy();\n                this._debugGraphics = null;\n            }\n        }\n\n        /**\r\n         * Check whether debug is enabled\r\n         * \r\n         * @returns {boolean}\r\n         */\n\n    }, {\n        key: \"isDebugEnabled\",\n        value: function isDebugEnabled() {\n            return this._debugGraphics !== null;\n        }\n\n        /**\r\n         * Clear the debug overlay\r\n         */\n\n    }, {\n        key: \"debugClear\",\n        value: function debugClear() {\n            if (this._debugGraphics) this._debugGraphics.clear();\n        }\n\n        /**\r\n         * Visualize the polygons in the nav mesh as an overlay on top of the game\r\n         *\r\n         * @param {object} options\r\n         * @param {boolean} [options.drawCentroid=true] For each polygon, show the approx centroid\r\n         * @param {boolean} [options.drawBounds=false] For each polygon, show the bounding radius\r\n         * @param {boolean} [options.drawNeighbors=true] For each polygon, show the connections to\r\n         * neighbors\r\n         * @param {boolean} [options.drawPortals=true] For each polygon, show the portal edges\r\n         */\n\n    }, {\n        key: \"debugDrawMesh\",\n        value: function debugDrawMesh() {\n            var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                _ref4$drawCentroid = _ref4.drawCentroid,\n                drawCentroid = _ref4$drawCentroid === undefined ? true : _ref4$drawCentroid,\n                _ref4$drawBounds = _ref4.drawBounds,\n                drawBounds = _ref4$drawBounds === undefined ? false : _ref4$drawBounds,\n                _ref4$drawNeighbors = _ref4.drawNeighbors,\n                drawNeighbors = _ref4$drawNeighbors === undefined ? true : _ref4$drawNeighbors,\n                _ref4$drawPortals = _ref4.drawPortals,\n                drawPortals = _ref4$drawPortals === undefined ? true : _ref4$drawPortals;\n\n            if (!this._debugGraphics) this.enableDebug();\n            // Visualize the navigation mesh\n            var _iteratorNormalCompletion10 = true;\n            var _didIteratorError10 = false;\n            var _iteratorError10 = undefined;\n\n            try {\n                for (var _iterator10 = this._navPolygons[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n                    var navPoly = _step10.value;\n\n                    navPoly.draw(this._debugGraphics, drawCentroid, drawBounds, drawNeighbors, drawPortals);\n                }\n            } catch (err) {\n                _didIteratorError10 = true;\n                _iteratorError10 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion10 && _iterator10.return) {\n                        _iterator10.return();\n                    }\n                } finally {\n                    if (_didIteratorError10) {\n                        throw _iteratorError10;\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * Visualize a path (array of points) on the debug graphics overlay\r\n         * \r\n         * @param {Phaser.Point[]} path \r\n         * @param {number} [color=0x00FF00] \r\n         * @param {number} [thickness=10] \r\n         */\n\n    }, {\n        key: \"debugDrawPath\",\n        value: function debugDrawPath(path) {\n            var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0x00FF00;\n            var thickness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n\n            if (!this._debugGraphics) this.enableDebug();\n            if (path.length) {\n                // Draw line for path\n                this._debugGraphics.lineStyle(thickness, color);\n                this._debugGraphics.drawShape(new (Function.prototype.bind.apply(Phaser.Polygon, [null].concat(_toConsumableArray(path))))());\n                this._debugGraphics.beginFill(color);\n                // Draw circle at start and end of path\n                var d = 0.5 * thickness;\n                this._debugGraphics.drawEllipse(path[0].x, path[0].y, d, d);\n                var lastPoint = path[path.length - 1];\n                this._debugGraphics.drawEllipse(lastPoint.x, lastPoint.y, d, d);\n                this._debugGraphics.endFill();\n            }\n        }\n    }]);\n\n    return NavMesh;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (NavMesh);\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Debug color palette\nvar palette = [0x00A0B0, 0x6A4A3C, 0xCC333F, 0xEB6841, 0xEDC951];\n\n/**\r\n * A class that represents a navigable polygon in a navmesh. It is build from a Phaser.Polygon. It\r\n * has a drawing function to help visualize it's features:\r\n *  - polygon\r\n *  - neighbors - any navpolys that can be reached from this navpoly\r\n *  - portals - overlapping edges between neighbors\r\n *  - centroid - not a true centroid, just an approximation.\r\n *  - boundingRadius - the radius of a circle at the centroid that fits all the points of the poly \r\n * \r\n * It implements the properties and fields that javascript-astar needs - weight, toString, isWall\r\n * and getCost. See GPS test from astar repo for structure: \r\n * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavPoly\r\n * @private\r\n */\n\nvar NavPoly = function () {\n    /**\r\n     * Creates an instance of NavPoly.\r\n     * @param {Phaser.Game} game \r\n     * @param {number} id \r\n     * @param {Phaser.Polygon} polygon \r\n     * \r\n     * @memberof NavPoly\r\n     */\n    function NavPoly(game, id, polygon) {\n        _classCallCheck(this, NavPoly);\n\n        this.game = game;\n        this.id = id;\n        this.polygon = polygon;\n        this.edges = this._calculateEdges();\n        this.neighbors = [];\n        this.portals = [];\n        this.centroid = this._calculateCentroid();\n        this.boundingRadius = this._calculateRadius();\n\n        this.weight = 1; // jsastar property\n\n        var i = this.id % palette.length;\n        this._color = palette[i];\n    }\n\n    _createClass(NavPoly, [{\n        key: \"constains\",\n        value: function constains(point) {\n            return this.polygon.contains(point.x, point.y);\n        }\n    }, {\n        key: \"destroy\",\n        value: function destroy() {\n            this.game = null;\n            this.neighbors = [];\n            this.portals = [];\n        }\n\n        // jsastar methods\n\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            return \"NavPoly(id: \" + this.id + \" at: \" + this.centroid + \")\";\n        }\n    }, {\n        key: \"isWall\",\n        value: function isWall() {\n            return this.weight === 0;\n        }\n    }, {\n        key: \"centroidDistance\",\n        value: function centroidDistance(navPolygon) {\n            return this.centroid.distance(navPolygon.centroid);\n        }\n    }, {\n        key: \"getCost\",\n        value: function getCost(navPolygon) {\n            return this.centroidDistance(navPolygon);\n        }\n    }, {\n        key: \"_calculateEdges\",\n        value: function _calculateEdges() {\n            var points = this.polygon.points;\n            var edges = [];\n            for (var i = 1; i < points.length; i++) {\n                var p1 = points[i - 1];\n                var p2 = points[i];\n                edges.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\n            }\n            var first = points[0];\n            var last = points[points.length - 1];\n            edges.push(new Phaser.Line(first.x, first.y, last.x, last.y));\n            return edges;\n        }\n    }, {\n        key: \"_calculateCentroid\",\n        value: function _calculateCentroid() {\n            // NOTE: this is not actually the centroid, it's the average of the vertices - not the same\n            // thing!\n            var centroid = new Phaser.Point(0, 0);\n            var length = this.polygon.points.length;\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.polygon.points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var point = _step.value;\n\n                    centroid.add(point.x, point.y);\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            centroid.divide(length, length);\n            return centroid;\n        }\n    }, {\n        key: \"_calculateRadius\",\n        value: function _calculateRadius() {\n            var boundingRadius = 0;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this.polygon.points[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var point = _step2.value;\n\n                    var d = this.centroid.distance(point);\n                    if (d > boundingRadius) boundingRadius = d;\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            return boundingRadius;\n        }\n\n        /**\r\n         * Draw the polygon to given graphics object\r\n         * \r\n         * @param {Phaser.Graphics} graphics \r\n         * @param {boolean} [drawCentroid=true] Show the approx centroid\r\n         * @param {boolean} [drawBounds=false] Show the bounding radius\r\n         * @param {boolean} [drawNeighbors=true] Show the connections to neighbors\r\n         * @param {boolean} [drawPortals=true] Show the portal edges\r\n         * \r\n         * @memberof NavPoly\r\n         */\n\n    }, {\n        key: \"draw\",\n        value: function draw(graphics) {\n            var drawCentroid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            var drawBounds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n            var drawNeighbors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n            var drawPortals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n            graphics.lineWidth = 0;\n            graphics.beginFill(this._color);\n            graphics.drawPolygon(this.polygon);\n            graphics.endFill();\n\n            if (drawCentroid) {\n                graphics.beginFill(0x000000);\n                graphics.drawEllipse(this.centroid.x, this.centroid.y, 4, 4);\n                graphics.endFill();\n            }\n\n            if (drawBounds) {\n                graphics.lineStyle(1, 0xFFFFFF);\n                var r = this.boundingRadius;\n                graphics.drawEllipse(this.centroid.x, this.centroid.y, r, r);\n            }\n\n            if (drawNeighbors) {\n                graphics.lineStyle(2, 0x000000);\n                var _iteratorNormalCompletion3 = true;\n                var _didIteratorError3 = false;\n                var _iteratorError3 = undefined;\n\n                try {\n                    for (var _iterator3 = this.neighbors[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                        var n = _step3.value;\n\n                        graphics.moveTo(this.centroid.x, this.centroid.y);\n                        graphics.lineTo(n.centroid.x, n.centroid.y);\n                    }\n                } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                            _iterator3.return();\n                        }\n                    } finally {\n                        if (_didIteratorError3) {\n                            throw _iteratorError3;\n                        }\n                    }\n                }\n            }\n\n            if (drawPortals) {\n                graphics.lineStyle(10, 0x000000);\n                var _iteratorNormalCompletion4 = true;\n                var _didIteratorError4 = false;\n                var _iteratorError4 = undefined;\n\n                try {\n                    for (var _iterator4 = this.portals[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                        var p = _step4.value;\n\n                        graphics.moveTo(p.start.x, p.start.y);\n                        graphics.lineTo(p.end.x, p.end.y);\n                    }\n                } catch (err) {\n                    _didIteratorError4 = true;\n                    _iteratorError4 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                            _iterator4.return();\n                        }\n                    } finally {\n                        if (_didIteratorError4) {\n                            throw _iteratorError4;\n                        }\n                    }\n                }\n            }\n        }\n    }]);\n\n    return NavPoly;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (NavPoly);\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// phaser-navmesh.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7c2d548790e295d9b34b","/**\r\n * Twice the area of the triangle formed by a, b and c\r\n * @private\r\n */\r\nexport function triarea2(a, b, c) {\r\n    const ax = b.x - a.x;\r\n    const ay = b.y - a.y;\r\n    const bx = c.x - a.x;\r\n    const by = c.y - a.y;\r\n    return bx * ay - ax * by;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function almostEqual(value1, value2, errorMargin = 0.0001) {\r\n    if (Math.abs(value1 - value2) <= errorMargin) return true;\r\n    else return false;\r\n}\r\n\r\n/**\r\n * https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0\r\n * @private\r\n */\r\nexport function angleDifference(x, y) {\r\n    let a = x - y;\r\n    const i = a + Math.PI;\r\n    const j = Math.PI * 2;\r\n    a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign\r\n    a -= Math.PI;\r\n    return a;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function areCollinear(line1, line2, errorMargin=0.0001) {\r\n    // Figure out if the two lines are equal by looking at the area of the triangle formed\r\n    // by their points\r\n    const area1 = triarea2(line1.start, line1.end, line2.start);\r\n    const area2 = triarea2(line1.start, line1.end, line2.end);\r\n    if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {\r\n        return true;\r\n    } else return false;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./utils.js","// javascript-astar 0.4.2\r\n// http://github.com/bgrins/javascript-astar\r\n// Freely distributable under the MIT License.\r\n// Implements the astar search algorithm in javascript using a Binary Heap.\r\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\r\n// http://eloquentjavascript.net/appendix2.html\r\n(function(definition) {\r\n  /* global module, define */\r\n  if (typeof module === 'object' && typeof module.exports === 'object') {\r\n    module.exports = definition();\r\n  } else if (typeof define === 'function' && define.amd) {\r\n    define([], definition);\r\n  } else {\r\n    var exports = definition();\r\n    window.astar = exports.astar;\r\n    window.Graph = exports.Graph;\r\n  }\r\n})(function() {\r\n\r\nfunction pathTo(node) {\r\n  var curr = node;\r\n  var path = [];\r\n  while (curr.parent) {\r\n    path.unshift(curr);\r\n    curr = curr.parent;\r\n  }\r\n  return path;\r\n}\r\n\r\nfunction getHeap() {\r\n  return new BinaryHeap(function(node) {\r\n    return node.f;\r\n  });\r\n}\r\n\r\nvar astar = {\r\n  /**\r\n  * Perform an A* Search on a graph given a start and end node.\r\n  * @param {Graph} graph\r\n  * @param {GridNode} start\r\n  * @param {GridNode} end\r\n  * @param {Object} [options]\r\n  * @param {bool} [options.closest] Specifies whether to return the\r\n             path to the closest node if the target is unreachable.\r\n  * @param {Function} [options.heuristic] Heuristic function (see\r\n  *          astar.heuristics).\r\n  */\r\n  search: function(graph, start, end, options) {\r\n    graph.cleanDirty();\r\n    options = options || {};\r\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\r\n    var closest = options.closest || false;\r\n\r\n    var openHeap = getHeap();\r\n    var closestNode = start; // set the start node to be the closest if required\r\n\r\n    start.h = heuristic(start, end);\r\n    graph.markDirty(start);\r\n\r\n    openHeap.push(start);\r\n\r\n    while (openHeap.size() > 0) {\r\n\r\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\r\n      var currentNode = openHeap.pop();\r\n\r\n      // End case -- result has been found, return the traced path.\r\n      if (currentNode === end) {\r\n        return pathTo(currentNode);\r\n      }\r\n\r\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\r\n      currentNode.closed = true;\r\n\r\n      // Find all neighbors for the current node.\r\n      var neighbors = graph.neighbors(currentNode);\r\n\r\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\r\n        var neighbor = neighbors[i];\r\n\r\n        if (neighbor.closed || neighbor.isWall()) {\r\n          // Not a valid node to process, skip to next neighbor.\r\n          continue;\r\n        }\r\n\r\n        // The g score is the shortest distance from start to current node.\r\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\r\n        var gScore = currentNode.g + neighbor.getCost(currentNode);\r\n        var beenVisited = neighbor.visited;\r\n\r\n        if (!beenVisited || gScore < neighbor.g) {\r\n\r\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\r\n          neighbor.visited = true;\r\n          neighbor.parent = currentNode;\r\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\r\n          neighbor.g = gScore;\r\n          neighbor.f = neighbor.g + neighbor.h;\r\n          graph.markDirty(neighbor);\r\n          if (closest) {\r\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\r\n            // a cheaper path than the current closest node then it becomes the closest node\r\n            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\r\n              closestNode = neighbor;\r\n            }\r\n          }\r\n\r\n          if (!beenVisited) {\r\n            // Pushing to heap will put it in proper place based on the 'f' value.\r\n            openHeap.push(neighbor);\r\n          } else {\r\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\r\n            openHeap.rescoreElement(neighbor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (closest) {\r\n      return pathTo(closestNode);\r\n    }\r\n\r\n    // No result was found - empty array signifies failure to find path.\r\n    return [];\r\n  },\r\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\r\n  heuristics: {\r\n    manhattan: function(pos0, pos1) {\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return d1 + d2;\r\n    },\r\n    diagonal: function(pos0, pos1) {\r\n      var D = 1;\r\n      var D2 = Math.sqrt(2);\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\r\n    }\r\n  },\r\n  cleanNode: function(node) {\r\n    node.f = 0;\r\n    node.g = 0;\r\n    node.h = 0;\r\n    node.visited = false;\r\n    node.closed = false;\r\n    node.parent = null;\r\n  }\r\n};\r\n\r\n/**\r\n * A graph memory structure\r\n * @param {Array} gridIn 2D array of input weights\r\n * @param {Object} [options]\r\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\r\n */\r\nfunction Graph(gridIn, options) {\r\n  options = options || {};\r\n  this.nodes = [];\r\n  this.diagonal = !!options.diagonal;\r\n  this.grid = [];\r\n  for (var x = 0; x < gridIn.length; x++) {\r\n    this.grid[x] = [];\r\n\r\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\r\n      var node = new GridNode(x, y, row[y]);\r\n      this.grid[x][y] = node;\r\n      this.nodes.push(node);\r\n    }\r\n  }\r\n  this.init();\r\n}\r\n\r\nGraph.prototype.init = function() {\r\n  this.dirtyNodes = [];\r\n  for (var i = 0; i < this.nodes.length; i++) {\r\n    astar.cleanNode(this.nodes[i]);\r\n  }\r\n};\r\n\r\nGraph.prototype.cleanDirty = function() {\r\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\r\n    astar.cleanNode(this.dirtyNodes[i]);\r\n  }\r\n  this.dirtyNodes = [];\r\n};\r\n\r\nGraph.prototype.markDirty = function(node) {\r\n  this.dirtyNodes.push(node);\r\n};\r\n\r\nGraph.prototype.neighbors = function(node) {\r\n  var ret = [];\r\n  var x = node.x;\r\n  var y = node.y;\r\n  var grid = this.grid;\r\n\r\n  // West\r\n  if (grid[x - 1] && grid[x - 1][y]) {\r\n    ret.push(grid[x - 1][y]);\r\n  }\r\n\r\n  // East\r\n  if (grid[x + 1] && grid[x + 1][y]) {\r\n    ret.push(grid[x + 1][y]);\r\n  }\r\n\r\n  // South\r\n  if (grid[x] && grid[x][y - 1]) {\r\n    ret.push(grid[x][y - 1]);\r\n  }\r\n\r\n  // North\r\n  if (grid[x] && grid[x][y + 1]) {\r\n    ret.push(grid[x][y + 1]);\r\n  }\r\n\r\n  if (this.diagonal) {\r\n    // Southwest\r\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\r\n      ret.push(grid[x - 1][y - 1]);\r\n    }\r\n\r\n    // Southeast\r\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\r\n      ret.push(grid[x + 1][y - 1]);\r\n    }\r\n\r\n    // Northwest\r\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\r\n      ret.push(grid[x - 1][y + 1]);\r\n    }\r\n\r\n    // Northeast\r\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\r\n      ret.push(grid[x + 1][y + 1]);\r\n    }\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nGraph.prototype.toString = function() {\r\n  var graphString = [];\r\n  var nodes = this.grid;\r\n  for (var x = 0; x < nodes.length; x++) {\r\n    var rowDebug = [];\r\n    var row = nodes[x];\r\n    for (var y = 0; y < row.length; y++) {\r\n      rowDebug.push(row[y].weight);\r\n    }\r\n    graphString.push(rowDebug.join(\" \"));\r\n  }\r\n  return graphString.join(\"\\n\");\r\n};\r\n\r\nfunction GridNode(x, y, weight) {\r\n  this.x = x;\r\n  this.y = y;\r\n  this.weight = weight;\r\n}\r\n\r\nGridNode.prototype.toString = function() {\r\n  return \"[\" + this.x + \" \" + this.y + \"]\";\r\n};\r\n\r\nGridNode.prototype.getCost = function(fromNeighbor) {\r\n  // Take diagonal weight into consideration.\r\n  if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\r\n    return this.weight * 1.41421;\r\n  }\r\n  return this.weight;\r\n};\r\n\r\nGridNode.prototype.isWall = function() {\r\n  return this.weight === 0;\r\n};\r\n\r\nfunction BinaryHeap(scoreFunction) {\r\n  this.content = [];\r\n  this.scoreFunction = scoreFunction;\r\n}\r\n\r\nBinaryHeap.prototype = {\r\n  push: function(element) {\r\n    // Add the new element to the end of the array.\r\n    this.content.push(element);\r\n\r\n    // Allow it to sink down.\r\n    this.sinkDown(this.content.length - 1);\r\n  },\r\n  pop: function() {\r\n    // Store the first element so we can return it later.\r\n    var result = this.content[0];\r\n    // Get the element at the end of the array.\r\n    var end = this.content.pop();\r\n    // If there are any elements left, put the end element at the\r\n    // start, and let it bubble up.\r\n    if (this.content.length > 0) {\r\n      this.content[0] = end;\r\n      this.bubbleUp(0);\r\n    }\r\n    return result;\r\n  },\r\n  remove: function(node) {\r\n    var i = this.content.indexOf(node);\r\n\r\n    // When it is found, the process seen in 'pop' is repeated\r\n    // to fill up the hole.\r\n    var end = this.content.pop();\r\n\r\n    if (i !== this.content.length - 1) {\r\n      this.content[i] = end;\r\n\r\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n        this.sinkDown(i);\r\n      } else {\r\n        this.bubbleUp(i);\r\n      }\r\n    }\r\n  },\r\n  size: function() {\r\n    return this.content.length;\r\n  },\r\n  rescoreElement: function(node) {\r\n    this.sinkDown(this.content.indexOf(node));\r\n  },\r\n  sinkDown: function(n) {\r\n    // Fetch the element that has to be sunk.\r\n    var element = this.content[n];\r\n\r\n    // When at 0, an element can not sink any further.\r\n    while (n > 0) {\r\n\r\n      // Compute the parent element's index, and fetch it.\r\n      var parentN = ((n + 1) >> 1) - 1;\r\n      var parent = this.content[parentN];\r\n      // Swap the elements if the parent is greater.\r\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n        this.content[parentN] = element;\r\n        this.content[n] = parent;\r\n        // Update 'n' to continue at the new position.\r\n        n = parentN;\r\n      }\r\n      // Found a parent that is less, no need to sink any further.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  },\r\n  bubbleUp: function(n) {\r\n    // Look up the target element and its score.\r\n    var length = this.content.length;\r\n    var element = this.content[n];\r\n    var elemScore = this.scoreFunction(element);\r\n\r\n    while (true) {\r\n      // Compute the indices of the child elements.\r\n      var child2N = (n + 1) << 1;\r\n      var child1N = child2N - 1;\r\n      // This is used to store the new position of the element, if any.\r\n      var swap = null;\r\n      var child1Score;\r\n      // If the first child exists (is inside the array)...\r\n      if (child1N < length) {\r\n        // Look it up and compute its score.\r\n        var child1 = this.content[child1N];\r\n        child1Score = this.scoreFunction(child1);\r\n\r\n        // If the score is less than our element's, we need to swap.\r\n        if (child1Score < elemScore) {\r\n          swap = child1N;\r\n        }\r\n      }\r\n\r\n      // Do the same checks for the other child.\r\n      if (child2N < length) {\r\n        var child2 = this.content[child2N];\r\n        var child2Score = this.scoreFunction(child2);\r\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\r\n          swap = child2N;\r\n        }\r\n      }\r\n\r\n      // If the element needs to be moved, swap it, and continue.\r\n      if (swap !== null) {\r\n        this.content[n] = this.content[swap];\r\n        this.content[swap] = element;\r\n        n = swap;\r\n      }\r\n      // Otherwise, we are done.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nreturn {\r\n  astar: astar,\r\n  Graph: Graph\r\n};\r\n\r\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/navmesh-phaser-plugin/~/javascript-astar/astar.js\n// module id = 1\n// module chunks = 0 1","// const triangulate = require(\"./triangulate\");\r\nimport NavMesh from \"./nav-mesh\";\r\n\r\n/**\r\n * This plugin can create navigation meshes for use in Phaser. The navmeshes can be constructed from\r\n * convex polygons embedded in a Tiled map. Instantiate this using game.plugins.add(NavMeshPlugin).\r\n *\r\n * @param {Phaser.Game} game\r\n * @param {Phaser.PluginManager} manager\r\n */\r\nexport default class NavMeshPlugin extends Phaser.Plugin {\r\n    constructor(game, manager) {\r\n        super(game, manager);\r\n        this._navMeshes = [];\r\n    }\r\n\r\n    /**\r\n     * Load a navmesh from Tiled and switch it to be the current navmesh. Currently assumes that the\r\n     * polygons are squares!\r\n     * \r\n     * @param {Phaser.Tilemap} tilemap The tilemap that contains polygons under an object layer\r\n     * @param {string} objectKey The name of the object layer in the tilemap\r\n     * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n     * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n     * \r\n     * @memberof NavMeshPlugin\r\n     */\r\n    buildMeshFromTiled(tilemap, objectKey, meshShrinkAmount = 0) {\r\n        // Load up the object layer\r\n        const rects = tilemap.objects[objectKey] || [];\r\n        // Loop over the objects and construct a polygon\r\n        const polygons = [];\r\n        for (const r of rects) {\r\n            const top = r.y;\r\n            const bottom = r.y + r.height;\r\n            const left = r.x;\r\n            const right = r.x + r.width;\r\n            const poly = new Phaser.Polygon(left,top, left,bottom, right,bottom, right,top);\r\n            polygons.push(poly);\r\n        }\r\n        // Build the navmesh\r\n        const mesh = new NavMesh(this.game, polygons, meshShrinkAmount);\r\n        this._navMeshes.push(mesh);\r\n        return mesh;\r\n    }\r\n\r\n    destroy() {\r\n        for (const mesh of this._navMeshes) mesh.destroy();\r\n        this._navMeshes = [];\r\n        super.destroy();\r\n    }\r\n\r\n    // /**\r\n    //  * Build a navmesh from an array of convex polygons. This currently tesselates the polygons into\r\n    //  * triangles. They aren't as efficient or as well designed as ones made by hand in Tiled. \r\n    //  *\r\n    //  * @param {string} levelName The key to use to store the navmesh in the plugin  \r\n    //  * @param {[]} hulls An array of convex polygons describing the obstacles in the\r\n    //  * level. See lighting-plugin/hull-from-tiles.\r\n    //  *\r\n    //  * @memberof NavMeshPlugin\r\n    //  */\r\n    // buildMesh(levelName, hulls) {\r\n    //     const contours = this._buildContours(hulls);\r\n    //     // Get an array of triangulated vertices\r\n    //     const triangles = triangulate(contours, false); // Counter-clockwise ordering!\r\n    //     const polygons = [];\r\n    //     for (let i = 0; i < triangles.length; i += 6) {\r\n    //         const poly = new Phaser.Polygon(\r\n    //             // These should be in counter-clockwise order from triangulate\r\n    //             triangles[i + 0], triangles[i + 1], \r\n    //             triangles[i + 2], triangles[i + 3], \r\n    //             triangles[i + 4], triangles[i + 5]\r\n    //         );\r\n    //         polygons.push(poly);\r\n    //     }\r\n    //     const navMesh = new NavMesh(this.game, polygons);\r\n    //     this._navMeshes[levelName] = navMesh;\r\n    //     this._currentNavMesh = navMesh;\r\n    // }\r\n\r\n    // /**\r\n    //  * @param {[]} hulls \r\n    //  * @returns \r\n    //  * \r\n    //  * @memberof NavMeshPlugin\r\n    //  */\r\n    // _buildContours(hulls) {\r\n    //     const w = this.game.width;\r\n    //     const h = this.game.height;\r\n    //     // Start the contours\r\n    //     const contours = [\r\n    //         // Full screen - counter clockwise\r\n    //         Float32Array.of(0,0, 0,h, w,h, w,0)\r\n    //     ];\r\n    //     // For each convex hull add the contour\r\n    //     for (const hull of hulls) {\r\n    //         const contour = [];\r\n    //         for (const lineInfo of hull) {\r\n    //             contour.push(lineInfo.line.start.x, lineInfo.line.start.y);\r\n    //         }\r\n    //         contours.push(Float32Array.from(contour));\r\n    //     }\r\n    //     return contours;\r\n    // }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./nav-mesh-plugin.js","// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete\r\n// funnel algorithm so astar checks can be more accurate.\r\n\r\nimport {triarea2} from \"./utils\";\r\n\r\n/**\r\n * @private\r\n */\r\nclass Channel {\r\n    constructor() {\r\n        this.portals = [];\r\n    }\r\n\r\n    /**\r\n     * @param {Phaser.Point} p1 \r\n     * @param {Phaser.Point} p2 \r\n     * \r\n     * @memberof Channel\r\n     */\r\n    push(p1, p2 = null) {\r\n        if (p2 === null) p2 = p1;\r\n        this.portals.push({\r\n            left: p1, \r\n            right: p2\r\n        });\r\n    }\r\n\r\n    stringPull() {\r\n        var portals = this.portals;\r\n        var pts = [];\r\n        // Init scan state\r\n        var portalApex, portalLeft, portalRight;\r\n        var apexIndex = 0,\r\n            leftIndex = 0,\r\n            rightIndex = 0;\r\n\r\n        portalApex = portals[0].left;\r\n        portalLeft = portals[0].left;\r\n        portalRight = portals[0].right;\r\n\r\n        // Add start point.\r\n        pts.push(portalApex);\r\n\r\n        for (var i = 1; i < portals.length; i++) {\r\n            // Find the next portal vertices\r\n            var left = portals[i].left;\r\n            var right = portals[i].right;\r\n\r\n            // Update right vertex.\r\n            if (triarea2(portalApex, portalRight, right) <= 0.0) {\r\n                if (portalApex.equals(portalRight) || \r\n                        triarea2(portalApex, portalLeft, right) > 0.0) {\r\n                    // Tighten the funnel.\r\n                    portalRight = right;\r\n                    rightIndex = i;\r\n                } else {\r\n                    // Right vertex just crossed over the left vertex, so the left vertex should\r\n                    // now be part of the path.\r\n                    pts.push(portalLeft);\r\n                    \r\n                    // Restart scan from portal left point.\r\n\r\n                    // Make current left the new apex.\r\n                    portalApex = portalLeft;\r\n                    apexIndex = leftIndex;\r\n                    // Reset portal\r\n                    portalLeft = portalApex;\r\n                    portalRight = portalApex;\r\n                    leftIndex = apexIndex;\r\n                    rightIndex = apexIndex;\r\n                    // Restart scan\r\n                    i = apexIndex;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // Update left vertex.\r\n            if (triarea2(portalApex, portalLeft, left) >= 0.0) {\r\n                if (portalApex.equals(portalLeft) || \r\n                        triarea2(portalApex, portalRight, left) < 0.0) {\r\n                    // Tighten the funnel.\r\n                    portalLeft = left;\r\n                    leftIndex = i;\r\n                } else {\r\n                    // Left vertex just crossed over the right vertex, so the right vertex should\r\n                    // now be part of the path\r\n                    pts.push(portalRight);\r\n                    \r\n                    // Restart scan from portal right point.\r\n\r\n                    // Make current right the new apex.\r\n                    portalApex = portalRight;\r\n                    apexIndex = rightIndex;\r\n                    // Reset portal\r\n                    portalLeft = portalApex;\r\n                    portalRight = portalApex;\r\n                    leftIndex = apexIndex;\r\n                    rightIndex = apexIndex;\r\n                    // Restart scan\r\n                    i = apexIndex;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        if ((pts.length === 0) || (!pts[pts.length - 1].equals(portals[portals.length - 1].left))) {\r\n            // Append last point to path.\r\n            pts.push(portals[portals.length - 1].left);\r\n        }\r\n\r\n        this.path = pts;\r\n        return pts;\r\n    }\r\n}\r\n\r\nexport default Channel;\n\n\n// WEBPACK FOOTER //\n// ./channel.js","// Fix for webpack not exporting ES6 module default properly when using global mode of UMD. It ends\r\n// up with someone having to do \"PhaserNavmesh.default\" instead of \"PhaserNavmesh\"\r\nmodule.exports = require(\"./nav-mesh-plugin\").default;\n\n\n// WEBPACK FOOTER //\n// ./index.js","import jsastar from \"javascript-astar\";\r\n\r\n/**\r\n * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar\r\n * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavGraph \r\n * @private\r\n */\r\nclass NavGraph {\r\n    constructor(navPolygons) {\r\n        this.nodes = navPolygons;\r\n        this.init();\r\n    }\r\n\r\n    neighbors(navPolygon) {\r\n        return navPolygon.neighbors;\r\n    }\r\n\r\n    navHeuristic(navPolygon1, navPolygon2) {\r\n        return navPolygon1.centroidDistance(navPolygon2);\r\n    }\r\n\r\n    destroy() {\r\n        this.cleanDirty();\r\n        this.nodes = [];\r\n    }\r\n}\r\n\r\nNavGraph.prototype.init = jsastar.Graph.prototype.init;\r\nNavGraph.prototype.cleanDirty = jsastar.Graph.prototype.cleanDirty;\r\nNavGraph.prototype.markDirty = jsastar.Graph.prototype.markDirty;\r\n\r\nexport default NavGraph;\n\n\n// WEBPACK FOOTER //\n// ./nav-graph.js","import jsastar from \"javascript-astar\";\r\nimport NavPoly from \"./nav-poly\";\r\nimport NavGraph from \"./nav-graph\";\r\nimport Channel from \"./channel\";\r\nimport {angleDifference, areCollinear} from \"./utils\";\r\n\r\n/**\r\n * The workhorse that represents a navigation mesh built from a series of polygons. Once built, the\r\n * mesh can be asked for a path from one point to another point. It has debug methods for \r\n * visualizing paths and visualizing the individual polygons. Some internal terminology usage:\r\n * \r\n * - neighbor: a polygon that shares part of an edge with another polygon\r\n * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment\r\n * - channel: the path of polygons from starting point to end point\r\n * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the\r\n *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut.\r\n */\r\nclass NavMesh {\r\n    /**\r\n     * Creates an instance of NavMesh.\r\n     * \r\n     * @param {Phaser.Game} game\r\n     * @param {Phaser.Polygon[]} polygons\r\n     * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n     * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n     */\r\n    constructor(game, polygons, meshShrinkAmount = 0) {\r\n        this.game = game;\r\n        this._debugGraphics = null;\r\n        this._meshShrinkAmount = meshShrinkAmount;\r\n\r\n        // Construct NavPoly instances for each polygon\r\n        this._navPolygons = [];\r\n        for (const [i, polygon] of polygons.entries()) {\r\n            this._navPolygons.push(new NavPoly(game, i, polygon));\r\n        }\r\n\r\n        this._calculateNeighbors();\r\n\r\n        // Astar graph of connections between polygons\r\n        this._graph = new NavGraph(this._navPolygons);\r\n    }\r\n\r\n    /**\r\n     * Cleanup method to remove references so that navmeshes don't hang around from state to state.\r\n     * You don't have to invoke this directly. If you call destroy on the plugin, it will destroy\r\n     * all navmeshes that have been created. \r\n     * \r\n     * @memberof NavMesh\r\n     */\r\n    destroy() {\r\n        this._graph.destroy();\r\n        for (const poly of this._navPolygons) poly.destroy();\r\n        this._navPolygons = [];\r\n        this.game = null;\r\n        this.disableDebug();\r\n    }\r\n\r\n    /**\r\n     * Find a path from the start point to the end point using this nav mesh.\r\n     *\r\n     * @param {Phaser.Point} startPoint\r\n     * @param {Phaser.Point} endPoint\r\n     * @param {object} [drawOptions={}] Options for controlling debug drawing\r\n     * @param {boolean} [drawOptions.drawPolyPath=false] Whether or not to visualize the path\r\n     * through the polygons - e.g. the path that astar found.\r\n     * @param {boolean} [drawOptions.drawFinalPath=false] Whether or not to visualize the path\r\n     * through the path that was returned.\r\n     * @returns {Phaser.Point[]|null} An array of points if a path is found, or null if no path\r\n     *\r\n     * @memberof NavMesh\r\n     */\r\n    findPath(startPoint, endPoint, {drawPolyPath = false, drawFinalPath = false} = {}) {\r\n        let startPoly = null;\r\n        let endPoly = null;\r\n        let startDistance = Number.MAX_VALUE;\r\n        let endDistance = Number.MAX_VALUE;\r\n        let d, r;\r\n\r\n        // Find the closest poly for the starting and ending point\r\n        for (const navPoly of this._navPolygons) {\r\n            r = navPoly.boundingRadius;\r\n            // Start\r\n            d = navPoly.centroid.distance(startPoint);\r\n            if (d <= startDistance && d <= r && navPoly.constains(startPoint)) {\r\n                startPoly = navPoly;\r\n                startDistance = d;\r\n            }\r\n            // End\r\n            d = navPoly.centroid.distance(endPoint);\r\n            if (d <= endDistance && d <= r && navPoly.constains(endPoint)) {\r\n                endPoly = navPoly;\r\n                endDistance = d;\r\n            }\r\n        }\r\n\r\n        // If the start point wasn't inside a polygon, run a more liberal check that allows a point\r\n        // to be within meshShrinkAmount radius of a polygon\r\n        if (!startPoly && this._meshShrinkAmount > 0) {\r\n            for (const navPoly of this._navPolygons) {\r\n                // Check if point is within bounding circle to avoid extra projection calculations\r\n                r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n                d = navPoly.centroid.distance(startPoint);\r\n                if (d <= r) {\r\n                    // Check if projected point is within range of a polgyon and is closer than the\r\n                    // previous point\r\n                    const {distance} = this._projectPointToPolygon(startPoint, navPoly);\r\n                    if (distance <= this._meshShrinkAmount && distance < startDistance) {\r\n                        startPoly = navPoly;\r\n                        startDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Same check as above, but for the end point\r\n        if (!endPoly && this._meshShrinkAmount > 0) {\r\n            for (const navPoly of this._navPolygons) {\r\n                r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n                d = navPoly.centroid.distance(endPoint);\r\n                if (d <= r) {\r\n                    const {distance}  = this._projectPointToPolygon(endPoint, navPoly);\r\n                    if (distance <= this._meshShrinkAmount && distance < endDistance) {\r\n                        endPoly = navPoly;\r\n                        endDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // No matching polygons locations for the start or end, so no path found\r\n        if (!startPoly || !endPoly) return null;\r\n        \r\n        // Search!\r\n        const astarPath = jsastar.astar.search(this._graph, startPoly, endPoly, {\r\n            heuristic: this._graph.navHeuristic\r\n        });\r\n        // jsastar drops the first point from the path, but the funnel algorithm needs it\r\n        astarPath.unshift(startPoly);\r\n        \r\n        // We have a path, so now time for the funnel algorithm\r\n        const channel = new Channel();\r\n        channel.push(startPoint);\r\n        for (let i = 0; i < astarPath.length - 1; i++) {\r\n            const navPolygon = astarPath[i];\r\n            const nextNavPolygon = astarPath[i + 1];\r\n\r\n            // Find the portal\r\n            let portal = null;\r\n            for (let i = 0; i < navPolygon.neighbors.length; i++) {\r\n                if (navPolygon.neighbors[i].id === nextNavPolygon.id) {\r\n                    portal = navPolygon.portals[i];\r\n                }\r\n            }\r\n\r\n            // Push the portal vertices into the channel\r\n            channel.push(portal.start, portal.end);\r\n        }\r\n        channel.push(endPoint);\r\n\r\n        // Pull a string along the channel to run the funnel\r\n        channel.stringPull();\r\n\r\n        // Clone path, excluding duplicates\r\n        let lastPoint = null;\r\n        const phaserPath = [];\r\n        for (const p of channel.path) {\r\n            const newPoint = p.clone();\r\n            if (!lastPoint || !newPoint.equals(lastPoint)) phaserPath.push(newPoint);\r\n            lastPoint = newPoint;\r\n        }\r\n\r\n        // Call debug drawing\r\n        if (drawPolyPath) {\r\n            const polyPath = astarPath.map((elem) => elem.centroid);\r\n            this.debugDrawPath(polyPath, 0x00ff00, 5);\r\n        }\r\n        if (drawFinalPath) this.debugDrawPath(phaserPath, 0xffd900, 10);\r\n\r\n        return phaserPath;\r\n    }\r\n\r\n    _calculateNeighbors() {\r\n        // Fill out the neighbor information for each navpoly\r\n        for (let i = 0; i < this._navPolygons.length; i++) {\r\n            const navPoly = this._navPolygons[i];\r\n\r\n            for (let j = i + 1; j < this._navPolygons.length; j++) {\r\n                const otherNavPoly = this._navPolygons[j];\r\n\r\n                // Check if the other navpoly is within range to touch\r\n                const d = navPoly.centroid.distance(otherNavPoly.centroid);\r\n                if (d > (navPoly.boundingRadius + otherNavPoly.boundingRadius)) continue;\r\n\r\n                // The are in range, so check each edge pairing\r\n                for (const edge of navPoly.edges) {\r\n                    for (const otherEdge of otherNavPoly.edges) {\r\n                        \r\n                        // If edges aren't collinear, not an option for connecting navpolys\r\n                        if (!areCollinear(edge, otherEdge)) continue;\r\n\r\n                        // If they are collinear, check if they overlap\r\n                        const overlap = this._getSegmentOverlap(edge, otherEdge);\r\n                        if (!overlap) continue;\r\n                        \r\n                        // Connections are symmetric!\r\n                        navPoly.neighbors.push(otherNavPoly);\r\n                        otherNavPoly.neighbors.push(navPoly);\r\n\r\n                        // Calculate the portal between the two polygons - this needs to be in\r\n                        // counter-clockwise order, relative to each polygon\r\n                        const [p1, p2] = overlap;\r\n                        let edgeStartAngle = navPoly.centroid.angle(edge.start);\r\n                        let a1 = navPoly.centroid.angle(overlap[0]);\r\n                        let a2 = navPoly.centroid.angle(overlap[1]);\r\n                        let d1 = angleDifference(edgeStartAngle, a1);\r\n                        let d2 = angleDifference(edgeStartAngle, a2);\r\n                        if (d1 < d2) {\r\n                            navPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n                        } else {\r\n                            navPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\r\n                        }\r\n\r\n                        edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);\r\n                        a1 = otherNavPoly.centroid.angle(overlap[0]);\r\n                        a2 = otherNavPoly.centroid.angle(overlap[1]);\r\n                        d1 = angleDifference(edgeStartAngle, a1);\r\n                        d2 = angleDifference(edgeStartAngle, a2);\r\n                        if (d1 < d2) {\r\n                            otherNavPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n                        } else {\r\n                            otherNavPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\r\n                        }\r\n                            \r\n                        // Two convex polygons shouldn't be connected more than once! (Unless\r\n                        // there are unnecessary vertices...)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check two collinear line segments to see if they overlap by sorting the points.\r\n    // Algorithm source: http://stackoverflow.com/a/17152247\r\n    _getSegmentOverlap(line1, line2) {\r\n        const points = [\r\n            {line: line1, point: line1.start}, \r\n            {line: line1, point: line1.end}, \r\n            {line: line2, point: line2.start}, \r\n            {line: line2, point: line2.end}\r\n        ]; \r\n        points.sort(function (a, b) {\r\n            if (a.point.x < b.point.x) return -1;\r\n            else if (a.point.x > b.point.x) return 1;\r\n            else {\r\n                if (a.point.y < b.point.y) return -1;\r\n                else if (a.point.y > b.point.y) return 1;\r\n                else return 0;\r\n            }\r\n        });\r\n        // If the first two points in the array come from the same line, no overlap\r\n        const noOverlap = points[0].line === points[1].line;\r\n        // If the two middle points in the array are the same coordinates, then there is a \r\n        // single point of overlap.\r\n        const singlePointOverlap = points[1].point.equals(points[2].point);\r\n        if (noOverlap || singlePointOverlap) return null;\r\n        else return [points[1].point, points[2].point];\r\n    }\r\n\r\n    /**\r\n     * Project a point onto a polygon in the shortest distance possible.\r\n     * \r\n     * @param {Phaser.Point} point The point to project\r\n     * @param {NavPoly} navPoly The navigation polygon to test against\r\n     * @returns {{point: Phaser.Point, distance: number}}\r\n     * \r\n     * @private\r\n     * @memberof NavMesh\r\n     */\r\n    _projectPointToPolygon(point, navPoly) {\r\n        let closestProjection = null;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        for (const edge of navPoly.edges) {\r\n            const projectedPoint = this._projectPointToEdge(point, edge);\r\n            const d = point.distance(projectedPoint);\r\n            if (closestProjection === null || d < closestDistance) {\r\n                closestDistance = d;\r\n                closestProjection = projectedPoint;\r\n            }\r\n        }\r\n        return {point: closestProjection, distance: closestDistance};\r\n    }\r\n\r\n    _distanceSquared(a, b) {\r\n        const dx = b.x - a.x;\r\n        const dy = b.y - a.y;\r\n        return dx * dx + dy * dy;\r\n    }\r\n\r\n    // Project a point onto a line segment\r\n    // JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\r\n    _projectPointToEdge(point, line) {\r\n        const a = line.start;\r\n        const b = line.end;\r\n        // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find\r\n        // where our point lies on the line by solving for t:\r\n        //  t = [(p-a) . (b-a)] / |b-a|^2\r\n        const l2 = this._distanceSquared(a, b);\r\n        let t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;\r\n        // We clamp t from [0,1] to handle points outside the segment vw.\r\n        t = Phaser.Math.clamp(t, 0, 1);\r\n        // Project onto the segment\r\n        const p = new Phaser.Point(\r\n            a.x + t * (b.x - a.x),\r\n            a.y + t * (b.y - a.y)\r\n        );\r\n        return p;        \r\n    }\r\n\r\n    /**\r\n     * Enable debug and create graphics overlay (if it hasn't already been created) \r\n     */\r\n    enableDebug() {\r\n        if (!this._debugGraphics) {\r\n            this._debugGraphics = this.game.add.graphics(0, 0);\r\n            this._debugGraphics.alpha = 0.5;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable debug and destroy associated graphics\r\n     */\r\n    disableDebug() {\r\n        if (this._debugGraphics) {\r\n            this._debugGraphics.destroy();\r\n            this._debugGraphics = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check whether debug is enabled\r\n     * \r\n     * @returns {boolean}\r\n     */\r\n    isDebugEnabled() {\r\n        return this._debugGraphics !== null;\r\n    }\r\n\r\n    /**\r\n     * Clear the debug overlay\r\n     */\r\n    debugClear() {\r\n        if (this._debugGraphics) this._debugGraphics.clear();\r\n    }\r\n    \r\n    /**\r\n     * Visualize the polygons in the nav mesh as an overlay on top of the game\r\n     *\r\n     * @param {object} options\r\n     * @param {boolean} [options.drawCentroid=true] For each polygon, show the approx centroid\r\n     * @param {boolean} [options.drawBounds=false] For each polygon, show the bounding radius\r\n     * @param {boolean} [options.drawNeighbors=true] For each polygon, show the connections to\r\n     * neighbors\r\n     * @param {boolean} [options.drawPortals=true] For each polygon, show the portal edges\r\n     */\r\n    debugDrawMesh({drawCentroid = true, drawBounds = false, drawNeighbors = true, \r\n            drawPortals = true} = {}) {\r\n        if (!this._debugGraphics) this.enableDebug();\r\n        // Visualize the navigation mesh\r\n        for (const navPoly of this._navPolygons) {\r\n            navPoly.draw(this._debugGraphics, drawCentroid, drawBounds, drawNeighbors, drawPortals);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Visualize a path (array of points) on the debug graphics overlay\r\n     * \r\n     * @param {Phaser.Point[]} path \r\n     * @param {number} [color=0x00FF00] \r\n     * @param {number} [thickness=10] \r\n     */\r\n    debugDrawPath(path, color = 0x00FF00, thickness = 10) {\r\n        if (!this._debugGraphics) this.enableDebug();\r\n        if (path.length) {\r\n            // Draw line for path\r\n            this._debugGraphics.lineStyle(thickness, color);\r\n            this._debugGraphics.drawShape(new Phaser.Polygon(...path)); \r\n            this._debugGraphics.beginFill(color);\r\n            // Draw circle at start and end of path\r\n            const d = 0.5 * thickness;\r\n            this._debugGraphics.drawEllipse(path[0].x, path[0].y, d, d);\r\n            const lastPoint = path[path.length - 1];\r\n            this._debugGraphics.drawEllipse(lastPoint.x, lastPoint.y, d, d);\r\n            this._debugGraphics.endFill();\r\n        }\r\n    }\r\n}\r\n\r\nexport default NavMesh;\n\n\n// WEBPACK FOOTER //\n// ./nav-mesh.js","// Debug color palette\r\nconst palette = [0x00A0B0, 0x6A4A3C, 0xCC333F, 0xEB6841, 0xEDC951];\r\n\r\n/**\r\n * A class that represents a navigable polygon in a navmesh. It is build from a Phaser.Polygon. It\r\n * has a drawing function to help visualize it's features:\r\n *  - polygon\r\n *  - neighbors - any navpolys that can be reached from this navpoly\r\n *  - portals - overlapping edges between neighbors\r\n *  - centroid - not a true centroid, just an approximation.\r\n *  - boundingRadius - the radius of a circle at the centroid that fits all the points of the poly \r\n * \r\n * It implements the properties and fields that javascript-astar needs - weight, toString, isWall\r\n * and getCost. See GPS test from astar repo for structure: \r\n * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavPoly\r\n * @private\r\n */\r\nclass NavPoly {\r\n    /**\r\n     * Creates an instance of NavPoly.\r\n     * @param {Phaser.Game} game \r\n     * @param {number} id \r\n     * @param {Phaser.Polygon} polygon \r\n     * \r\n     * @memberof NavPoly\r\n     */\r\n    constructor(game, id, polygon) {\r\n        this.game = game;\r\n        this.id = id;\r\n        this.polygon = polygon;\r\n        this.edges = this._calculateEdges();\r\n        this.neighbors = [];\r\n        this.portals = [];\r\n        this.centroid = this._calculateCentroid();\r\n        this.boundingRadius = this._calculateRadius();\r\n\r\n        this.weight = 1; // jsastar property\r\n        \r\n        const i = this.id % palette.length;\r\n        this._color = palette[i];\r\n    }\r\n\r\n    constains(point) {\r\n        return this.polygon.contains(point.x, point.y);\r\n    }\r\n\r\n    destroy() {\r\n        this.game = null;\r\n        this.neighbors = [];\r\n        this.portals = [];\r\n    }\r\n\r\n    // jsastar methods\r\n    toString() {\r\n        return `NavPoly(id: ${this.id} at: ${this.centroid})`;\r\n    }\r\n    isWall() {\r\n        return this.weight === 0;\r\n    }\r\n    centroidDistance(navPolygon) {\r\n        return this.centroid.distance(navPolygon.centroid);\r\n    }\r\n    getCost(navPolygon) {\r\n        return this.centroidDistance(navPolygon);\r\n    }\r\n\r\n    _calculateEdges() {\r\n        const points = this.polygon.points;\r\n        const edges = [];\r\n        for (let i = 1; i < points.length; i++) {\r\n            const p1 = points[i - 1];\r\n            const p2 = points[i];\r\n            edges.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n        }\r\n        const first = points[0];\r\n        const last = points[points.length - 1]\r\n        edges.push(new Phaser.Line(first.x, first.y, last.x, last.y));\r\n        return edges;\r\n    }\r\n    \r\n    _calculateCentroid() {\r\n        // NOTE: this is not actually the centroid, it's the average of the vertices - not the same\r\n        // thing!\r\n        const centroid = new Phaser.Point(0, 0);\r\n        const length = this.polygon.points.length;\r\n        for (const point of this.polygon.points) {\r\n            centroid.add(point.x, point.y);\r\n        }\r\n        centroid.divide(length, length);\r\n        return centroid;\r\n    }\r\n\r\n    _calculateRadius() {\r\n        let boundingRadius = 0;\r\n        for (const point of this.polygon.points) {\r\n            const d = this.centroid.distance(point);\r\n            if (d > boundingRadius) boundingRadius = d;\r\n        }\r\n        return boundingRadius;\r\n    }\r\n\r\n    /**\r\n     * Draw the polygon to given graphics object\r\n     * \r\n     * @param {Phaser.Graphics} graphics \r\n     * @param {boolean} [drawCentroid=true] Show the approx centroid\r\n     * @param {boolean} [drawBounds=false] Show the bounding radius\r\n     * @param {boolean} [drawNeighbors=true] Show the connections to neighbors\r\n     * @param {boolean} [drawPortals=true] Show the portal edges\r\n     * \r\n     * @memberof NavPoly\r\n     */\r\n    draw(graphics, drawCentroid = true, drawBounds = false, drawNeighbors = true, \r\n            drawPortals = true) {\r\n        graphics.lineWidth = 0;\r\n        graphics.beginFill(this._color);\r\n        graphics.drawPolygon(this.polygon);\r\n        graphics.endFill();\r\n\r\n        if (drawCentroid) {\r\n            graphics.beginFill(0x000000);\r\n            graphics.drawEllipse(this.centroid.x, this.centroid.y, 4, 4);\r\n            graphics.endFill();\r\n        }\r\n\r\n        if (drawBounds) {\r\n            graphics.lineStyle(1, 0xFFFFFF);\r\n            const r = this.boundingRadius;\r\n            graphics.drawEllipse(this.centroid.x, this.centroid.y, r, r);\r\n        }\r\n\r\n        if (drawNeighbors) {\r\n            graphics.lineStyle(2, 0x000000);\r\n            for (const n of this.neighbors) {\r\n                graphics.moveTo(this.centroid.x, this.centroid.y);\r\n                graphics.lineTo(n.centroid.x, n.centroid.y);\r\n            }\r\n        }\r\n\r\n        if (drawPortals) {\r\n            graphics.lineStyle(10, 0x000000);\r\n            for (const p of this.portals) {\r\n                graphics.moveTo(p.start.x, p.start.y);\r\n                graphics.lineTo(p.end.x, p.end.y);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default NavPoly;\n\n\n// WEBPACK FOOTER //\n// ./nav-poly.js"],"sourceRoot":""}