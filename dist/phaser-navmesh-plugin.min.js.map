{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///phaser-navmesh-plugin.min.js","webpack:///webpack/bootstrap b3956335bfed79eef32c?9a56","webpack:///./utils.js?e8fb","webpack:///E:/Github/navmesh-phaser-plugin/~/javascript-astar/astar.js?e4f8","webpack:///./nav-mesh.js?f576","webpack:///./channel.js?5df9","webpack:///./index.js?2645","webpack:///./nav-graph.js?63ca","webpack:///./nav-poly.js?b51a"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","triarea2","a","b","ax","x","ay","y","almostEqual","value1","value2","errorMargin","arguments","length","undefined","Math","abs","angleDifference","PI","j","floor","areCollinear","line1","line2","area1","start","end","area2","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","definition","apply","pathTo","node","curr","path","parent","unshift","getHeap","BinaryHeap","f","Graph","gridIn","options","nodes","diagonal","grid","row","GridNode","push","init","weight","scoreFunction","content","astar","search","graph","cleanDirty","heuristic","heuristics","manhattan","closest","openHeap","closestNode","h","markDirty","size","currentNode","pop","closed","neighbors","il","neighbor","isWall","gScore","g","getCost","beenVisited","visited","rescoreElement","pos0","pos1","D2","sqrt","d1","d2","min","cleanNode","dirtyNodes","ret","toString","graphString","rowDebug","join","fromNeighbor","element","sinkDown","result","bubbleUp","remove","indexOf","parentN","elemScore","child1Score","child2N","child1N","swap","child1","child2","_toConsumableArray","arr","Array","isArray","arr2","from","_classCallCheck","instance","Constructor","TypeError","__WEBPACK_IMPORTED_MODULE_0_javascript_astar__","__WEBPACK_IMPORTED_MODULE_0_javascript_astar___default","__WEBPACK_IMPORTED_MODULE_1__nav_poly__","__WEBPACK_IMPORTED_MODULE_2__nav_graph__","__WEBPACK_IMPORTED_MODULE_3__channel__","__WEBPACK_IMPORTED_MODULE_4__utils__","_slicedToArray","sliceIterator","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","err","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","NavMesh","game","polygons","meshShrinkAmount","_debugGraphics","_meshShrinkAmount","_navPolygons","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","entries","_ref","_ref2","polygon","return","_calculateNeighbors","startPoint","endPoint","_ref3","_ref3$drawPolyPath","drawPolyPath","_ref3$drawFinalPath","drawFinalPath","startPoly","endPoly","startDistance","Number","MAX_VALUE","endDistance","r","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","navPoly","boundingRadius","centroid","distance","constains","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_projectPointToPolygo","_projectPointToPolygon","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_projectPointToPolygo2","astarPath","navHeuristic","channel","navPolygon","nextNavPolygon","portal","id","portals","stringPull","lastPoint","phaserPath","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","newPoint","clone","equals","debugDraw","otherNavPoly","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","edges","edge","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","otherEdge","overlap","_getSegmentOverlap","_overlap","p1","p2","edgeStartAngle","angle","a1","a2","Phaser","Line","points","line","point","sort","noOverlap","singlePointOverlap","closestProjection","closestDistance","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_iterator8","projectedPoint","_projectPointToEdge","dx","dy","l2","_distanceSquared","t","clamp","Point","add","graphics","alpha","destroy","clear","_ref4","_ref4$drawCentroid","drawCentroid","_ref4$drawBounds","drawBounds","_ref4$drawNeighbors","drawNeighbors","_ref4$drawPortals","drawPortals","enableDebug","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_step9","_iterator9","draw","polyPath","funnelPath","lineStyle","moveTo","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_step10","_iterator10","lineTo","lastPoly","Polygon","concat","drawShape","beginFill","drawEllipse","endFill","__WEBPACK_IMPORTED_MODULE_0__utils__","Channel","left","right","portalApex","portalLeft","portalRight","pts","apexIndex","leftIndex","rightIndex","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0__nav_mesh__","NavMeshPlugin","_Phaser$Plugin","manager","_this","getPrototypeOf","_pluginManager","_navmeshes","_currentLevel","levelName","tilemap","objectKey","rects","objects","top","bottom","height","width","poly","navMesh","_currentNavMesh","findPath","Plugin","NavGraph","navPolygons","navPolygon1","navPolygon2","centroidDistance","palette","NavPoly","_calculateEdges","_calculateCentroid","_calculateRadius","_color","contains","first","last","divide","lineWidth","drawPolygon"],"mappings":"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","file":"phaser-navmesh-plugin.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"phaserNavmeshPlugin\"] = factory();\n\telse\n\t\troot[\"phaserNavmeshPlugin\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"phaserNavmeshPlugin\"] = factory();\n\telse\n\t\troot[\"phaserNavmeshPlugin\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = triarea2;\n/* unused harmony export almostEqual */\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = angleDifference;\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = areCollinear;\n// Twice the area of the triangle formed by a, b and c\nfunction triarea2(a, b, c) {\n    var ax = b.x - a.x;\n    var ay = b.y - a.y;\n    var bx = c.x - a.x;\n    var by = c.y - a.y;\n    return bx * ay - ax * by;\n}\n\nfunction almostEqual(value1, value2) {\n    var errorMargin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0001;\n\n    if (Math.abs(value1 - value2) <= errorMargin) return true;else return false;\n}\n\n// https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0\nfunction angleDifference(x, y) {\n    var a = x - y;\n    var i = a + Math.PI;\n    var j = Math.PI * 2;\n    a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign\n    a -= Math.PI;\n    return a;\n}\n\nfunction areCollinear(line1, line2) {\n    var errorMargin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0001;\n\n    // Figure out if the two lines are equal by looking at the area of the triangle formed\n    // by their points\n    var area1 = triarea2(line1.start, line1.end, line2.start);\n    var area2 = triarea2(line1.start, line1.end, line2.end);\n    if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {\n        return true;\n    } else return false;\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// javascript-astar 0.4.2\r\n// http://github.com/bgrins/javascript-astar\r\n// Freely distributable under the MIT License.\r\n// Implements the astar search algorithm in javascript using a Binary Heap.\r\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\r\n// http://eloquentjavascript.net/appendix2.html\r\n(function(definition) {\r\n  /* global module, define */\r\n  if (typeof module === 'object' && typeof module.exports === 'object') {\r\n    module.exports = definition();\r\n  } else if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n  } else {\r\n    var exports = definition();\r\n    window.astar = exports.astar;\r\n    window.Graph = exports.Graph;\r\n  }\r\n})(function() {\r\n\r\nfunction pathTo(node) {\r\n  var curr = node;\r\n  var path = [];\r\n  while (curr.parent) {\r\n    path.unshift(curr);\r\n    curr = curr.parent;\r\n  }\r\n  return path;\r\n}\r\n\r\nfunction getHeap() {\r\n  return new BinaryHeap(function(node) {\r\n    return node.f;\r\n  });\r\n}\r\n\r\nvar astar = {\r\n  /**\r\n  * Perform an A* Search on a graph given a start and end node.\r\n  * @param {Graph} graph\r\n  * @param {GridNode} start\r\n  * @param {GridNode} end\r\n  * @param {Object} [options]\r\n  * @param {bool} [options.closest] Specifies whether to return the\r\n             path to the closest node if the target is unreachable.\r\n  * @param {Function} [options.heuristic] Heuristic function (see\r\n  *          astar.heuristics).\r\n  */\r\n  search: function(graph, start, end, options) {\r\n    graph.cleanDirty();\r\n    options = options || {};\r\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\r\n    var closest = options.closest || false;\r\n\r\n    var openHeap = getHeap();\r\n    var closestNode = start; // set the start node to be the closest if required\r\n\r\n    start.h = heuristic(start, end);\r\n    graph.markDirty(start);\r\n\r\n    openHeap.push(start);\r\n\r\n    while (openHeap.size() > 0) {\r\n\r\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\r\n      var currentNode = openHeap.pop();\r\n\r\n      // End case -- result has been found, return the traced path.\r\n      if (currentNode === end) {\r\n        return pathTo(currentNode);\r\n      }\r\n\r\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\r\n      currentNode.closed = true;\r\n\r\n      // Find all neighbors for the current node.\r\n      var neighbors = graph.neighbors(currentNode);\r\n\r\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\r\n        var neighbor = neighbors[i];\r\n\r\n        if (neighbor.closed || neighbor.isWall()) {\r\n          // Not a valid node to process, skip to next neighbor.\r\n          continue;\r\n        }\r\n\r\n        // The g score is the shortest distance from start to current node.\r\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\r\n        var gScore = currentNode.g + neighbor.getCost(currentNode);\r\n        var beenVisited = neighbor.visited;\r\n\r\n        if (!beenVisited || gScore < neighbor.g) {\r\n\r\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\r\n          neighbor.visited = true;\r\n          neighbor.parent = currentNode;\r\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\r\n          neighbor.g = gScore;\r\n          neighbor.f = neighbor.g + neighbor.h;\r\n          graph.markDirty(neighbor);\r\n          if (closest) {\r\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\r\n            // a cheaper path than the current closest node then it becomes the closest node\r\n            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\r\n              closestNode = neighbor;\r\n            }\r\n          }\r\n\r\n          if (!beenVisited) {\r\n            // Pushing to heap will put it in proper place based on the 'f' value.\r\n            openHeap.push(neighbor);\r\n          } else {\r\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\r\n            openHeap.rescoreElement(neighbor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (closest) {\r\n      return pathTo(closestNode);\r\n    }\r\n\r\n    // No result was found - empty array signifies failure to find path.\r\n    return [];\r\n  },\r\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\r\n  heuristics: {\r\n    manhattan: function(pos0, pos1) {\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return d1 + d2;\r\n    },\r\n    diagonal: function(pos0, pos1) {\r\n      var D = 1;\r\n      var D2 = Math.sqrt(2);\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\r\n    }\r\n  },\r\n  cleanNode: function(node) {\r\n    node.f = 0;\r\n    node.g = 0;\r\n    node.h = 0;\r\n    node.visited = false;\r\n    node.closed = false;\r\n    node.parent = null;\r\n  }\r\n};\r\n\r\n/**\r\n * A graph memory structure\r\n * @param {Array} gridIn 2D array of input weights\r\n * @param {Object} [options]\r\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\r\n */\r\nfunction Graph(gridIn, options) {\r\n  options = options || {};\r\n  this.nodes = [];\r\n  this.diagonal = !!options.diagonal;\r\n  this.grid = [];\r\n  for (var x = 0; x < gridIn.length; x++) {\r\n    this.grid[x] = [];\r\n\r\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\r\n      var node = new GridNode(x, y, row[y]);\r\n      this.grid[x][y] = node;\r\n      this.nodes.push(node);\r\n    }\r\n  }\r\n  this.init();\r\n}\r\n\r\nGraph.prototype.init = function() {\r\n  this.dirtyNodes = [];\r\n  for (var i = 0; i < this.nodes.length; i++) {\r\n    astar.cleanNode(this.nodes[i]);\r\n  }\r\n};\r\n\r\nGraph.prototype.cleanDirty = function() {\r\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\r\n    astar.cleanNode(this.dirtyNodes[i]);\r\n  }\r\n  this.dirtyNodes = [];\r\n};\r\n\r\nGraph.prototype.markDirty = function(node) {\r\n  this.dirtyNodes.push(node);\r\n};\r\n\r\nGraph.prototype.neighbors = function(node) {\r\n  var ret = [];\r\n  var x = node.x;\r\n  var y = node.y;\r\n  var grid = this.grid;\r\n\r\n  // West\r\n  if (grid[x - 1] && grid[x - 1][y]) {\r\n    ret.push(grid[x - 1][y]);\r\n  }\r\n\r\n  // East\r\n  if (grid[x + 1] && grid[x + 1][y]) {\r\n    ret.push(grid[x + 1][y]);\r\n  }\r\n\r\n  // South\r\n  if (grid[x] && grid[x][y - 1]) {\r\n    ret.push(grid[x][y - 1]);\r\n  }\r\n\r\n  // North\r\n  if (grid[x] && grid[x][y + 1]) {\r\n    ret.push(grid[x][y + 1]);\r\n  }\r\n\r\n  if (this.diagonal) {\r\n    // Southwest\r\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\r\n      ret.push(grid[x - 1][y - 1]);\r\n    }\r\n\r\n    // Southeast\r\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\r\n      ret.push(grid[x + 1][y - 1]);\r\n    }\r\n\r\n    // Northwest\r\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\r\n      ret.push(grid[x - 1][y + 1]);\r\n    }\r\n\r\n    // Northeast\r\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\r\n      ret.push(grid[x + 1][y + 1]);\r\n    }\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nGraph.prototype.toString = function() {\r\n  var graphString = [];\r\n  var nodes = this.grid;\r\n  for (var x = 0; x < nodes.length; x++) {\r\n    var rowDebug = [];\r\n    var row = nodes[x];\r\n    for (var y = 0; y < row.length; y++) {\r\n      rowDebug.push(row[y].weight);\r\n    }\r\n    graphString.push(rowDebug.join(\" \"));\r\n  }\r\n  return graphString.join(\"\\n\");\r\n};\r\n\r\nfunction GridNode(x, y, weight) {\r\n  this.x = x;\r\n  this.y = y;\r\n  this.weight = weight;\r\n}\r\n\r\nGridNode.prototype.toString = function() {\r\n  return \"[\" + this.x + \" \" + this.y + \"]\";\r\n};\r\n\r\nGridNode.prototype.getCost = function(fromNeighbor) {\r\n  // Take diagonal weight into consideration.\r\n  if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\r\n    return this.weight * 1.41421;\r\n  }\r\n  return this.weight;\r\n};\r\n\r\nGridNode.prototype.isWall = function() {\r\n  return this.weight === 0;\r\n};\r\n\r\nfunction BinaryHeap(scoreFunction) {\r\n  this.content = [];\r\n  this.scoreFunction = scoreFunction;\r\n}\r\n\r\nBinaryHeap.prototype = {\r\n  push: function(element) {\r\n    // Add the new element to the end of the array.\r\n    this.content.push(element);\r\n\r\n    // Allow it to sink down.\r\n    this.sinkDown(this.content.length - 1);\r\n  },\r\n  pop: function() {\r\n    // Store the first element so we can return it later.\r\n    var result = this.content[0];\r\n    // Get the element at the end of the array.\r\n    var end = this.content.pop();\r\n    // If there are any elements left, put the end element at the\r\n    // start, and let it bubble up.\r\n    if (this.content.length > 0) {\r\n      this.content[0] = end;\r\n      this.bubbleUp(0);\r\n    }\r\n    return result;\r\n  },\r\n  remove: function(node) {\r\n    var i = this.content.indexOf(node);\r\n\r\n    // When it is found, the process seen in 'pop' is repeated\r\n    // to fill up the hole.\r\n    var end = this.content.pop();\r\n\r\n    if (i !== this.content.length - 1) {\r\n      this.content[i] = end;\r\n\r\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n        this.sinkDown(i);\r\n      } else {\r\n        this.bubbleUp(i);\r\n      }\r\n    }\r\n  },\r\n  size: function() {\r\n    return this.content.length;\r\n  },\r\n  rescoreElement: function(node) {\r\n    this.sinkDown(this.content.indexOf(node));\r\n  },\r\n  sinkDown: function(n) {\r\n    // Fetch the element that has to be sunk.\r\n    var element = this.content[n];\r\n\r\n    // When at 0, an element can not sink any further.\r\n    while (n > 0) {\r\n\r\n      // Compute the parent element's index, and fetch it.\r\n      var parentN = ((n + 1) >> 1) - 1;\r\n      var parent = this.content[parentN];\r\n      // Swap the elements if the parent is greater.\r\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n        this.content[parentN] = element;\r\n        this.content[n] = parent;\r\n        // Update 'n' to continue at the new position.\r\n        n = parentN;\r\n      }\r\n      // Found a parent that is less, no need to sink any further.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  },\r\n  bubbleUp: function(n) {\r\n    // Look up the target element and its score.\r\n    var length = this.content.length;\r\n    var element = this.content[n];\r\n    var elemScore = this.scoreFunction(element);\r\n\r\n    while (true) {\r\n      // Compute the indices of the child elements.\r\n      var child2N = (n + 1) << 1;\r\n      var child1N = child2N - 1;\r\n      // This is used to store the new position of the element, if any.\r\n      var swap = null;\r\n      var child1Score;\r\n      // If the first child exists (is inside the array)...\r\n      if (child1N < length) {\r\n        // Look it up and compute its score.\r\n        var child1 = this.content[child1N];\r\n        child1Score = this.scoreFunction(child1);\r\n\r\n        // If the score is less than our element's, we need to swap.\r\n        if (child1Score < elemScore) {\r\n          swap = child1N;\r\n        }\r\n      }\r\n\r\n      // Do the same checks for the other child.\r\n      if (child2N < length) {\r\n        var child2 = this.content[child2N];\r\n        var child2Score = this.scoreFunction(child2);\r\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\r\n          swap = child2N;\r\n        }\r\n      }\r\n\r\n      // If the element needs to be moved, swap it, and continue.\r\n      if (swap !== null) {\r\n        this.content[n] = this.content[swap];\r\n        this.content[swap] = element;\r\n        n = swap;\r\n      }\r\n      // Otherwise, we are done.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nreturn {\r\n  astar: astar,\r\n  Graph: Graph\r\n};\r\n\r\n});\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_javascript_astar__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_javascript_astar__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__nav_poly__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__nav_graph__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__channel__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils__ = __webpack_require__(0);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\n\n\n/**\r\n * The workhorse that builds a navigation mesh from a series of polygons. Once built, the mesh can\r\n * be asked for a path from one point to another point. It has debug methods for visualizing paths\r\n * and visualizing the individual polygons. Some internal terminology usage:\r\n * \r\n * - neighbor: a polygon that shares part of an edge with another polygon\r\n * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment\r\n * - channel: the path of polygons from starting point to end point\r\n * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the\r\n *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut\r\n * \r\n * @class NavMesh\r\n */\n\nvar NavMesh = function () {\n\n    /**\r\n     * Creates an instance of NavMesh.\r\n     * @param {Phaser.Game} game\r\n     * @param {Phaser.Polygon[]} polygons\r\n     * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n     * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n     *\r\n     * @memberof NavMesh\r\n     */\n    function NavMesh(game, polygons) {\n        var meshShrinkAmount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n        _classCallCheck(this, NavMesh);\n\n        this.game = game;\n        this._debugGraphics = null;\n        this._meshShrinkAmount = meshShrinkAmount;\n\n        // Construct NavPoly instances for each polygon\n        this._navPolygons = [];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = polygons.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var _ref = _step.value;\n\n                var _ref2 = _slicedToArray(_ref, 2);\n\n                var i = _ref2[0];\n                var polygon = _ref2[1];\n\n                this._navPolygons.push(new __WEBPACK_IMPORTED_MODULE_1__nav_poly__[\"a\" /* default */](game, i, polygon));\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        this._calculateNeighbors();\n\n        // Astar graph of connections between polygons\n        this.graph = new __WEBPACK_IMPORTED_MODULE_2__nav_graph__[\"a\" /* default */](this._navPolygons);\n    }\n\n    /**\r\n     * Find a path from the start point to the end point using this nav mesh.\r\n     *\r\n     * @param {Phaser.Point} startPoint\r\n     * @param {Phaser.Point} endPoint\r\n     * @param {object} [drawOptions={}] Options for controlling debug drawing\r\n     * @param {boolean} [drawOptions.drawPolyPath=false] Whether or not to visualize the path\r\n     * through the polygons - e.g. the path that astar found.\r\n     * @param {boolean} [drawOptions.drawFinalPath=false] Whether or not to visualize the path\r\n     * through the path that was returned.\r\n     * @returns {Phaser.Point[]|null} An array of points if a path is found, or null if no path\r\n     *\r\n     * @memberof NavMesh\r\n     */\n\n\n    _createClass(NavMesh, [{\n        key: \"findPath\",\n        value: function findPath(startPoint, endPoint) {\n            var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n                _ref3$drawPolyPath = _ref3.drawPolyPath,\n                drawPolyPath = _ref3$drawPolyPath === undefined ? false : _ref3$drawPolyPath,\n                _ref3$drawFinalPath = _ref3.drawFinalPath,\n                drawFinalPath = _ref3$drawFinalPath === undefined ? false : _ref3$drawFinalPath;\n\n            var startPoly = null;\n            var endPoly = null;\n            var startDistance = Number.MAX_VALUE;\n            var endDistance = Number.MAX_VALUE;\n            var d = void 0,\n                r = void 0;\n\n            // Find the closest poly for the starting and ending point\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this._navPolygons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var navPoly = _step2.value;\n\n                    r = navPoly.boundingRadius;\n                    // Start\n                    d = navPoly.centroid.distance(startPoint);\n                    if (d <= startDistance && d <= r && navPoly.constains(startPoint)) {\n                        startPoly = navPoly;\n                        startDistance = d;\n                    }\n                    // End\n                    d = navPoly.centroid.distance(endPoint);\n                    if (d <= endDistance && d <= r && navPoly.constains(endPoint)) {\n                        endPoly = navPoly;\n                        endDistance = d;\n                    }\n                }\n\n                // If the start point wasn't inside a polygon, run a more liberal check that allows a point\n                // to be within meshShrinkAmount radius of a polygon\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            if (!startPoly && this._meshShrinkAmount > 0) {\n                var _iteratorNormalCompletion3 = true;\n                var _didIteratorError3 = false;\n                var _iteratorError3 = undefined;\n\n                try {\n                    for (var _iterator3 = this._navPolygons[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                        var _navPoly = _step3.value;\n\n                        // Check if point is within bounding circle to avoid extra projection calculations\n                        r = _navPoly.boundingRadius + this._meshShrinkAmount;\n                        d = _navPoly.centroid.distance(startPoint);\n                        if (d <= r) {\n                            // Check if projected point is within range of a polgyon and is closer than the\n                            // previous point\n                            var _projectPointToPolygo = this._projectPointToPolygon(startPoint, _navPoly),\n                                distance = _projectPointToPolygo.distance;\n\n                            if (distance <= this._meshShrinkAmount && distance < startDistance) {\n                                startPoly = _navPoly;\n                                startDistance = distance;\n                            }\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                            _iterator3.return();\n                        }\n                    } finally {\n                        if (_didIteratorError3) {\n                            throw _iteratorError3;\n                        }\n                    }\n                }\n            }\n\n            // Same check as above, but for the end point\n            if (!endPoly && this._meshShrinkAmount > 0) {\n                var _iteratorNormalCompletion4 = true;\n                var _didIteratorError4 = false;\n                var _iteratorError4 = undefined;\n\n                try {\n                    for (var _iterator4 = this._navPolygons[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                        var _navPoly2 = _step4.value;\n\n                        r = _navPoly2.boundingRadius + this._meshShrinkAmount;\n                        d = _navPoly2.centroid.distance(endPoint);\n                        if (d <= r) {\n                            var _projectPointToPolygo2 = this._projectPointToPolygon(endPoint, _navPoly2),\n                                _distance = _projectPointToPolygo2.distance;\n\n                            if (_distance <= this._meshShrinkAmount && _distance < endDistance) {\n                                endPoly = _navPoly2;\n                                endDistance = _distance;\n                            }\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError4 = true;\n                    _iteratorError4 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                            _iterator4.return();\n                        }\n                    } finally {\n                        if (_didIteratorError4) {\n                            throw _iteratorError4;\n                        }\n                    }\n                }\n            }\n\n            // No matching polygons locations for the start or end, so no path found\n            if (!startPoly || !endPoly) return null;\n\n            // Search!\n            var astarPath = __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default.a.astar.search(this.graph, startPoly, endPoly, {\n                heuristic: this.graph.navHeuristic\n            });\n            // jsastar drops the first point from the path, but the funnel algorithm needs it\n            astarPath.unshift(startPoly);\n\n            // We have a path, so now time for the funnel algorithm\n            var channel = new __WEBPACK_IMPORTED_MODULE_3__channel__[\"a\" /* default */]();\n            channel.push(startPoint);\n            for (var i = 0; i < astarPath.length - 1; i++) {\n                var navPolygon = astarPath[i];\n                var nextNavPolygon = astarPath[i + 1];\n\n                // Find the portal\n                var portal = null;\n                for (var _i = 0; _i < navPolygon.neighbors.length; _i++) {\n                    if (navPolygon.neighbors[_i].id === nextNavPolygon.id) {\n                        portal = navPolygon.portals[_i];\n                    }\n                }\n\n                // Push the portal vertices into the channel\n                channel.push(portal.start, portal.end);\n            }\n            channel.push(endPoint);\n\n            // Pull a string along the channel to run the funnel\n            channel.stringPull();\n\n            // Clone path, excluding duplicates\n            var lastPoint = null;\n            var phaserPath = [];\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n                for (var _iterator5 = channel.path[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var p = _step5.value;\n\n                    var newPoint = p.clone();\n                    if (!lastPoint || !newPoint.equals(lastPoint)) phaserPath.push(newPoint);\n                    lastPoint = newPoint;\n                }\n\n                // Call debug drawing\n            } catch (err) {\n                _didIteratorError5 = true;\n                _iteratorError5 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                        _iterator5.return();\n                    }\n                } finally {\n                    if (_didIteratorError5) {\n                        throw _iteratorError5;\n                    }\n                }\n            }\n\n            if (drawFinalPath || drawPolyPath) {\n                this.debugDraw(drawPolyPath ? astarPath : null, drawFinalPath ? phaserPath : null);\n            }\n\n            return phaserPath;\n        }\n    }, {\n        key: \"_calculateNeighbors\",\n        value: function _calculateNeighbors() {\n            // Fill out the neighbor information for each navpoly\n            for (var i = 0; i < this._navPolygons.length; i++) {\n                var navPoly = this._navPolygons[i];\n\n                for (var j = i + 1; j < this._navPolygons.length; j++) {\n                    var otherNavPoly = this._navPolygons[j];\n\n                    // Check if the other navpoly is within range to touch\n                    var d = navPoly.centroid.distance(otherNavPoly.centroid);\n                    if (d > navPoly.boundingRadius + otherNavPoly.boundingRadius) continue;\n\n                    // The are in range, so check each edge pairing\n                    var _iteratorNormalCompletion6 = true;\n                    var _didIteratorError6 = false;\n                    var _iteratorError6 = undefined;\n\n                    try {\n                        for (var _iterator6 = navPoly.edges[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                            var edge = _step6.value;\n                            var _iteratorNormalCompletion7 = true;\n                            var _didIteratorError7 = false;\n                            var _iteratorError7 = undefined;\n\n                            try {\n                                for (var _iterator7 = otherNavPoly.edges[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                                    var otherEdge = _step7.value;\n\n\n                                    // If edges aren't collinear, not an option for connecting navpolys\n                                    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__[\"a\" /* areCollinear */])(edge, otherEdge)) continue;\n\n                                    // If they are collinear, check if they overlap\n                                    var overlap = this._getSegmentOverlap(edge, otherEdge);\n                                    if (!overlap) continue;\n\n                                    // Connections are symmetric!\n                                    navPoly.neighbors.push(otherNavPoly);\n                                    otherNavPoly.neighbors.push(navPoly);\n\n                                    // Calculate the portal between the two polygons - this needs to be in\n                                    // counter-clockwise order, relative to each polygon\n\n                                    var _overlap = _slicedToArray(overlap, 2),\n                                        p1 = _overlap[0],\n                                        p2 = _overlap[1];\n\n                                    var edgeStartAngle = navPoly.centroid.angle(edge.start);\n                                    var a1 = navPoly.centroid.angle(overlap[0]);\n                                    var a2 = navPoly.centroid.angle(overlap[1]);\n                                    var d1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__[\"b\" /* angleDifference */])(edgeStartAngle, a1);\n                                    var d2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__[\"b\" /* angleDifference */])(edgeStartAngle, a2);\n                                    if (d1 < d2) {\n                                        navPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\n                                    } else {\n                                        navPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\n                                    }\n\n                                    edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);\n                                    a1 = otherNavPoly.centroid.angle(overlap[0]);\n                                    a2 = otherNavPoly.centroid.angle(overlap[1]);\n                                    d1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__[\"b\" /* angleDifference */])(edgeStartAngle, a1);\n                                    d2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__[\"b\" /* angleDifference */])(edgeStartAngle, a2);\n                                    if (d1 < d2) {\n                                        otherNavPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\n                                    } else {\n                                        otherNavPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\n                                    }\n\n                                    // Two convex polygons shouldn't be connected more than once! (Unless\n                                    // there are unnecessary vertices...)\n                                }\n                            } catch (err) {\n                                _didIteratorError7 = true;\n                                _iteratorError7 = err;\n                            } finally {\n                                try {\n                                    if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                                        _iterator7.return();\n                                    }\n                                } finally {\n                                    if (_didIteratorError7) {\n                                        throw _iteratorError7;\n                                    }\n                                }\n                            }\n                        }\n                    } catch (err) {\n                        _didIteratorError6 = true;\n                        _iteratorError6 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                                _iterator6.return();\n                            }\n                        } finally {\n                            if (_didIteratorError6) {\n                                throw _iteratorError6;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Check two collinear line segments to see if they overlap by sorting the points.\n        // Algorithm source: http://stackoverflow.com/a/17152247\n\n    }, {\n        key: \"_getSegmentOverlap\",\n        value: function _getSegmentOverlap(line1, line2) {\n            var points = [{ line: line1, point: line1.start }, { line: line1, point: line1.end }, { line: line2, point: line2.start }, { line: line2, point: line2.end }];\n            points.sort(function (a, b) {\n                if (a.point.x < b.point.x) return -1;else if (a.point.x > b.point.x) return 1;else {\n                    if (a.point.y < b.point.y) return -1;else if (a.point.y > b.point.y) return 1;else return 0;\n                }\n            });\n            // If the first two points in the array come from the same line, no overlap\n            var noOverlap = points[0].line === points[1].line;\n            // If the two middle points in the array are the same coordinates, then there is a \n            // single point of overlap.\n            var singlePointOverlap = points[1].point.equals(points[2].point);\n            if (noOverlap || singlePointOverlap) return null;else return [points[1].point, points[2].point];\n        }\n\n        /**\r\n         * Project a point onto a polygon in the shortest distance possible.\r\n         * \r\n         * @param {Phaser.Point} point The point to project\r\n         * @param {NavPoly} navPoly The navigation polygon to test against\r\n         * @returns {{point: Phaser.Point, distance: number}}\r\n         * \r\n         * @memberof NavMesh\r\n         */\n\n    }, {\n        key: \"_projectPointToPolygon\",\n        value: function _projectPointToPolygon(point, navPoly) {\n            var closestProjection = null;\n            var closestDistance = Number.MAX_VALUE;\n            var _iteratorNormalCompletion8 = true;\n            var _didIteratorError8 = false;\n            var _iteratorError8 = undefined;\n\n            try {\n                for (var _iterator8 = navPoly.edges[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                    var edge = _step8.value;\n\n                    var projectedPoint = this._projectPointToEdge(point, edge);\n                    var d = point.distance(projectedPoint);\n                    if (closestProjection === null || d < closestDistance) {\n                        closestDistance = d;\n                        closestProjection = projectedPoint;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError8 = true;\n                _iteratorError8 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                        _iterator8.return();\n                    }\n                } finally {\n                    if (_didIteratorError8) {\n                        throw _iteratorError8;\n                    }\n                }\n            }\n\n            return { point: closestProjection, distance: closestDistance };\n        }\n    }, {\n        key: \"_distanceSquared\",\n        value: function _distanceSquared(a, b) {\n            var dx = b.x - a.x;\n            var dy = b.y - a.y;\n            return dx * dx + dy * dy;\n        }\n\n        // Project a point onto a line segment\n        // JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\n\n    }, {\n        key: \"_projectPointToEdge\",\n        value: function _projectPointToEdge(point, line) {\n            var a = line.start;\n            var b = line.end;\n            // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find\n            // where our point lies on the line by solving for t:\n            //  t = [(p-a) . (b-a)] / |b-a|^2\n            var l2 = this._distanceSquared(a, b);\n            var t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;\n            // We clamp t from [0,1] to handle points outside the segment vw.\n            t = Phaser.Math.clamp(t, 0, 1);\n            // Project onto the segment\n            var p = new Phaser.Point(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));\n            return p;\n        }\n    }, {\n        key: \"enableDebug\",\n        value: function enableDebug() {\n            this._debugGraphics = this.game.add.graphics(0, 0);\n            this._debugGraphics.alpha = 0.5;\n        }\n    }, {\n        key: \"disableDebug\",\n        value: function disableDebug() {\n            if (this._debugGraphics) {\n                this._debugGraphics.destroy();\n                this._debugGraphics = null;\n            }\n        }\n    }, {\n        key: \"isDebugEnabled\",\n        value: function isDebugEnabled() {\n            return this._debugGraphics !== null;\n        }\n    }, {\n        key: \"debugClear\",\n        value: function debugClear() {\n            if (this._debugGraphics) this._debugGraphics.clear();\n        }\n\n        /**\r\n         * Visualize the polygons in the nav mesh as an overlay on top of the game\r\n         *\r\n         * @param {object} options\r\n         * @param {boolean} [options.drawCentroid=true] For each polygon, show the approx centroid\r\n         * @param {boolean} [options.drawBounds=false] For each polygon, show the bounding radius\r\n         * @param {boolean} [options.drawNeighbors=true] For each polygon, show the connections to\r\n         * neighbors\r\n         * @param {boolean} [options.drawPortals=true] For each polygon, show the portal edges\r\n         *\r\n         * @memberof NavMesh\r\n         */\n\n    }, {\n        key: \"debugDrawMesh\",\n        value: function debugDrawMesh() {\n            var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                _ref4$drawCentroid = _ref4.drawCentroid,\n                drawCentroid = _ref4$drawCentroid === undefined ? true : _ref4$drawCentroid,\n                _ref4$drawBounds = _ref4.drawBounds,\n                drawBounds = _ref4$drawBounds === undefined ? false : _ref4$drawBounds,\n                _ref4$drawNeighbors = _ref4.drawNeighbors,\n                drawNeighbors = _ref4$drawNeighbors === undefined ? true : _ref4$drawNeighbors,\n                _ref4$drawPortals = _ref4.drawPortals,\n                drawPortals = _ref4$drawPortals === undefined ? true : _ref4$drawPortals;\n\n            if (!this._debugGraphics) this.enableDebug();\n            this._debugGraphics.clear();\n            // Visualize the navigation mesh\n            var _iteratorNormalCompletion9 = true;\n            var _didIteratorError9 = false;\n            var _iteratorError9 = undefined;\n\n            try {\n                for (var _iterator9 = this._navPolygons[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                    var navPoly = _step9.value;\n\n                    navPoly.draw(this._debugGraphics, drawCentroid, drawBounds, drawNeighbors, drawPortals);\n                }\n            } catch (err) {\n                _didIteratorError9 = true;\n                _iteratorError9 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                        _iterator9.return();\n                    }\n                } finally {\n                    if (_didIteratorError9) {\n                        throw _iteratorError9;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"debugDraw\",\n        value: function debugDraw() {\n            var polyPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n            var funnelPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            if (!this._debugGraphics) this.enableDebug();\n\n            // Draw astar path through the polygons\n            if (polyPath) {\n                this._debugGraphics.lineStyle(10, 0x00FF00);\n                this._debugGraphics.moveTo(polyPath[0].centroid.x, polyPath[0].centroid.y);\n                var _iteratorNormalCompletion10 = true;\n                var _didIteratorError10 = false;\n                var _iteratorError10 = undefined;\n\n                try {\n                    for (var _iterator10 = polyPath[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n                        var navPoly = _step10.value;\n\n                        this._debugGraphics.lineTo(navPoly.centroid.x, navPoly.centroid.y);\n                    }\n                } catch (err) {\n                    _didIteratorError10 = true;\n                    _iteratorError10 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion10 && _iterator10.return) {\n                            _iterator10.return();\n                        }\n                    } finally {\n                        if (_didIteratorError10) {\n                            throw _iteratorError10;\n                        }\n                    }\n                }\n\n                var lastPoly = polyPath[polyPath.length - 1];\n                this._debugGraphics.lineTo(lastPoly.centroid.x, lastPoly.centroid.y);\n            }\n\n            // Draw the funneled path\n            if (funnelPath) {\n                this._debugGraphics.lineStyle(5, 0xffd900);\n                var p = new (Function.prototype.bind.apply(Phaser.Polygon, [null].concat(_toConsumableArray(funnelPath))))();\n                p.closed = false;\n                this._debugGraphics.drawShape(p);\n                this._debugGraphics.beginFill(0xffd900);\n                this._debugGraphics.drawEllipse(funnelPath[0].x, funnelPath[0].y, 10, 10);\n                var lastPoint = funnelPath[funnelPath.length - 1];\n                this._debugGraphics.drawEllipse(lastPoint.x, lastPoint.y, 10, 10);\n                this._debugGraphics.endFill();\n            }\n        }\n    }]);\n\n    return NavMesh;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (NavMesh);\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete\n// funnel algorithm so astar checks can be more accurate.\n\n\n\nvar Channel = function () {\n    function Channel() {\n        _classCallCheck(this, Channel);\n\n        this.portals = [];\n    }\n\n    /**\r\n     * @param {Phaser.Point} p1 \r\n     * @param {Phaser.Point} p2 \r\n     * \r\n     * @memberof Channel\r\n     */\n\n\n    _createClass(Channel, [{\n        key: \"push\",\n        value: function push(p1) {\n            var p2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            if (p2 === null) p2 = p1;\n            this.portals.push({\n                left: p1,\n                right: p2\n            });\n        }\n    }, {\n        key: \"stringPull\",\n        value: function stringPull() {\n            var portals = this.portals;\n            var pts = [];\n            // Init scan state\n            var portalApex, portalLeft, portalRight;\n            var apexIndex = 0,\n                leftIndex = 0,\n                rightIndex = 0;\n\n            portalApex = portals[0].left;\n            portalLeft = portals[0].left;\n            portalRight = portals[0].right;\n\n            // Add start point.\n            pts.push(portalApex);\n\n            for (var i = 1; i < portals.length; i++) {\n                // Find the next portal vertices\n                var left = portals[i].left;\n                var right = portals[i].right;\n\n                // Update right vertex.\n                if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__[\"c\" /* triarea2 */])(portalApex, portalRight, right) <= 0.0) {\n                    if (portalApex.equals(portalRight) || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__[\"c\" /* triarea2 */])(portalApex, portalLeft, right) > 0.0) {\n                        // Tighten the funnel.\n                        portalRight = right;\n                        rightIndex = i;\n                    } else {\n                        // Right vertex just crossed over the left vertex, so the left vertex should\n                        // now be part of the path.\n                        pts.push(portalLeft);\n\n                        // Restart scan from portal left point.\n\n                        // Make current left the new apex.\n                        portalApex = portalLeft;\n                        apexIndex = leftIndex;\n                        // Reset portal\n                        portalLeft = portalApex;\n                        portalRight = portalApex;\n                        leftIndex = apexIndex;\n                        rightIndex = apexIndex;\n                        // Restart scan\n                        i = apexIndex;\n                        continue;\n                    }\n                }\n\n                // Update left vertex.\n                if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__[\"c\" /* triarea2 */])(portalApex, portalLeft, left) >= 0.0) {\n                    if (portalApex.equals(portalLeft) || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__[\"c\" /* triarea2 */])(portalApex, portalRight, left) < 0.0) {\n                        // Tighten the funnel.\n                        portalLeft = left;\n                        leftIndex = i;\n                    } else {\n                        // Left vertex just crossed over the right vertex, so the right vertex should\n                        // now be part of the path\n                        pts.push(portalRight);\n\n                        // Restart scan from portal right point.\n\n                        // Make current right the new apex.\n                        portalApex = portalRight;\n                        apexIndex = rightIndex;\n                        // Reset portal\n                        portalLeft = portalApex;\n                        portalRight = portalApex;\n                        leftIndex = apexIndex;\n                        rightIndex = apexIndex;\n                        // Restart scan\n                        i = apexIndex;\n                        continue;\n                    }\n                }\n            }\n\n            if (pts.length === 0 || !pts[pts.length - 1].equals(portals[portals.length - 1].left)) {\n                // Append last point to path.\n                pts.push(portals[portals.length - 1].left);\n            }\n\n            this.path = pts;\n            return pts;\n        }\n    }]);\n\n    return Channel;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Channel);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__nav_mesh__ = __webpack_require__(2);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// const triangulate = require(\"./triangulate\");\n\n\n/**\r\n * This plugin can create and manage a set of navmeshes for a game. Each is stored in the plugin\r\n * under a user-supplied key. The navmeshes can either be constructed algorithmically from convex\r\n * polygons that describe the obstacles in the map or from convex polygons embedded in a Tiled map.\r\n *\r\n * @class NavMeshPlugin\r\n * @extends {Phaser.Plugin}\r\n */\n\nvar NavMeshPlugin = function (_Phaser$Plugin) {\n    _inherits(NavMeshPlugin, _Phaser$Plugin);\n\n    /**\r\n     * Creates an instance of NavMeshPlugin.\r\n     * \r\n     * @param {Phaser.Game} game \r\n     * @param {Phaser.PluginManager} manager \r\n     * \r\n     * @memberOf NavMeshPlugin\r\n     */\n    function NavMeshPlugin(game, manager) {\n        _classCallCheck(this, NavMeshPlugin);\n\n        var _this = _possibleConstructorReturn(this, (NavMeshPlugin.__proto__ || Object.getPrototypeOf(NavMeshPlugin)).call(this, game, manager));\n\n        _this.game = game;\n        _this._pluginManager = manager;\n        _this._navmeshes = {};\n        _this._currentLevel = null;\n        return _this;\n    }\n\n    /**\r\n     * Load a navmesh from Tiled and switch it to be the current navmesh. Currently assumes that the\r\n     * polygons are squares!\r\n     * \r\n     * @param {string} levelName The key to use to store the navmesh in the plugin \r\n     * @param {Phaser.Tilemap} tilemap The tilemap that contains polygons under an object layer\r\n     * @param {string} objectKey The name of the object layer in the tilemap\r\n     * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n     * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n     * \r\n     * @memberof NavMeshPlugin\r\n     */\n\n\n    _createClass(NavMeshPlugin, [{\n        key: \"buildMeshFromTiled\",\n        value: function buildMeshFromTiled(levelName, tilemap, objectKey) {\n            var meshShrinkAmount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n            // Load up the object layer\n            var rects = tilemap.objects[objectKey];\n            // Loop over the objects and construct a polygon\n            var polygons = [];\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = rects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var r = _step.value;\n\n                    var top = r.y;\n                    var bottom = r.y + r.height;\n                    var left = r.x;\n                    var right = r.x + r.width;\n                    var poly = new Phaser.Polygon(left, top, left, bottom, right, bottom, right, top);\n                    polygons.push(poly);\n                }\n                // Build the navmesh, cache it and set it to be the current\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            var navMesh = new __WEBPACK_IMPORTED_MODULE_0__nav_mesh__[\"a\" /* default */](this.game, polygons, meshShrinkAmount);\n            this._navmeshes[levelName] = navMesh;\n            this._currentNavMesh = navMesh;\n            return navMesh;\n        }\n\n        // /**\n        //  * Build a navmesh from an array of convex polygons. This currently tesselates the polygons into\n        //  * triangles. They aren't as efficient or as well designed as ones made by hand in Tiled. \n        //  *\n        //  * @param {string} levelName The key to use to store the navmesh in the plugin  \n        //  * @param {[]} hulls An array of convex polygons describing the obstacles in the\n        //  * level. See lighting-plugin/hull-from-tiles.\n        //  *\n        //  * @memberof NavMeshPlugin\n        //  */\n        // buildMesh(levelName, hulls) {\n        //     const contours = this._buildContours(hulls);\n        //     // Get an array of triangulated vertices\n        //     const triangles = triangulate(contours, false); // Counter-clockwise ordering!\n        //     const polygons = [];\n        //     for (let i = 0; i < triangles.length; i += 6) {\n        //         const poly = new Phaser.Polygon(\n        //             // These should be in counter-clockwise order from triangulate\n        //             triangles[i + 0], triangles[i + 1], \n        //             triangles[i + 2], triangles[i + 3], \n        //             triangles[i + 4], triangles[i + 5]\n        //         );\n        //         polygons.push(poly);\n        //     }\n        //     const navMesh = new NavMesh(this.game, polygons);\n        //     this._navMeshes[levelName] = navMesh;\n        //     this._currentNavMesh = navMesh;\n        // }\n\n        /**\r\n         * Switch the currently loaded navmesh\r\n         *\r\n         * @param {string} levelName Name of the level to look up in the cache of loaded levels \r\n         * \r\n         * @memberof NavMeshPlugin\r\n         */\n\n    }, {\n        key: \"switchLevel\",\n        value: function switchLevel(levelName) {\n            if (this._navmeshes[levelName]) this._currentNavMesh = this._navmeshes[levelName];\n        }\n\n        /**\r\n         * Find a path from the start point to the end point using the currently loaded nav mesh.\r\n         * \r\n         * @param {Phaser.Point} startPoint The starting point in world coordinates\r\n         * @param {Phaser.Point} endPoint The end point in world coordinates\r\n         * @param {boolean} [debugDraw=false] Whether or not to draw debug graphics for the path\r\n         * @returns {Phaser.Point[]|null} An array of points if a path is found, or null if no path\r\n         * \r\n         * @memberof NavMeshPlugin\r\n         */\n\n    }, {\n        key: \"findPath\",\n        value: function findPath(startPoint, endPoint) {\n            var debugDraw = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n            if (!this._currentNavMesh) return null;\n            return this._currentNavMesh.findPath(startPoint, endPoint, debugDraw);\n        }\n\n        // /**\n        //  * @param {[]} hulls \n        //  * @returns \n        //  * \n        //  * @memberof NavMeshPlugin\n        //  */\n        // _buildContours(hulls) {\n        //     const w = this.game.width;\n        //     const h = this.game.height;\n        //     // Start the contours\n        //     const contours = [\n        //         // Full screen - counter clockwise\n        //         Float32Array.of(0,0, 0,h, w,h, w,0)\n        //     ];\n        //     // For each convex hull add the contour\n        //     for (const hull of hulls) {\n        //         const contour = [];\n        //         for (const lineInfo of hull) {\n        //             contour.push(lineInfo.line.start.x, lineInfo.line.start.y);\n        //         }\n        //         contours.push(Float32Array.from(contour));\n        //     }\n        //     return contours;\n        // }\n\n    }]);\n\n    return NavMeshPlugin;\n}(Phaser.Plugin);\n\nPhaser.NavMeshPlugin = NavMeshPlugin;\n/* harmony default export */ __webpack_exports__[\"default\"] = (NavMeshPlugin);\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_javascript_astar__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_javascript_astar__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n/**\r\n * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar\r\n * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavGraph\r\n */\n\nvar NavGraph = function () {\n    function NavGraph(navPolygons) {\n        _classCallCheck(this, NavGraph);\n\n        this.nodes = navPolygons;\n        this.init();\n    }\n\n    _createClass(NavGraph, [{\n        key: \"neighbors\",\n        value: function neighbors(navPolygon) {\n            return navPolygon.neighbors;\n        }\n    }, {\n        key: \"navHeuristic\",\n        value: function navHeuristic(navPolygon1, navPolygon2) {\n            return navPolygon1.centroidDistance(navPolygon2);\n        }\n    }]);\n\n    return NavGraph;\n}();\n\nNavGraph.prototype.init = __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default.a.Graph.prototype.init;\nNavGraph.prototype.cleanDirty = __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default.a.Graph.prototype.cleanDirty;\nNavGraph.prototype.markDirty = __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default.a.Graph.prototype.markDirty;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (NavGraph);\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Debug color palette\nvar palette = [0x00A0B0, 0x6A4A3C, 0xCC333F, 0xEB6841, 0xEDC951];\n\n/**\r\n * A class that represents a navigable polygon in a navmesh. It is build from a Phaser.Polygon. It\r\n * has a drawing function to help visualize it's features:\r\n *  - polygon\r\n *  - neighbors - any navpolys that can be reached from this navpoly\r\n *  - portals - overlapping edges between neighbors\r\n *  - centroid - not a true centroid, just an approximation.\r\n *  - boundingRadius - the radius of a circle at the centroid that fits all the points of the poly \r\n * \r\n * It implements the properties and fields that javascript-astar needs - weight, toString, isWall\r\n * and getCost. See GPS test from astar repo for structure: \r\n * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavPoly\r\n */\n\nvar NavPoly = function () {\n    /**\r\n     * Creates an instance of NavPoly.\r\n     * @param {Phaser.Game} game \r\n     * @param {number} id \r\n     * @param {Phaser.Polygon} polygon \r\n     * \r\n     * @memberof NavPoly\r\n     */\n    function NavPoly(game, id, polygon) {\n        _classCallCheck(this, NavPoly);\n\n        this.game = game;\n        this.id = id;\n        this.polygon = polygon;\n        this.edges = this._calculateEdges();\n        this.neighbors = [];\n        this.portals = [];\n        this.centroid = this._calculateCentroid();\n        this.boundingRadius = this._calculateRadius();\n\n        this.weight = 1; // jsastar property\n\n        var i = this.id % palette.length;\n        this._color = palette[i];\n    }\n\n    _createClass(NavPoly, [{\n        key: \"constains\",\n        value: function constains(point) {\n            return this.polygon.contains(point.x, point.y);\n        }\n\n        // jsastar methods\n\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            return \"NavPoly(id: \" + this.id + \" at: \" + this.centroid + \")\";\n        }\n    }, {\n        key: \"isWall\",\n        value: function isWall() {\n            return this.weight === 0;\n        }\n    }, {\n        key: \"centroidDistance\",\n        value: function centroidDistance(navPolygon) {\n            return this.centroid.distance(navPolygon.centroid);\n        }\n    }, {\n        key: \"getCost\",\n        value: function getCost(navPolygon) {\n            return this.centroidDistance(navPolygon);\n        }\n    }, {\n        key: \"_calculateEdges\",\n        value: function _calculateEdges() {\n            var points = this.polygon.points;\n            var edges = [];\n            for (var i = 1; i < points.length; i++) {\n                var p1 = points[i - 1];\n                var p2 = points[i];\n                edges.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\n            }\n            var first = points[0];\n            var last = points[points.length - 1];\n            edges.push(new Phaser.Line(first.x, first.y, last.x, last.y));\n            return edges;\n        }\n    }, {\n        key: \"_calculateCentroid\",\n        value: function _calculateCentroid() {\n            // NOTE: this is not actually the centroid, it's the average of the vertices - not the same\n            // thing!\n            var centroid = new Phaser.Point(0, 0);\n            var length = this.polygon.points.length;\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.polygon.points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var point = _step.value;\n\n                    centroid.add(point.x, point.y);\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            centroid.divide(length, length);\n            return centroid;\n        }\n    }, {\n        key: \"_calculateRadius\",\n        value: function _calculateRadius() {\n            var boundingRadius = 0;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this.polygon.points[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var point = _step2.value;\n\n                    var d = this.centroid.distance(point);\n                    if (d > boundingRadius) boundingRadius = d;\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            return boundingRadius;\n        }\n\n        /**\r\n         * Draw the polygon to given graphics object\r\n         * \r\n         * @param {Phaser.Graphics} graphics \r\n         * @param {boolean} [drawCentroid=true] Show the approx centroid\r\n         * @param {boolean} [drawBounds=false] Show the bounding radius\r\n         * @param {boolean} [drawNeighbors=true] Show the connections to neighbors\r\n         * @param {boolean} [drawPortals=true] Show the portal edges\r\n         * \r\n         * @memberof NavPoly\r\n         */\n\n    }, {\n        key: \"draw\",\n        value: function draw(graphics) {\n            var drawCentroid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            var drawBounds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n            var drawNeighbors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n            var drawPortals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n            graphics.lineWidth = 0;\n            graphics.beginFill(this._color);\n            graphics.drawPolygon(this.polygon);\n            graphics.endFill();\n\n            if (drawCentroid) {\n                graphics.beginFill(0x000000);\n                graphics.drawEllipse(this.centroid.x, this.centroid.y, 4, 4);\n                graphics.endFill();\n            }\n\n            if (drawBounds) {\n                graphics.lineStyle(1, 0xFFFFFF);\n                var r = this.boundingRadius;\n                graphics.drawEllipse(this.centroid.x, this.centroid.y, r, r);\n            }\n\n            if (drawNeighbors) {\n                graphics.lineStyle(2, 0x000000);\n                var _iteratorNormalCompletion3 = true;\n                var _didIteratorError3 = false;\n                var _iteratorError3 = undefined;\n\n                try {\n                    for (var _iterator3 = this.neighbors[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                        var n = _step3.value;\n\n                        graphics.moveTo(this.centroid.x, this.centroid.y);\n                        graphics.lineTo(n.centroid.x, n.centroid.y);\n                    }\n                } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                            _iterator3.return();\n                        }\n                    } finally {\n                        if (_didIteratorError3) {\n                            throw _iteratorError3;\n                        }\n                    }\n                }\n            }\n\n            if (drawPortals) {\n                graphics.lineStyle(10, 0x000000);\n                var _iteratorNormalCompletion4 = true;\n                var _didIteratorError4 = false;\n                var _iteratorError4 = undefined;\n\n                try {\n                    for (var _iterator4 = this.portals[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                        var p = _step4.value;\n\n                        graphics.moveTo(p.start.x, p.start.y);\n                        graphics.lineTo(p.end.x, p.end.y);\n                    }\n                } catch (err) {\n                    _didIteratorError4 = true;\n                    _iteratorError4 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                            _iterator4.return();\n                        }\n                    } finally {\n                        if (_didIteratorError4) {\n                            throw _iteratorError4;\n                        }\n                    }\n                }\n            }\n        }\n    }]);\n\n    return NavPoly;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (NavPoly);\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// phaser-navmesh-plugin.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b3956335bfed79eef32c","// Twice the area of the triangle formed by a, b and c\r\nexport function triarea2(a, b, c) {\r\n    const ax = b.x - a.x;\r\n    const ay = b.y - a.y;\r\n    const bx = c.x - a.x;\r\n    const by = c.y - a.y;\r\n    return bx * ay - ax * by;\r\n}\r\n\r\nexport function almostEqual(value1, value2, errorMargin = 0.0001) {\r\n    if (Math.abs(value1 - value2) <= errorMargin) return true;\r\n    else return false;\r\n}\r\n\r\n// https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0\r\nexport function angleDifference(x, y) {\r\n    let a = x - y;\r\n    const i = a + Math.PI;\r\n    const j = Math.PI * 2;\r\n    a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign\r\n    a -= Math.PI;\r\n    return a;\r\n}\r\n\r\nexport function areCollinear(line1, line2, errorMargin=0.0001) {\r\n    // Figure out if the two lines are equal by looking at the area of the triangle formed\r\n    // by their points\r\n    const area1 = triarea2(line1.start, line1.end, line2.start);\r\n    const area2 = triarea2(line1.start, line1.end, line2.end);\r\n    if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {\r\n        return true;\r\n    } else return false;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./utils.js","// javascript-astar 0.4.2\r\n// http://github.com/bgrins/javascript-astar\r\n// Freely distributable under the MIT License.\r\n// Implements the astar search algorithm in javascript using a Binary Heap.\r\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\r\n// http://eloquentjavascript.net/appendix2.html\r\n(function(definition) {\r\n  /* global module, define */\r\n  if (typeof module === 'object' && typeof module.exports === 'object') {\r\n    module.exports = definition();\r\n  } else if (typeof define === 'function' && define.amd) {\r\n    define([], definition);\r\n  } else {\r\n    var exports = definition();\r\n    window.astar = exports.astar;\r\n    window.Graph = exports.Graph;\r\n  }\r\n})(function() {\r\n\r\nfunction pathTo(node) {\r\n  var curr = node;\r\n  var path = [];\r\n  while (curr.parent) {\r\n    path.unshift(curr);\r\n    curr = curr.parent;\r\n  }\r\n  return path;\r\n}\r\n\r\nfunction getHeap() {\r\n  return new BinaryHeap(function(node) {\r\n    return node.f;\r\n  });\r\n}\r\n\r\nvar astar = {\r\n  /**\r\n  * Perform an A* Search on a graph given a start and end node.\r\n  * @param {Graph} graph\r\n  * @param {GridNode} start\r\n  * @param {GridNode} end\r\n  * @param {Object} [options]\r\n  * @param {bool} [options.closest] Specifies whether to return the\r\n             path to the closest node if the target is unreachable.\r\n  * @param {Function} [options.heuristic] Heuristic function (see\r\n  *          astar.heuristics).\r\n  */\r\n  search: function(graph, start, end, options) {\r\n    graph.cleanDirty();\r\n    options = options || {};\r\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\r\n    var closest = options.closest || false;\r\n\r\n    var openHeap = getHeap();\r\n    var closestNode = start; // set the start node to be the closest if required\r\n\r\n    start.h = heuristic(start, end);\r\n    graph.markDirty(start);\r\n\r\n    openHeap.push(start);\r\n\r\n    while (openHeap.size() > 0) {\r\n\r\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\r\n      var currentNode = openHeap.pop();\r\n\r\n      // End case -- result has been found, return the traced path.\r\n      if (currentNode === end) {\r\n        return pathTo(currentNode);\r\n      }\r\n\r\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\r\n      currentNode.closed = true;\r\n\r\n      // Find all neighbors for the current node.\r\n      var neighbors = graph.neighbors(currentNode);\r\n\r\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\r\n        var neighbor = neighbors[i];\r\n\r\n        if (neighbor.closed || neighbor.isWall()) {\r\n          // Not a valid node to process, skip to next neighbor.\r\n          continue;\r\n        }\r\n\r\n        // The g score is the shortest distance from start to current node.\r\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\r\n        var gScore = currentNode.g + neighbor.getCost(currentNode);\r\n        var beenVisited = neighbor.visited;\r\n\r\n        if (!beenVisited || gScore < neighbor.g) {\r\n\r\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\r\n          neighbor.visited = true;\r\n          neighbor.parent = currentNode;\r\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\r\n          neighbor.g = gScore;\r\n          neighbor.f = neighbor.g + neighbor.h;\r\n          graph.markDirty(neighbor);\r\n          if (closest) {\r\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\r\n            // a cheaper path than the current closest node then it becomes the closest node\r\n            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\r\n              closestNode = neighbor;\r\n            }\r\n          }\r\n\r\n          if (!beenVisited) {\r\n            // Pushing to heap will put it in proper place based on the 'f' value.\r\n            openHeap.push(neighbor);\r\n          } else {\r\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\r\n            openHeap.rescoreElement(neighbor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (closest) {\r\n      return pathTo(closestNode);\r\n    }\r\n\r\n    // No result was found - empty array signifies failure to find path.\r\n    return [];\r\n  },\r\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\r\n  heuristics: {\r\n    manhattan: function(pos0, pos1) {\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return d1 + d2;\r\n    },\r\n    diagonal: function(pos0, pos1) {\r\n      var D = 1;\r\n      var D2 = Math.sqrt(2);\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\r\n    }\r\n  },\r\n  cleanNode: function(node) {\r\n    node.f = 0;\r\n    node.g = 0;\r\n    node.h = 0;\r\n    node.visited = false;\r\n    node.closed = false;\r\n    node.parent = null;\r\n  }\r\n};\r\n\r\n/**\r\n * A graph memory structure\r\n * @param {Array} gridIn 2D array of input weights\r\n * @param {Object} [options]\r\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\r\n */\r\nfunction Graph(gridIn, options) {\r\n  options = options || {};\r\n  this.nodes = [];\r\n  this.diagonal = !!options.diagonal;\r\n  this.grid = [];\r\n  for (var x = 0; x < gridIn.length; x++) {\r\n    this.grid[x] = [];\r\n\r\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\r\n      var node = new GridNode(x, y, row[y]);\r\n      this.grid[x][y] = node;\r\n      this.nodes.push(node);\r\n    }\r\n  }\r\n  this.init();\r\n}\r\n\r\nGraph.prototype.init = function() {\r\n  this.dirtyNodes = [];\r\n  for (var i = 0; i < this.nodes.length; i++) {\r\n    astar.cleanNode(this.nodes[i]);\r\n  }\r\n};\r\n\r\nGraph.prototype.cleanDirty = function() {\r\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\r\n    astar.cleanNode(this.dirtyNodes[i]);\r\n  }\r\n  this.dirtyNodes = [];\r\n};\r\n\r\nGraph.prototype.markDirty = function(node) {\r\n  this.dirtyNodes.push(node);\r\n};\r\n\r\nGraph.prototype.neighbors = function(node) {\r\n  var ret = [];\r\n  var x = node.x;\r\n  var y = node.y;\r\n  var grid = this.grid;\r\n\r\n  // West\r\n  if (grid[x - 1] && grid[x - 1][y]) {\r\n    ret.push(grid[x - 1][y]);\r\n  }\r\n\r\n  // East\r\n  if (grid[x + 1] && grid[x + 1][y]) {\r\n    ret.push(grid[x + 1][y]);\r\n  }\r\n\r\n  // South\r\n  if (grid[x] && grid[x][y - 1]) {\r\n    ret.push(grid[x][y - 1]);\r\n  }\r\n\r\n  // North\r\n  if (grid[x] && grid[x][y + 1]) {\r\n    ret.push(grid[x][y + 1]);\r\n  }\r\n\r\n  if (this.diagonal) {\r\n    // Southwest\r\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\r\n      ret.push(grid[x - 1][y - 1]);\r\n    }\r\n\r\n    // Southeast\r\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\r\n      ret.push(grid[x + 1][y - 1]);\r\n    }\r\n\r\n    // Northwest\r\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\r\n      ret.push(grid[x - 1][y + 1]);\r\n    }\r\n\r\n    // Northeast\r\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\r\n      ret.push(grid[x + 1][y + 1]);\r\n    }\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nGraph.prototype.toString = function() {\r\n  var graphString = [];\r\n  var nodes = this.grid;\r\n  for (var x = 0; x < nodes.length; x++) {\r\n    var rowDebug = [];\r\n    var row = nodes[x];\r\n    for (var y = 0; y < row.length; y++) {\r\n      rowDebug.push(row[y].weight);\r\n    }\r\n    graphString.push(rowDebug.join(\" \"));\r\n  }\r\n  return graphString.join(\"\\n\");\r\n};\r\n\r\nfunction GridNode(x, y, weight) {\r\n  this.x = x;\r\n  this.y = y;\r\n  this.weight = weight;\r\n}\r\n\r\nGridNode.prototype.toString = function() {\r\n  return \"[\" + this.x + \" \" + this.y + \"]\";\r\n};\r\n\r\nGridNode.prototype.getCost = function(fromNeighbor) {\r\n  // Take diagonal weight into consideration.\r\n  if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\r\n    return this.weight * 1.41421;\r\n  }\r\n  return this.weight;\r\n};\r\n\r\nGridNode.prototype.isWall = function() {\r\n  return this.weight === 0;\r\n};\r\n\r\nfunction BinaryHeap(scoreFunction) {\r\n  this.content = [];\r\n  this.scoreFunction = scoreFunction;\r\n}\r\n\r\nBinaryHeap.prototype = {\r\n  push: function(element) {\r\n    // Add the new element to the end of the array.\r\n    this.content.push(element);\r\n\r\n    // Allow it to sink down.\r\n    this.sinkDown(this.content.length - 1);\r\n  },\r\n  pop: function() {\r\n    // Store the first element so we can return it later.\r\n    var result = this.content[0];\r\n    // Get the element at the end of the array.\r\n    var end = this.content.pop();\r\n    // If there are any elements left, put the end element at the\r\n    // start, and let it bubble up.\r\n    if (this.content.length > 0) {\r\n      this.content[0] = end;\r\n      this.bubbleUp(0);\r\n    }\r\n    return result;\r\n  },\r\n  remove: function(node) {\r\n    var i = this.content.indexOf(node);\r\n\r\n    // When it is found, the process seen in 'pop' is repeated\r\n    // to fill up the hole.\r\n    var end = this.content.pop();\r\n\r\n    if (i !== this.content.length - 1) {\r\n      this.content[i] = end;\r\n\r\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n        this.sinkDown(i);\r\n      } else {\r\n        this.bubbleUp(i);\r\n      }\r\n    }\r\n  },\r\n  size: function() {\r\n    return this.content.length;\r\n  },\r\n  rescoreElement: function(node) {\r\n    this.sinkDown(this.content.indexOf(node));\r\n  },\r\n  sinkDown: function(n) {\r\n    // Fetch the element that has to be sunk.\r\n    var element = this.content[n];\r\n\r\n    // When at 0, an element can not sink any further.\r\n    while (n > 0) {\r\n\r\n      // Compute the parent element's index, and fetch it.\r\n      var parentN = ((n + 1) >> 1) - 1;\r\n      var parent = this.content[parentN];\r\n      // Swap the elements if the parent is greater.\r\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n        this.content[parentN] = element;\r\n        this.content[n] = parent;\r\n        // Update 'n' to continue at the new position.\r\n        n = parentN;\r\n      }\r\n      // Found a parent that is less, no need to sink any further.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  },\r\n  bubbleUp: function(n) {\r\n    // Look up the target element and its score.\r\n    var length = this.content.length;\r\n    var element = this.content[n];\r\n    var elemScore = this.scoreFunction(element);\r\n\r\n    while (true) {\r\n      // Compute the indices of the child elements.\r\n      var child2N = (n + 1) << 1;\r\n      var child1N = child2N - 1;\r\n      // This is used to store the new position of the element, if any.\r\n      var swap = null;\r\n      var child1Score;\r\n      // If the first child exists (is inside the array)...\r\n      if (child1N < length) {\r\n        // Look it up and compute its score.\r\n        var child1 = this.content[child1N];\r\n        child1Score = this.scoreFunction(child1);\r\n\r\n        // If the score is less than our element's, we need to swap.\r\n        if (child1Score < elemScore) {\r\n          swap = child1N;\r\n        }\r\n      }\r\n\r\n      // Do the same checks for the other child.\r\n      if (child2N < length) {\r\n        var child2 = this.content[child2N];\r\n        var child2Score = this.scoreFunction(child2);\r\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\r\n          swap = child2N;\r\n        }\r\n      }\r\n\r\n      // If the element needs to be moved, swap it, and continue.\r\n      if (swap !== null) {\r\n        this.content[n] = this.content[swap];\r\n        this.content[swap] = element;\r\n        n = swap;\r\n      }\r\n      // Otherwise, we are done.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nreturn {\r\n  astar: astar,\r\n  Graph: Graph\r\n};\r\n\r\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/navmesh-phaser-plugin/~/javascript-astar/astar.js\n// module id = 1\n// module chunks = 0 1","import jsastar from \"javascript-astar\";\r\nimport NavPoly from \"./nav-poly\";\r\nimport NavGraph from \"./nav-graph\";\r\nimport Channel from \"./channel\";\r\nimport {angleDifference, areCollinear} from \"./utils\";\r\n\r\n/**\r\n * The workhorse that builds a navigation mesh from a series of polygons. Once built, the mesh can\r\n * be asked for a path from one point to another point. It has debug methods for visualizing paths\r\n * and visualizing the individual polygons. Some internal terminology usage:\r\n * \r\n * - neighbor: a polygon that shares part of an edge with another polygon\r\n * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment\r\n * - channel: the path of polygons from starting point to end point\r\n * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the\r\n *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut\r\n * \r\n * @class NavMesh\r\n */\r\nclass NavMesh {\r\n\r\n    /**\r\n     * Creates an instance of NavMesh.\r\n     * @param {Phaser.Game} game\r\n     * @param {Phaser.Polygon[]} polygons\r\n     * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n     * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n     *\r\n     * @memberof NavMesh\r\n     */\r\n    constructor(game, polygons, meshShrinkAmount = 0) {\r\n        this.game = game;\r\n        this._debugGraphics = null;\r\n        this._meshShrinkAmount = meshShrinkAmount;\r\n\r\n        // Construct NavPoly instances for each polygon\r\n        this._navPolygons = [];\r\n        for (const [i, polygon] of polygons.entries()) {\r\n            this._navPolygons.push(new NavPoly(game, i, polygon));\r\n        }\r\n\r\n        this._calculateNeighbors();\r\n\r\n        // Astar graph of connections between polygons\r\n        this.graph = new NavGraph(this._navPolygons);\r\n    }\r\n\r\n    /**\r\n     * Find a path from the start point to the end point using this nav mesh.\r\n     *\r\n     * @param {Phaser.Point} startPoint\r\n     * @param {Phaser.Point} endPoint\r\n     * @param {object} [drawOptions={}] Options for controlling debug drawing\r\n     * @param {boolean} [drawOptions.drawPolyPath=false] Whether or not to visualize the path\r\n     * through the polygons - e.g. the path that astar found.\r\n     * @param {boolean} [drawOptions.drawFinalPath=false] Whether or not to visualize the path\r\n     * through the path that was returned.\r\n     * @returns {Phaser.Point[]|null} An array of points if a path is found, or null if no path\r\n     *\r\n     * @memberof NavMesh\r\n     */\r\n    findPath(startPoint, endPoint, {drawPolyPath = false, drawFinalPath = false} = {}) {\r\n        let startPoly = null;\r\n        let endPoly = null;\r\n        let startDistance = Number.MAX_VALUE;\r\n        let endDistance = Number.MAX_VALUE;\r\n        let d, r;\r\n\r\n        // Find the closest poly for the starting and ending point\r\n        for (const navPoly of this._navPolygons) {\r\n            r = navPoly.boundingRadius;\r\n            // Start\r\n            d = navPoly.centroid.distance(startPoint);\r\n            if (d <= startDistance && d <= r && navPoly.constains(startPoint)) {\r\n                startPoly = navPoly;\r\n                startDistance = d;\r\n            }\r\n            // End\r\n            d = navPoly.centroid.distance(endPoint);\r\n            if (d <= endDistance && d <= r && navPoly.constains(endPoint)) {\r\n                endPoly = navPoly;\r\n                endDistance = d;\r\n            }\r\n        }\r\n\r\n        // If the start point wasn't inside a polygon, run a more liberal check that allows a point\r\n        // to be within meshShrinkAmount radius of a polygon\r\n        if (!startPoly && this._meshShrinkAmount > 0) {\r\n            for (const navPoly of this._navPolygons) {\r\n                // Check if point is within bounding circle to avoid extra projection calculations\r\n                r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n                d = navPoly.centroid.distance(startPoint);\r\n                if (d <= r) {\r\n                    // Check if projected point is within range of a polgyon and is closer than the\r\n                    // previous point\r\n                    const {distance} = this._projectPointToPolygon(startPoint, navPoly);\r\n                    if (distance <= this._meshShrinkAmount && distance < startDistance) {\r\n                        startPoly = navPoly;\r\n                        startDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Same check as above, but for the end point\r\n        if (!endPoly && this._meshShrinkAmount > 0) {\r\n            for (const navPoly of this._navPolygons) {\r\n                r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n                d = navPoly.centroid.distance(endPoint);\r\n                if (d <= r) {\r\n                    const {distance}  = this._projectPointToPolygon(endPoint, navPoly);\r\n                    if (distance <= this._meshShrinkAmount && distance < endDistance) {\r\n                        endPoly = navPoly;\r\n                        endDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // No matching polygons locations for the start or end, so no path found\r\n        if (!startPoly || !endPoly) return null;\r\n        \r\n        // Search!\r\n        const astarPath = jsastar.astar.search(this.graph, startPoly, endPoly, {\r\n            heuristic: this.graph.navHeuristic\r\n        });\r\n        // jsastar drops the first point from the path, but the funnel algorithm needs it\r\n        astarPath.unshift(startPoly);\r\n        \r\n        // We have a path, so now time for the funnel algorithm\r\n        const channel = new Channel();\r\n        channel.push(startPoint);\r\n        for (let i = 0; i < astarPath.length - 1; i++) {\r\n            const navPolygon = astarPath[i];\r\n            const nextNavPolygon = astarPath[i + 1];\r\n\r\n            // Find the portal\r\n            let portal = null;\r\n            for (let i = 0; i < navPolygon.neighbors.length; i++) {\r\n                if (navPolygon.neighbors[i].id === nextNavPolygon.id) {\r\n                    portal = navPolygon.portals[i];\r\n                }\r\n            }\r\n\r\n            // Push the portal vertices into the channel\r\n            channel.push(portal.start, portal.end);\r\n        }\r\n        channel.push(endPoint);\r\n\r\n        // Pull a string along the channel to run the funnel\r\n        channel.stringPull();\r\n\r\n        // Clone path, excluding duplicates\r\n        let lastPoint = null;\r\n        const phaserPath = [];\r\n        for (const p of channel.path) {\r\n            const newPoint = p.clone();\r\n            if (!lastPoint || !newPoint.equals(lastPoint)) phaserPath.push(newPoint);\r\n            lastPoint = newPoint;\r\n        }\r\n\r\n        // Call debug drawing\r\n        if (drawFinalPath || drawPolyPath) {\r\n            this.debugDraw(\r\n                drawPolyPath ? astarPath : null,\r\n                drawFinalPath ? phaserPath : null \r\n            );\r\n        }\r\n\r\n        return phaserPath;\r\n    }\r\n\r\n    _calculateNeighbors() {\r\n        // Fill out the neighbor information for each navpoly\r\n        for (let i = 0; i < this._navPolygons.length; i++) {\r\n            const navPoly = this._navPolygons[i];\r\n\r\n            for (let j = i + 1; j < this._navPolygons.length; j++) {\r\n                const otherNavPoly = this._navPolygons[j];\r\n\r\n                // Check if the other navpoly is within range to touch\r\n                const d = navPoly.centroid.distance(otherNavPoly.centroid);\r\n                if (d > (navPoly.boundingRadius + otherNavPoly.boundingRadius)) continue;\r\n\r\n                // The are in range, so check each edge pairing\r\n                for (const edge of navPoly.edges) {\r\n                    for (const otherEdge of otherNavPoly.edges) {\r\n                        \r\n                        // If edges aren't collinear, not an option for connecting navpolys\r\n                        if (!areCollinear(edge, otherEdge)) continue;\r\n\r\n                        // If they are collinear, check if they overlap\r\n                        const overlap = this._getSegmentOverlap(edge, otherEdge);\r\n                        if (!overlap) continue;\r\n                        \r\n                        // Connections are symmetric!\r\n                        navPoly.neighbors.push(otherNavPoly);\r\n                        otherNavPoly.neighbors.push(navPoly);\r\n\r\n                        // Calculate the portal between the two polygons - this needs to be in\r\n                        // counter-clockwise order, relative to each polygon\r\n                        const [p1, p2] = overlap;\r\n                        let edgeStartAngle = navPoly.centroid.angle(edge.start);\r\n                        let a1 = navPoly.centroid.angle(overlap[0]);\r\n                        let a2 = navPoly.centroid.angle(overlap[1]);\r\n                        let d1 = angleDifference(edgeStartAngle, a1);\r\n                        let d2 = angleDifference(edgeStartAngle, a2);\r\n                        if (d1 < d2) {\r\n                            navPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n                        } else {\r\n                            navPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\r\n                        }\r\n\r\n                        edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);\r\n                        a1 = otherNavPoly.centroid.angle(overlap[0]);\r\n                        a2 = otherNavPoly.centroid.angle(overlap[1]);\r\n                        d1 = angleDifference(edgeStartAngle, a1);\r\n                        d2 = angleDifference(edgeStartAngle, a2);\r\n                        if (d1 < d2) {\r\n                            otherNavPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n                        } else {\r\n                            otherNavPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\r\n                        }\r\n                            \r\n                        // Two convex polygons shouldn't be connected more than once! (Unless\r\n                        // there are unnecessary vertices...)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check two collinear line segments to see if they overlap by sorting the points.\r\n    // Algorithm source: http://stackoverflow.com/a/17152247\r\n    _getSegmentOverlap(line1, line2) {\r\n        const points = [\r\n            {line: line1, point: line1.start}, \r\n            {line: line1, point: line1.end}, \r\n            {line: line2, point: line2.start}, \r\n            {line: line2, point: line2.end}\r\n        ]; \r\n        points.sort(function (a, b) {\r\n            if (a.point.x < b.point.x) return -1;\r\n            else if (a.point.x > b.point.x) return 1;\r\n            else {\r\n                if (a.point.y < b.point.y) return -1;\r\n                else if (a.point.y > b.point.y) return 1;\r\n                else return 0;\r\n            }\r\n        });\r\n        // If the first two points in the array come from the same line, no overlap\r\n        const noOverlap = points[0].line === points[1].line;\r\n        // If the two middle points in the array are the same coordinates, then there is a \r\n        // single point of overlap.\r\n        const singlePointOverlap = points[1].point.equals(points[2].point);\r\n        if (noOverlap || singlePointOverlap) return null;\r\n        else return [points[1].point, points[2].point];\r\n    }\r\n\r\n    /**\r\n     * Project a point onto a polygon in the shortest distance possible.\r\n     * \r\n     * @param {Phaser.Point} point The point to project\r\n     * @param {NavPoly} navPoly The navigation polygon to test against\r\n     * @returns {{point: Phaser.Point, distance: number}}\r\n     * \r\n     * @memberof NavMesh\r\n     */\r\n    _projectPointToPolygon(point, navPoly) {\r\n        let closestProjection = null;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        for (const edge of navPoly.edges) {\r\n            const projectedPoint = this._projectPointToEdge(point, edge);\r\n            const d = point.distance(projectedPoint);\r\n            if (closestProjection === null || d < closestDistance) {\r\n                closestDistance = d;\r\n                closestProjection = projectedPoint;\r\n            }\r\n        }\r\n        return {point: closestProjection, distance: closestDistance};\r\n    }\r\n\r\n    _distanceSquared(a, b) {\r\n        const dx = b.x - a.x;\r\n        const dy = b.y - a.y;\r\n        return dx * dx + dy * dy;\r\n    }\r\n\r\n    // Project a point onto a line segment\r\n    // JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\r\n    _projectPointToEdge(point, line) {\r\n        const a = line.start;\r\n        const b = line.end;\r\n        // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find\r\n        // where our point lies on the line by solving for t:\r\n        //  t = [(p-a) . (b-a)] / |b-a|^2\r\n        const l2 = this._distanceSquared(a, b);\r\n        let t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;\r\n        // We clamp t from [0,1] to handle points outside the segment vw.\r\n        t = Phaser.Math.clamp(t, 0, 1);\r\n        // Project onto the segment\r\n        const p = new Phaser.Point(\r\n            a.x + t * (b.x - a.x),\r\n            a.y + t * (b.y - a.y)\r\n        );\r\n        return p;        \r\n    }\r\n\r\n    enableDebug() {\r\n        this._debugGraphics = this.game.add.graphics(0, 0);\r\n        this._debugGraphics.alpha = 0.5;\r\n    }\r\n\r\n    disableDebug() {\r\n        if (this._debugGraphics) {\r\n            this._debugGraphics.destroy();\r\n            this._debugGraphics = null;\r\n        }\r\n    }\r\n\r\n    isDebugEnabled() {\r\n        return this._debugGraphics !== null;\r\n    }\r\n\r\n    debugClear() {\r\n        if (this._debugGraphics) this._debugGraphics.clear();\r\n    }\r\n    \r\n    /**\r\n     * Visualize the polygons in the nav mesh as an overlay on top of the game\r\n     *\r\n     * @param {object} options\r\n     * @param {boolean} [options.drawCentroid=true] For each polygon, show the approx centroid\r\n     * @param {boolean} [options.drawBounds=false] For each polygon, show the bounding radius\r\n     * @param {boolean} [options.drawNeighbors=true] For each polygon, show the connections to\r\n     * neighbors\r\n     * @param {boolean} [options.drawPortals=true] For each polygon, show the portal edges\r\n     *\r\n     * @memberof NavMesh\r\n     */\r\n    debugDrawMesh({drawCentroid = true, drawBounds = false, drawNeighbors = true, \r\n            drawPortals = true} = {}) {\r\n        if (!this._debugGraphics) this.enableDebug();\r\n        this._debugGraphics.clear();\r\n        // Visualize the navigation mesh\r\n        for (const navPoly of this._navPolygons) {\r\n            navPoly.draw(this._debugGraphics, drawCentroid, drawBounds, drawNeighbors, drawPortals);\r\n        }\r\n    }\r\n\r\n    debugDraw(polyPath = null, funnelPath = null) {\r\n        if (!this._debugGraphics) this.enableDebug();\r\n\r\n        // Draw astar path through the polygons\r\n        if (polyPath) {\r\n            this._debugGraphics.lineStyle(10, 0x00FF00);\r\n            this._debugGraphics.moveTo(polyPath[0].centroid.x, polyPath[0].centroid.y);\r\n            for (const navPoly of polyPath) {\r\n                this._debugGraphics.lineTo(navPoly.centroid.x, navPoly.centroid.y);\r\n            }\r\n            const lastPoly = polyPath[polyPath.length - 1];\r\n            this._debugGraphics.lineTo(lastPoly.centroid.x, lastPoly.centroid.y);\r\n        }\r\n\r\n        // Draw the funneled path\r\n        if (funnelPath) {\r\n            this._debugGraphics.lineStyle(5, 0xffd900);\r\n            const p = new Phaser.Polygon(...funnelPath);\r\n            p.closed = false;\r\n            this._debugGraphics.drawShape(p); \r\n            this._debugGraphics.beginFill(0xffd900);\r\n            this._debugGraphics.drawEllipse(funnelPath[0].x, funnelPath[0].y, 10, 10);\r\n            const lastPoint = funnelPath[funnelPath.length - 1];\r\n            this._debugGraphics.drawEllipse(lastPoint.x, lastPoint.y, 10, 10);\r\n            this._debugGraphics.endFill();\r\n        }\r\n    }\r\n}\r\n\r\nexport default NavMesh;\n\n\n// WEBPACK FOOTER //\n// ./nav-mesh.js","// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete\r\n// funnel algorithm so astar checks can be more accurate.\r\n\r\nimport {triarea2} from \"./utils\";\r\n\r\nclass Channel {\r\n    constructor() {\r\n        this.portals = [];\r\n    }\r\n\r\n    /**\r\n     * @param {Phaser.Point} p1 \r\n     * @param {Phaser.Point} p2 \r\n     * \r\n     * @memberof Channel\r\n     */\r\n    push(p1, p2 = null) {\r\n        if (p2 === null) p2 = p1;\r\n        this.portals.push({\r\n            left: p1, \r\n            right: p2\r\n        });\r\n    }\r\n\r\n    stringPull() {\r\n        var portals = this.portals;\r\n        var pts = [];\r\n        // Init scan state\r\n        var portalApex, portalLeft, portalRight;\r\n        var apexIndex = 0,\r\n            leftIndex = 0,\r\n            rightIndex = 0;\r\n\r\n        portalApex = portals[0].left;\r\n        portalLeft = portals[0].left;\r\n        portalRight = portals[0].right;\r\n\r\n        // Add start point.\r\n        pts.push(portalApex);\r\n\r\n        for (var i = 1; i < portals.length; i++) {\r\n            // Find the next portal vertices\r\n            var left = portals[i].left;\r\n            var right = portals[i].right;\r\n\r\n            // Update right vertex.\r\n            if (triarea2(portalApex, portalRight, right) <= 0.0) {\r\n                if (portalApex.equals(portalRight) || \r\n                        triarea2(portalApex, portalLeft, right) > 0.0) {\r\n                    // Tighten the funnel.\r\n                    portalRight = right;\r\n                    rightIndex = i;\r\n                } else {\r\n                    // Right vertex just crossed over the left vertex, so the left vertex should\r\n                    // now be part of the path.\r\n                    pts.push(portalLeft);\r\n                    \r\n                    // Restart scan from portal left point.\r\n\r\n                    // Make current left the new apex.\r\n                    portalApex = portalLeft;\r\n                    apexIndex = leftIndex;\r\n                    // Reset portal\r\n                    portalLeft = portalApex;\r\n                    portalRight = portalApex;\r\n                    leftIndex = apexIndex;\r\n                    rightIndex = apexIndex;\r\n                    // Restart scan\r\n                    i = apexIndex;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // Update left vertex.\r\n            if (triarea2(portalApex, portalLeft, left) >= 0.0) {\r\n                if (portalApex.equals(portalLeft) || \r\n                        triarea2(portalApex, portalRight, left) < 0.0) {\r\n                    // Tighten the funnel.\r\n                    portalLeft = left;\r\n                    leftIndex = i;\r\n                } else {\r\n                    // Left vertex just crossed over the right vertex, so the right vertex should\r\n                    // now be part of the path\r\n                    pts.push(portalRight);\r\n                    \r\n                    // Restart scan from portal right point.\r\n\r\n                    // Make current right the new apex.\r\n                    portalApex = portalRight;\r\n                    apexIndex = rightIndex;\r\n                    // Reset portal\r\n                    portalLeft = portalApex;\r\n                    portalRight = portalApex;\r\n                    leftIndex = apexIndex;\r\n                    rightIndex = apexIndex;\r\n                    // Restart scan\r\n                    i = apexIndex;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        if ((pts.length === 0) || (!pts[pts.length - 1].equals(portals[portals.length - 1].left))) {\r\n            // Append last point to path.\r\n            pts.push(portals[portals.length - 1].left);\r\n        }\r\n\r\n        this.path = pts;\r\n        return pts;\r\n    }\r\n}\r\n\r\nexport default Channel;\n\n\n// WEBPACK FOOTER //\n// ./channel.js","// const triangulate = require(\"./triangulate\");\r\nimport NavMesh from \"./nav-mesh\";\r\n\r\n/**\r\n * This plugin can create and manage a set of navmeshes for a game. Each is stored in the plugin\r\n * under a user-supplied key. The navmeshes can either be constructed algorithmically from convex\r\n * polygons that describe the obstacles in the map or from convex polygons embedded in a Tiled map.\r\n *\r\n * @class NavMeshPlugin\r\n * @extends {Phaser.Plugin}\r\n */\r\nclass NavMeshPlugin extends Phaser.Plugin {\r\n    /**\r\n     * Creates an instance of NavMeshPlugin.\r\n     * \r\n     * @param {Phaser.Game} game \r\n     * @param {Phaser.PluginManager} manager \r\n     * \r\n     * @memberOf NavMeshPlugin\r\n     */\r\n    constructor(game, manager) {\r\n        super(game, manager);\r\n        this.game = game;\r\n        this._pluginManager = manager;\r\n        this._navmeshes = {};\r\n        this._currentLevel = null;\r\n    }\r\n\r\n    /**\r\n     * Load a navmesh from Tiled and switch it to be the current navmesh. Currently assumes that the\r\n     * polygons are squares!\r\n     * \r\n     * @param {string} levelName The key to use to store the navmesh in the plugin \r\n     * @param {Phaser.Tilemap} tilemap The tilemap that contains polygons under an object layer\r\n     * @param {string} objectKey The name of the object layer in the tilemap\r\n     * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n     * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n     * \r\n     * @memberof NavMeshPlugin\r\n     */\r\n    buildMeshFromTiled(levelName, tilemap, objectKey, meshShrinkAmount = 0) {\r\n        // Load up the object layer\r\n        const rects = tilemap.objects[objectKey];\r\n        // Loop over the objects and construct a polygon\r\n        const polygons = [];\r\n        for (const r of rects) {\r\n            const top = r.y;\r\n            const bottom = r.y + r.height;\r\n            const left = r.x;\r\n            const right = r.x + r.width;\r\n            const poly = new Phaser.Polygon(left,top, left,bottom, right,bottom, right,top);\r\n            polygons.push(poly);\r\n        }\r\n        // Build the navmesh, cache it and set it to be the current\r\n        const navMesh = new NavMesh(this.game, polygons, meshShrinkAmount);\r\n        this._navmeshes[levelName] = navMesh;\r\n        this._currentNavMesh = navMesh;\r\n        return navMesh;\r\n    }  \r\n\r\n    // /**\r\n    //  * Build a navmesh from an array of convex polygons. This currently tesselates the polygons into\r\n    //  * triangles. They aren't as efficient or as well designed as ones made by hand in Tiled. \r\n    //  *\r\n    //  * @param {string} levelName The key to use to store the navmesh in the plugin  \r\n    //  * @param {[]} hulls An array of convex polygons describing the obstacles in the\r\n    //  * level. See lighting-plugin/hull-from-tiles.\r\n    //  *\r\n    //  * @memberof NavMeshPlugin\r\n    //  */\r\n    // buildMesh(levelName, hulls) {\r\n    //     const contours = this._buildContours(hulls);\r\n    //     // Get an array of triangulated vertices\r\n    //     const triangles = triangulate(contours, false); // Counter-clockwise ordering!\r\n    //     const polygons = [];\r\n    //     for (let i = 0; i < triangles.length; i += 6) {\r\n    //         const poly = new Phaser.Polygon(\r\n    //             // These should be in counter-clockwise order from triangulate\r\n    //             triangles[i + 0], triangles[i + 1], \r\n    //             triangles[i + 2], triangles[i + 3], \r\n    //             triangles[i + 4], triangles[i + 5]\r\n    //         );\r\n    //         polygons.push(poly);\r\n    //     }\r\n    //     const navMesh = new NavMesh(this.game, polygons);\r\n    //     this._navMeshes[levelName] = navMesh;\r\n    //     this._currentNavMesh = navMesh;\r\n    // }\r\n\r\n    /**\r\n     * Switch the currently loaded navmesh\r\n     *\r\n     * @param {string} levelName Name of the level to look up in the cache of loaded levels \r\n     * \r\n     * @memberof NavMeshPlugin\r\n     */\r\n    switchLevel(levelName) {\r\n        if (this._navmeshes[levelName]) this._currentNavMesh = this._navmeshes[levelName];\r\n    }\r\n    \r\n    /**\r\n     * Find a path from the start point to the end point using the currently loaded nav mesh.\r\n     * \r\n     * @param {Phaser.Point} startPoint The starting point in world coordinates\r\n     * @param {Phaser.Point} endPoint The end point in world coordinates\r\n     * @param {boolean} [debugDraw=false] Whether or not to draw debug graphics for the path\r\n     * @returns {Phaser.Point[]|null} An array of points if a path is found, or null if no path\r\n     * \r\n     * @memberof NavMeshPlugin\r\n     */\r\n    findPath(startPoint, endPoint, debugDraw = false) {\r\n        if (!this._currentNavMesh) return null;\r\n        return this._currentNavMesh.findPath(startPoint, endPoint, debugDraw);\r\n    }\r\n\r\n    // /**\r\n    //  * @param {[]} hulls \r\n    //  * @returns \r\n    //  * \r\n    //  * @memberof NavMeshPlugin\r\n    //  */\r\n    // _buildContours(hulls) {\r\n    //     const w = this.game.width;\r\n    //     const h = this.game.height;\r\n    //     // Start the contours\r\n    //     const contours = [\r\n    //         // Full screen - counter clockwise\r\n    //         Float32Array.of(0,0, 0,h, w,h, w,0)\r\n    //     ];\r\n    //     // For each convex hull add the contour\r\n    //     for (const hull of hulls) {\r\n    //         const contour = [];\r\n    //         for (const lineInfo of hull) {\r\n    //             contour.push(lineInfo.line.start.x, lineInfo.line.start.y);\r\n    //         }\r\n    //         contours.push(Float32Array.from(contour));\r\n    //     }\r\n    //     return contours;\r\n    // }\r\n}\r\n\r\nPhaser.NavMeshPlugin = NavMeshPlugin;\r\nexport default NavMeshPlugin;\n\n\n// WEBPACK FOOTER //\n// ./index.js","import jsastar from \"javascript-astar\";\r\n\r\n/**\r\n * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar\r\n * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavGraph\r\n */\r\nclass NavGraph {\r\n    constructor(navPolygons) {\r\n        this.nodes = navPolygons;\r\n        this.init();\r\n    }\r\n\r\n    neighbors(navPolygon) {\r\n        return navPolygon.neighbors;\r\n    }\r\n\r\n    navHeuristic(navPolygon1, navPolygon2) {\r\n        return navPolygon1.centroidDistance(navPolygon2);\r\n    }\r\n}\r\n\r\nNavGraph.prototype.init = jsastar.Graph.prototype.init;\r\nNavGraph.prototype.cleanDirty = jsastar.Graph.prototype.cleanDirty;\r\nNavGraph.prototype.markDirty = jsastar.Graph.prototype.markDirty;\r\n\r\nexport default NavGraph;\n\n\n// WEBPACK FOOTER //\n// ./nav-graph.js","// Debug color palette\r\nconst palette = [0x00A0B0, 0x6A4A3C, 0xCC333F, 0xEB6841, 0xEDC951];\r\n\r\n/**\r\n * A class that represents a navigable polygon in a navmesh. It is build from a Phaser.Polygon. It\r\n * has a drawing function to help visualize it's features:\r\n *  - polygon\r\n *  - neighbors - any navpolys that can be reached from this navpoly\r\n *  - portals - overlapping edges between neighbors\r\n *  - centroid - not a true centroid, just an approximation.\r\n *  - boundingRadius - the radius of a circle at the centroid that fits all the points of the poly \r\n * \r\n * It implements the properties and fields that javascript-astar needs - weight, toString, isWall\r\n * and getCost. See GPS test from astar repo for structure: \r\n * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavPoly\r\n */\r\nclass NavPoly {\r\n    /**\r\n     * Creates an instance of NavPoly.\r\n     * @param {Phaser.Game} game \r\n     * @param {number} id \r\n     * @param {Phaser.Polygon} polygon \r\n     * \r\n     * @memberof NavPoly\r\n     */\r\n    constructor(game, id, polygon) {\r\n        this.game = game;\r\n        this.id = id;\r\n        this.polygon = polygon;\r\n        this.edges = this._calculateEdges();\r\n        this.neighbors = [];\r\n        this.portals = [];\r\n        this.centroid = this._calculateCentroid();\r\n        this.boundingRadius = this._calculateRadius();\r\n\r\n        this.weight = 1; // jsastar property\r\n        \r\n        const i = this.id % palette.length;\r\n        this._color = palette[i];\r\n    }\r\n\r\n    constains(point) {\r\n        return this.polygon.contains(point.x, point.y);\r\n    }\r\n\r\n    // jsastar methods\r\n    toString() {\r\n        return `NavPoly(id: ${this.id} at: ${this.centroid})`;\r\n    }\r\n    isWall() {\r\n        return this.weight === 0;\r\n    }\r\n    centroidDistance(navPolygon) {\r\n        return this.centroid.distance(navPolygon.centroid);\r\n    }\r\n    getCost(navPolygon) {\r\n        return this.centroidDistance(navPolygon);\r\n    }\r\n\r\n    _calculateEdges() {\r\n        const points = this.polygon.points;\r\n        const edges = [];\r\n        for (let i = 1; i < points.length; i++) {\r\n            const p1 = points[i - 1];\r\n            const p2 = points[i];\r\n            edges.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n        }\r\n        const first = points[0];\r\n        const last = points[points.length - 1]\r\n        edges.push(new Phaser.Line(first.x, first.y, last.x, last.y));\r\n        return edges;\r\n    }\r\n    \r\n    _calculateCentroid() {\r\n        // NOTE: this is not actually the centroid, it's the average of the vertices - not the same\r\n        // thing!\r\n        const centroid = new Phaser.Point(0, 0);\r\n        const length = this.polygon.points.length;\r\n        for (const point of this.polygon.points) {\r\n            centroid.add(point.x, point.y);\r\n        }\r\n        centroid.divide(length, length);\r\n        return centroid;\r\n    }\r\n\r\n    _calculateRadius() {\r\n        let boundingRadius = 0;\r\n        for (const point of this.polygon.points) {\r\n            const d = this.centroid.distance(point);\r\n            if (d > boundingRadius) boundingRadius = d;\r\n        }\r\n        return boundingRadius;\r\n    }\r\n\r\n    /**\r\n     * Draw the polygon to given graphics object\r\n     * \r\n     * @param {Phaser.Graphics} graphics \r\n     * @param {boolean} [drawCentroid=true] Show the approx centroid\r\n     * @param {boolean} [drawBounds=false] Show the bounding radius\r\n     * @param {boolean} [drawNeighbors=true] Show the connections to neighbors\r\n     * @param {boolean} [drawPortals=true] Show the portal edges\r\n     * \r\n     * @memberof NavPoly\r\n     */\r\n    draw(graphics, drawCentroid = true, drawBounds = false, drawNeighbors = true, \r\n            drawPortals = true) {\r\n        graphics.lineWidth = 0;\r\n        graphics.beginFill(this._color);\r\n        graphics.drawPolygon(this.polygon);\r\n        graphics.endFill();\r\n\r\n        if (drawCentroid) {\r\n            graphics.beginFill(0x000000);\r\n            graphics.drawEllipse(this.centroid.x, this.centroid.y, 4, 4);\r\n            graphics.endFill();\r\n        }\r\n\r\n        if (drawBounds) {\r\n            graphics.lineStyle(1, 0xFFFFFF);\r\n            const r = this.boundingRadius;\r\n            graphics.drawEllipse(this.centroid.x, this.centroid.y, r, r);\r\n        }\r\n\r\n        if (drawNeighbors) {\r\n            graphics.lineStyle(2, 0x000000);\r\n            for (const n of this.neighbors) {\r\n                graphics.moveTo(this.centroid.x, this.centroid.y);\r\n                graphics.lineTo(n.centroid.x, n.centroid.y);\r\n            }\r\n        }\r\n\r\n        if (drawPortals) {\r\n            graphics.lineStyle(10, 0x000000);\r\n            for (const p of this.portals) {\r\n                graphics.moveTo(p.start.x, p.start.y);\r\n                graphics.lineTo(p.end.x, p.end.y);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default NavPoly;\n\n\n// WEBPACK FOOTER //\n// ./nav-poly.js"],"sourceRoot":""}